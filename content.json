{"meta":{"title":"自留地","subtitle":"大龄程序员笔记","description":"程序员学习笔记, 方便查漏补缺","author":"zhou cheng jie","url":"https://juzipeek.github.io","root":"/"},"pages":[{"title":"","date":"2022-09-03T11:56:36.879Z","updated":"2022-09-03T11:56:36.879Z","comments":true,"path":"links/index.html","permalink":"https://juzipeek.github.io/links/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-09-03T14:09:17.154Z","updated":"2022-09-03T14:09:17.154Z","comments":false,"path":"categories/index.html","permalink":"https://juzipeek.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2022-09-03T12:02:00.000Z","updated":"2022-09-03T16:53:46.324Z","comments":true,"path":"about/index.html","permalink":"https://juzipeek.github.io/about/index.html","excerpt":"","text":"个人信息一个专注于 Nginx/OpenResty 领域的码农, 欢迎来撩. 联系方式 邮箱：&#x63;&#x68;&#x65;&#x6e;&#103;&#106;&#105;&#101;&#46;&#x7a;&#104;&#111;&#117;&#x31;&#48;&#50;&#x34;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d; 微信：HahaZhouCJ GitHub: https://github.com/juzipeek"},{"title":"Repositories","date":"2022-09-03T11:57:18.661Z","updated":"2022-09-03T11:57:18.661Z","comments":false,"path":"repository/index.html","permalink":"https://juzipeek.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-09-03T16:54:04.732Z","updated":"2022-09-03T16:54:04.732Z","comments":false,"path":"tags/index.html","permalink":"https://juzipeek.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"火焰图","slug":"tools-2020-03-13-火焰图","date":"2022-09-03T14:48:00.270Z","updated":"2022-09-03T15:19:56.084Z","comments":true,"path":"2022/09/03/tools-2020-03-13-火焰图/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/tools-2020-03-13-%E7%81%AB%E7%84%B0%E5%9B%BE/","excerpt":"","text":"一 环境准备1. systemtap 安装123$yum install systemtap$yum install kernel-devel$sudo stap -ve &#x27;probe begin &#123; log(&quot;hello world&quot;) exit() &#125;&#x27; 2. 安装 debug 包通过 uname -r 查看系统版本，到网站 http://debuginfo.centos.org/ 下载相应的软件包进行安装。 12345$wget http://debuginfo.centos.org/6/x86_64/kernel-debug-debuginfo-2.6.32-696.20.1.el6.x86_64.rpm$wget http://debuginfo.centos.org/6/x86_64/kernel-debuginfo-2.6.32-696.20.1.el6.x86_64.rpm$wget http://debuginfo.centos.org/6/x86_64/kernel-debuginfo-common-x86_64-2.6.32-696.20.1.el6.x86_64.rpm$rpm -Uhv kernel-debuginfo-*.rpm$rpm -Uhv kernel-debug-*.rpm 使用 yum 安装更方便 123yum search kernel-debugyum install -y kernel-debuginfo-common-x86_64.x86_64 kernel-debug.x86_64 kernel-debug-devel.x86_64 kernel-debuginfo.x86_64debuginfo-install -y kernel-3.10.0-693.el7.x86_64 执行命令测试 1234[root@localhost ~]# stap -L &#x27;kernel.function(&quot;printk&quot;)&#x27;kernel.function(&quot;printk@kernel/printk.c:641&quot;) $fmt:char const* $args:va_list $r:int[root@localhost ~]# stap -L &#x27;process(&quot;/lib64/libc.so.6&quot;).function(&quot;malloc&quot;)&#x27;process(&quot;/lib64/libc-2.12.so&quot;).function(&quot;malloc&quot;) 3. 下载火焰图生成工具12git clone https://github.com/brendangregg/FlameGraph.gitgit clone https://github.com/openresty/openresty-systemtap-toolkit.git 二 NGINX 程序分析1. NGINX 程序安装使用 systemtap 分析 NGINX 非常方便, 正常编译安装进行测试并采集调用栈数据即可. 12345$sudo yum install gcc gcc-c++$cd /opt/nginx-1.12.1$./configure --with-http_dav_module --with-http_stub_status_module --add-module=/opt/nginx-1.12.1/src/dynamod/nginx_accept_language_module$make$make install 2. 采集 NGINX 数据1234$cd /usr/local/nginx/sbin$sudo ./nginx$ps -ef|grep nginx # 查看进程 pid$sudo stap --ldd -d /usr/local/nginx/module/ngx_http_du_entry_module.so -d /usr/local/nginx/sbin/nginx --all-modules -D MAXMAPENTRIES=10240 -D MAXACTION=20000 -D MAXSTRINGLEN=4096 -D MAXBACKTRACE=10240 -x 18421 ngx.stp --vp 0001 &gt; ats.out stap 参数： x : 分析进程 pid ldd : 指定分析的执行程序、动态模块 MAXACTION : 单个探针命中执行的最大次数 MAXSTRINGLEN : 字符串最大长度 MAXBACKTRACE : 栈展开的最大深度 3. 生成 NGINX 运行火焰图12345# 下载火焰图项目代码$git clone https://github.com/brendangregg/FlameGraph.git# 使用 FlameGraph 项目脚本生成火焰图$perl stackcollapse-stap.pl ats.out &gt; ats.out2$perl flamegraph.pl ats.out2 &gt; ats.svg 将生成的 ats.svg 文件在浏览器打开就可以看到火焰图。 三 OpenResty 程序分析如果不需要分析 lua 调用栈, 可以使用分析 NGINX 方法生成火焰图. 如果需要分析 lua 调用栈, 需要使用 OpenResty 社区的分析工具进行分析. 1. lj-lua-stacks 下载1git clone https://github.com/openresty/stapxx 2. OpenResty 编译目前火焰图工具不支持 GC64 需要使用 --without-luajit-gc64 关闭 GC64 选项. 同时需要区分 OpenResty 版本是否默认启用 luajit, 可以使用 --with-luajit 开启. 12345$./configure --prefix=/usr/local \\--with-debug --with-pcre-jit --with-ipv6 \\--without-luajit-gc64 --with-luajit$make &amp;&amp; make install 3. 采集数据123456$lj-lua-stacks.sxx -I ./stapxx/tapset -D MAXMAPENTRIES=102400 --arg time=10 --skip-badvars -x 1398924 &gt; a.bt# 下载火焰图项目代码$git clone https://github.com/brendangregg/FlameGraph.git# 使用 FlameGraph 项目脚本生成火焰图$stackcollapse-stap.pl a.bt &gt; a.cbt$flamegraph.pl --encoding=&quot;ISO-8859-1&quot; --title=&quot;Lua-land on-CPU flamegraph&quot; a.cbt &gt; a.svg lj-lua-stacks 参数: -I ./stapxx/tapset 指定 stap++ 依赖库目录. -D MAXMAPENTRIES=102400 指定 stap 使用 map 的最大记录数. --arg time=10 采集时间, 单位秒. -x 1398924 Nginx Worker 进程号. 四 火焰图含义 y 轴表示调用栈，每一层都是一个函数。调用栈越深，火焰就越高，顶部就是正在执行的函数，下方都是它的父函数。 x 轴表示抽样数，如果一个函数在 x 轴占据的宽度越宽，就表示它被抽到的次数多，即执行的时间长。注意，x 轴不代表时间，而是所有的调用栈合并后，按字母顺序排列的。 火焰图就是看顶层的哪个函数占据的宽度最大。只要有”平顶”（plateaus），就表示该函数可能存在性能问题。颜色没有特殊含义，因为火焰图表示的是 CPU 的繁忙程度，所以一般选择暖色调。 五 参考资料 systemtap 文档主页 火焰图资料 突破systemtap脚本对资源使用的限制 stap++ openresty-systemtap-toolkit","categories":[{"name":"tools","slug":"tools","permalink":"https://juzipeek.github.io/categories/tools/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://juzipeek.github.io/tags/nginx/"},{"name":"openresty","slug":"openresty","permalink":"https://juzipeek.github.io/tags/openresty/"},{"name":"systemtap","slug":"systemtap","permalink":"https://juzipeek.github.io/tags/systemtap/"},{"name":"flamegraph","slug":"flamegraph","permalink":"https://juzipeek.github.io/tags/flamegraph/"}]},{"title":"wrk 使用","slug":"tools-2019-01-17-wrk-使用","date":"2022-09-03T14:48:00.269Z","updated":"2022-09-03T14:52:18.054Z","comments":true,"path":"2022/09/03/tools-2019-01-17-wrk-使用/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/tools-2019-01-17-wrk-%E4%BD%BF%E7%94%A8/","excerpt":"","text":"安装wrk 安装123456git clone https://github.com/wg/wrk.gitcd wrkmakecp wrk /usr/local/bincp wrk /usr/bin lzlib 安装lzlib 编译产生 zlib.so 提供 compress/uncompress 功能。到网站 http://luaforge.net/projects/lzlib/ 下载 lzlib。 12345wget http://files.luaforge.net/releases/lzlib/lzlib/lzlib-0.4-work3/lzlib-0.4-work3.tar.gztar zxvf lzlib-0.4-work3.tar.gzcd lzlib-0.4-work3makecp zlib.so ~/wrk_test/ 测试脚本编写123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121------ 环境信息--- Lua 5.1.5--- LuaJIT 2.0.5---local bit = require &quot;bit&quot;local zlib = require &quot;zlib&quot;local data = &#x27;%s-%s&#x27;local mac_data_file = &quot;file_1.txt&quot;local imei_data_file = &quot;file_2.txt&quot;------ 从文本文件载入数据到 table--- 参数：--- tb 载入数据的 table--- file_name 数据文件路径---local function load_data(tb, file_name) local tpl = &quot;%s&quot; for e in io.lines(file_name) do table.insert(tb, tpl.format(e)) endend------ 从文本文件载入数据到 table--- 参数：--- tb 载入数据的 table--- file_name 数据文件路径---local function private_enc(raw, key) local compressed_data = zlib.compress(raw) local compressed_bytes = &#123; string.byte(compressed_data, 1, -1) &#125; local key_bytes = &#123; string.byte(key, 1, -1) &#125; local encryped_data = &#123;&#125; local key_len = #key_bytes for i in pairs(compressed_bytes) do local a = bit.bxor(compressed_bytes[i], key_bytes[(i - 1) % key_len + 1]) table.insert(encryped_data, string.char(a)) end return table.concat(encryped_data, &quot;&quot;)endlocal mac_table = &#123;&#125;local imei_table = &#123;&#125;load_data(mac_table, mac_data_file)load_data(imei_table, imei_data_file)local mac_table_len = #mac_tablelocal imei_table_len = #imei_tablelocal counter = 1local all_threads = &#123;&#125;------ wrk 就会在测试线程已经初始化但还没有启动的时候调用该方法。--- wrk 会为每一个测试线程调用一次 setup 方法，并传入代表测试线程的对象 thread 作为参数。--- setup 方法中可操作该 thread 对象，获取信息、存储信息、甚至关闭该线程。---function setup(thread) thread:set(&quot;id&quot;, counter) counter = counter + 1 table.insert(all_threads, thread)end------ 每个线程仅调用 1 次，args 用于获取命令行中传入的参数---function init(args) -- ok_count、all_count 会存储在线程变量中 -- wrk.thread:set(&quot;all_count&quot;, 0) -- wrk.thread:set(&quot;ok_count&quot;, 0) ok_count = 0 all_count = 0end------ 请求---function request() local mac_idx = math.random(mac_table_len) local imei_idx = math.random(imei_table_len) local mac = mac_table[mac_idx] local imei = imei_table[imei_idx] all_count=all_count + 1 local raw_data = string.format(data, mac, imei) local key = &quot;key&quot; local post_data = private_enc(raw_data, key) local post_data_len = string.len(post_data) local header = &#123; [&quot;Content-Type&quot;] = &quot;application/json&quot;, [&quot;Content-Length&quot;] = post_data_len &#125; return wrk.format(&quot;POST&quot;, &quot;/r?v=5.2&amp;e=1&amp;c=1&quot;, header, post_data)endfunction response(status, headers, body) if 200 == status then ok_count = ok_count + 1 endendfunction done(summary, latency, requests) local msg = &quot;made %d requests and got %d responses ok&quot; print(msg:format(all_count, ok_count))end 测试命令1wrk -d 2s -t 3 -c 3 -T 1s -s wrk_gen_data.lua --latency &quot;http://127.0.0.1:8080/r?v=5.2&amp;c=1&amp;e=1&quot;","categories":[{"name":"tools","slug":"tools","permalink":"https://juzipeek.github.io/categories/tools/"}],"tags":[{"name":"lua","slug":"lua","permalink":"https://juzipeek.github.io/tags/lua/"},{"name":"wrk","slug":"wrk","permalink":"https://juzipeek.github.io/tags/wrk/"}]},{"title":"ss server 搭建","slug":"tools-2019-02-10-ss-server-搭建","date":"2022-09-03T14:48:00.269Z","updated":"2022-09-03T14:52:30.377Z","comments":true,"path":"2022/09/03/tools-2019-02-10-ss-server-搭建/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/tools-2019-02-10-ss-server-%E6%90%AD%E5%BB%BA/","excerpt":"","text":"搭建 ss 服务器1234567891011sudo apt update#sudo apt install gcc#sudo apt install python3-pip#sudo apt install build-essential #sudo apt install openssl#sudo apt install libssl-dev#pip3 install gevent#pip3 install shadowsockssudo apt install shadowsocks 配置文件1sudo vi /etc/shadowsocks/config.json 配置文件内容： 12345678910111213&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;server_port&quot;:8388, &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;D2qtfeXlvz5t+SC&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;: false, &quot;workers&quot;: 1, &quot;prefer_ipv6&quot;: false&#125; 启动1sudo ssserver -c /etc/shadowsocks/config.json -d start 服务自启动12sudo vi /etc/systemd/system/shadowsocks.servicesudo chmod 755 /etc/systemd/system/shadowsocks.service shadowsocks.service 文件内容如下： 123456789101112131415161718[Unit]Description=ShadowsocksAfter=network.target[Service]Type=forkingPIDFile=/run/shadowsocks/server.pidPermissionsStartOnly=trueExecStartPre=/bin/mkdir -p /run/shadowsocksExecStartPre=/bin/chown root:root /run/shadowsocksExecStart=/usr/local/bin/ssserver --pid-file /var/run/shadowsocks/server.pid -c /etc/shadowsocks/config.json -d startRestart=on-abortUser=rootGroup=rootUMask=0027[Install]WantedBy=multi-user.target 服务器选择可以选择在 aws 或 vultr 购买主机，vultr 美国区主机最低 2.5$ 每个月。","categories":[{"name":"tools","slug":"tools","permalink":"https://juzipeek.github.io/categories/tools/"}],"tags":[{"name":"ss","slug":"ss","permalink":"https://juzipeek.github.io/tags/ss/"},{"name":"shadowsocks","slug":"shadowsocks","permalink":"https://juzipeek.github.io/tags/shadowsocks/"}]},{"title":"git 端点续传","slug":"tools-2019-04-05-git-端点续传","date":"2022-09-03T14:48:00.269Z","updated":"2022-09-03T14:57:30.485Z","comments":true,"path":"2022/09/03/tools-2019-04-05-git-端点续传/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/tools-2019-04-05-git-%E7%AB%AF%E7%82%B9%E7%BB%AD%E4%BC%A0/","excerpt":"","text":"概述在使用 git 拉大项目时有时需要中断，如果网络状况不好不断的取消尝试非常头痛。可以使用 git fetch 来避免重复下载，实现类似端点续传功能。 12345678mkdir project_namecd project_namegit init# 拉取远程仓储git fetch [remote project url] [master]# 检出代码git checkout FETCH_HEAD","categories":[{"name":"tools","slug":"tools","permalink":"https://juzipeek.github.io/categories/tools/"}],"tags":[{"name":"git","slug":"git","permalink":"https://juzipeek.github.io/tags/git/"}]},{"title":"keepalived 学习","slug":"network-2020-02-16-keepalived","date":"2022-09-03T14:47:51.091Z","updated":"2022-09-03T14:52:03.702Z","comments":true,"path":"2022/09/03/network-2020-02-16-keepalived/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/network-2020-02-16-keepalived/","excerpt":"","text":"一 概述keepalived 提供了三个主要功能:管理 LVS, LVS 集群健康检查, 实现系统网络服务高可用性. Keepalived 是通过 VRRP (Virtual Router Redundancy Protocol, 虚拟路由器冗余协议）来实现网络高可用的, 当 Master 节点不可用时 Backup 节点会接管 IP 资源。当 Master 节点恢复时, Backup 节点会释放结果的 IP 资源. 1. 安装启动123456$cd keepalived$./build_setup$./configure --prefix=/usr/local/keepalived$make$sudo make install$sudo /usr/local/keepalived/sbin/keepalived -G -D -l -f /usr/local/keepalived/etc/keepalived/keepalived.conf 二 虚拟路由冗余协议VRRP (Virtual Router Redundancy Protocol 虚拟路由器冗余协议), 是为消除在静态缺省路由环境下的缺省路由器单点故障引起的网络失效而设计的主备模式的协议，使得在发生故障而进行设备功能切换时可以不影响内外数据通信，不需要再修改内部网络的网络参数。VRRP 协议具有 IP地址备份、优先路由选择功能。 VRRP 协议将两台或多台路由器设备虚拟成一个设备, 对外提供虚拟路由器 IP(一个或多个). 而在路由器组内部, 如果实际拥有这个对外 IP 的路由器如果工作正常的话就是 MASTER, 或者是通过算法选举产生，MASTER 实现针对虚拟路由器 IP 的各种网络功能，如 ARP 请求, ICMP, 以及数据的转发等; 其他设备不拥有该 IP, 状态是 BACKUP, 除了接收 MASTER 的 VRRP 状态通告信息外, 不执行对外的网络功能. 当主机失效时, BACKUP 将接管原先 MASTER 的网络功能. 配置 VRRP 协议时需要配置每个路由器的虚拟路由器 ID(VRID)和优先权值. 使用 VRID 将路由器进行分组, 具有相同 VRID 值的路由器为同一个组, VRID是一个 0～255 的正整数. 同一组中的路由器通过使用优先权值来选举 MASTER, 优先权大者为 MASTER, 优先权也是一个 0～255 的正整数。如果优先权相同, IP 地址大的为 Master. VRRP 协议使用多播数据来传输 VRRP 数据, VRRP 数据使用特殊的虚拟源 MAC 地址发送数据而不是自身网卡的 MAC 地址. VRRP 运行时只有 MASTER 路由器定时发送 VRRP 通告信息, 表示 MASTER 工作正常. BACKUP 只接收 VRRP 数据, 不发送数据, 如果一定时间内没有接收到 MASTER 的通告信息, 各 BACKUP 将宣告自己成为 MASTER, 发送通告信息, 重新进行 MASTER 选举状态. VRRP 使用 224.0.0.18 作为广播地址, 使用 IP 协议传输数据. VRRP 协议格式: 12345678910111213141516171819 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|Version| Type | Virtual Rtr ID| Priority | Count IP Addrs|+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Auth Type | Adver Int | Checksum |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| IP Address (1) |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| . || . || . |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| IP Address (n) |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Authentication Data (1) |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Authentication Data (2) |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 1. 单播除了组播外, keepalived 支持使用单播进行工作.需要修改配置文件关闭 vrrp_strict 选项, 并配置单播地址. 三 实现keepalived 中包含三个主要模块: core, check, vrrp. core 是程序运行主模块, 用来启动管理 check, vrrp 进程, 当 check, vrrp 进程挂掉时拉起进程. check 用来对 realserver 进行检测. vrrp 进行用来实现 vrrp 逻辑. keepalived 中使用红黑树进行定时器管理, epoll 来进行网络事件处理. 在 vrrp_dispatcher_init 函数中调用 vrrp_register_workers 注册所有 socket 的读事件处理函数为 vrrp_read_dispatcher_thread, 用来处理 VRRP 通知消息, 最后会增加定时器触发 vrrp_read_dispatcher_thread, 进行 VRRP 超时检查. VRRP 子进程启动时, 会调用 vrrp_restore_interfaces_startup 函数, 依次对所有的 VIP 接口调用 vrrp_restore_interface 函数进行 VRRP 恢复. 在 start_vrrp 中会添加 vrrp_dispatcher_init 定时器, 触发发送 VRRP 通告. 1. 调试使用 gdb 调试 keepalived 来分析源码. 因为会 fork 子进程进行处理, 需要使用 set follow-fork-mode child 配置在 fork 时调试子进程. 1234sudo gdb /usr/local/keepalived/sbin/keepalivedset args -n -G -D -l -f /usr/local/keepalived/etc/keepalived/keepalived.conf# 在 start_vrrp_child 函数内设置跟随子进程set follow-fork-mode child 2. 发送通告vrrp_send_pkt 函数实现通告发送, 使用配置的组播地址(224.0.0.18)作为目的地址. 123456789101112131415161718192021222324252627282930313233343536static ssize_tvrrp_send_pkt(vrrp_t * vrrp, unicast_peer_t *peer)&#123; struct sockaddr_storage *src = &amp;vrrp-&gt;saddr; struct msghdr msg; struct iovec iov; char cbuf[256]; /* Build the message data */ memset(&amp;msg, 0, sizeof(msg)); msg.msg_iov = &amp;iov; msg.msg_iovlen = 1; // 发送的 IP 数据包(datagram)内容 iov.iov_base = vrrp-&gt;send_buffer; iov.iov_len = vrrp-&gt;send_buffer_size; /* Unicast sending path */ if (peer &amp;&amp; peer-&gt;address.ss_family == AF_INET) &#123; msg.msg_name = &amp;peer-&gt;address; msg.msg_namelen = sizeof(struct sockaddr_in); &#125; else if (peer &amp;&amp; peer-&gt;address.ss_family == AF_INET6) &#123; msg.msg_name = &amp;peer-&gt;address; msg.msg_namelen = sizeof(struct sockaddr_in6); vrrp_build_ancillary_data(&amp;msg, cbuf, src, vrrp); &#125; else if (vrrp-&gt;family == AF_INET) &#123; /* Multicast sending path */ msg.msg_name = &amp;global_data-&gt;vrrp_mcast_group4; // 配置的组播地址 msg.msg_namelen = sizeof(struct sockaddr_in); &#125; else if (vrrp-&gt;family == AF_INET6) &#123; msg.msg_name = &amp;global_data-&gt;vrrp_mcast_group6; msg.msg_namelen = sizeof(struct sockaddr_in6); vrrp_build_ancillary_data(&amp;msg, cbuf, src, vrrp); &#125; /* Send the packet */ return sendmsg(vrrp-&gt;sockets-&gt;fd_out, &amp;msg, (peer) ? 0 : MSG_DONTROUTE);&#125; 参考文档 keepalived manpage keepalived docs keepalived 实现服务高可用 Keepalived原理与实战精讲–VRRP协议 使用 GDB 调试多进程程序","categories":[{"name":"Network","slug":"Network","permalink":"https://juzipeek.github.io/categories/Network/"}],"tags":[{"name":"network","slug":"network","permalink":"https://juzipeek.github.io/tags/network/"},{"name":"keepalived","slug":"keepalived","permalink":"https://juzipeek.github.io/tags/keepalived/"},{"name":"ip","slug":"ip","permalink":"https://juzipeek.github.io/tags/ip/"},{"name":"multi-cast","slug":"multi-cast","permalink":"https://juzipeek.github.io/tags/multi-cast/"}]},{"title":"主机协议栈探测","slug":"network-2019-03-16-探测支持协议栈","date":"2022-09-03T14:47:51.090Z","updated":"2022-09-03T14:51:33.609Z","comments":true,"path":"2022/09/03/network-2019-03-16-探测支持协议栈/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/network-2019-03-16-%E6%8E%A2%E6%B5%8B%E6%94%AF%E6%8C%81%E5%8D%8F%E8%AE%AE%E6%A0%88/","excerpt":"","text":"说明本文摘自网络文章：百度 App 网络深度优化系列《一》DNS 优化，在此处备录。 IPv4/IPv6 协议栈探测客户端同时知道服务端的 IPv4 和 IPv6 地址，如何判断客户端主机支持的协议栈并做出选择？如果选择 TCP 虽然可以实现地址（IPv4 或 IPv6 地址）端口可用，但是 TCP 是面向连接的在 TCP Connect 阶段会发起三次握手发生网络真实损耗。如果使用 UDP Connect，无需建立连接便能收发数据，调用 UDP Connect 方法时系统会检测地址、端口是否正确，然后记录对端的 IP 地址和端口号，并返回不会发生真实的网络损耗。只有调用 send 或 sendto 时才会发生真实的网络损耗。 原文连接 文章地址","categories":[{"name":"Network","slug":"Network","permalink":"https://juzipeek.github.io/categories/Network/"}],"tags":[{"name":"network","slug":"network","permalink":"https://juzipeek.github.io/tags/network/"},{"name":"tcp","slug":"tcp","permalink":"https://juzipeek.github.io/tags/tcp/"},{"name":"udp","slug":"udp","permalink":"https://juzipeek.github.io/tags/udp/"}]},{"title":"lua c api - registry","slug":"lua-2019-07-10-lua-c-api-registry","date":"2022-09-03T14:47:43.664Z","updated":"2022-09-03T14:50:38.930Z","comments":true,"path":"2022/09/03/lua-2019-07-10-lua-c-api-registry/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/lua-2019-07-10-lua-c-api-registry/","excerpt":"","text":"一 registryregistry 是一个单独的表，用来保存 lua 中的全局变量，同时 lua 代码不能直接访问（只能通过 c 函数接口访问）。registry 通过伪索引（LUA_REGISTRYINDEX）访问，伪索引类似于栈上的索引，但是它的关联数据并未在栈中。 registry 的存在是用来解决一个问题：在 c 动态库中如何保存一个 lua 状态机的全局变量。如果使用 c 的全局变量、静态变量，相同进程内的所有 lua 状态机会共享此变量。如果将值保存在 lua 中的全局 table 中，lua 代码是可以直接访问、修改的；没有限制措施，数据被修改后非常容易导致 c 动态库崩溃。 使用 registry 可以实现针对每个 state 保存全局变量，同时不同动态库直接可以通过约定的 key 从 registry 中获得值，进行交互。 如果动态库（.so）不希望其他库修改自己设置的全局变量，一个好的方法是使用全局变量的地址作为 key。此时需要取全局变量地址，并转换为 lightuserdata 作为 registry 的 key。 1. 示例代码123456789101112131415/* * 在 registry 全局表中保存一条记录 * registry[key] = value */void state_store_global_var(lua_State *state, char *key, char *value)&#123; if (!state||!key||!value) return; lua_pushstring(state, key); // 入栈 lua_pushstring(state, value); // 入栈 // 操作 registy table // registy[key] = value lua_settable(state, LUA_REGISTRYINDEX);&#125; 二 references如果想在 registry 中添加记录而又不想费劲考虑如何分配 key，可以使用 reference 系统。reference 系统可以自动生成一个唯一 key。 1int r = luaL_ref(L, LUA_REGISTRYINDEX); 这个函数会从栈顶弹出一个元素，并保存到 registry 中，同时返回唯一数值 r 作为索引。数值 r 就叫做栈顶值的“引用”（reference）。 从这可以看出，用户不能在 registry 中使用数值作为 key，避免影响 reference 系统。 在 c 中无法直接使用指向 lua 的 table、function 类型指针（未提供此类接口），我们可以使用引用实现类似指针的功能。假设上面的例子中栈顶元素为 table，我们已经创建了它的一个引用，下面我们将其再次放入栈顶： 1lua_rawgeti(L, LUA_REGISTRYINDEX, r); 在引用使用结束后，我们需要使用 luaL_unref 释放引用值与引用自身： 1luaL_unref(L, LUA_REGISTRYINDEX, r); 三 UpvaluesUpvalue 存在的目的是为了在 c 中实现闭包功能。Upvalue 仅在函数内可见，并且在每个函数中是相互独立的。示例代码： 1234567891011121314151617181920// 定义函数static int counter(lua_State *L);int newCounter(lua_State *L) &#123; lua_pushnumber(L, 0); // 栈顶增加数字，后续作为闭包的值 // 创建闭包 // &amp;counter 是闭包基函数；注意是函数名取地址 // 1 告诉闭包 upvalue 的数目 lua_pushcclosure(L, &amp;counter, 1); return 1;&#125;static int counter(lua_State *L) &#123; // lua_upvalueindex 同样适用伪索引技术，取 counter 函数的第一个 upvale double val = lua_tonumber(L, lua_upvalueindex(1)); lua_pushnumber(L, ++val); // 栈顶值为 upvalue 值加 1 lua_pushvalue(L, -1); // 栈顶增加一个相同值，用来更新 upvalue 值 lua_replace(L, lua_upvalueindex(1)); // 更新 upvalue 值 return 1;&#125; 1. 闭包示例代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546// gcc -fPIC -I/usr/local/lua5.1.5/include -g -c counter.c -Wall// gcc -shared -I/usr/local/lua5.1.5/include -L/usr/local/lua5.1.5/lib -llua -o counter.so counter.o#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &quot;lua.h&quot;#include &quot;lauxlib.h&quot;#include &quot;lualib.h&quot;static int counter(lua_State *L) &#123; // lua_upvalueindex 同样适用伪索引技术，取 counter 函数的第一个 upvale double val = lua_tonumber(L, lua_upvalueindex(1)); lua_pushnumber(L, ++val); // 栈顶值为 upvalue 值加 1 lua_pushvalue(L, -1); // 栈顶增加一个相同值，用来更新 upvalue 值 lua_replace(L, lua_upvalueindex(1)); // 更新 upvalue 值 return 1;&#125;static int newCounter(lua_State *L) &#123; lua_pushnumber(L, 0); // 栈顶增加数字，后续作为闭包的值 // 创建闭包 // &amp;counter 是闭包基函数；注意是函数名取地址 // 1 告诉闭包 upvalue 的数目 lua_pushcclosure(L, &amp;counter, 1); return 1;&#125;static const struct luaL_reg counter_lib[] = &#123; &#123;&quot;newCounter&quot;, newCounter&#125;, &#123;NULL, NULL&#125;&#125;;/****************************************************************************** * 注册函数 * 注意，在 lua 中 require 时，必须与 luaopen_xxxx 相同 ******************************************************************************/int luaopen_counter(lua_State *l) &#123; luaL_openlib(l, &quot;counter&quot;, counter_lib, 0); return 1;&#125; newCounter 在 C 中创建一个闭包，返回给 lua 使用。 123456789-- use package.loadlib or require to dynamic library-- l,e = package.loadlib(&quot;./counter.so&quot;, &quot;luaopen_counter&quot;)require &quot;counter&quot;c1 = counter.newCounter()print(type(c1)) --&gt; functionc2 = counter.newCounter()print(c1()) --&gt; 1print(c1()) --&gt; 2print(c2()) --&gt; 1 2. 程序说明12345678910111213141516171819202122232425262728293031323334353637#define luaI_openlib luaL_openLibtypedef struct luaL_Reg &#123;const char *name;lua_CFunction func;&#125; luaL_Reg;/* luaL_register 实际调用的也是 luaI_openlib 函数 */LUALIB_API void (luaL_register) (lua_State *L, const char *libname, const luaL_Reg *l) &#123;luaI_openlib(L, libname, l, 0);&#125;LUALIB_API void luaI_openlib (lua_State *L, const char *libname, const luaL_Reg *l, int nup) &#123;if (libname) &#123;int size = libsize(l);/* check whether lib already exists */luaL_findtable(L, LUA_REGISTRYINDEX, &quot;_LOADED&quot;, 1);lua_getfield(L, -1, libname); /* get _LOADED[libname] */if (!lua_istable(L, -1)) &#123; /* not found? */lua_pop(L, 1); /* remove previous result *//* try global variable (and create one if it does not exist) */if (luaL_findtable(L, LUA_GLOBALSINDEX, libname, size) != NULL)luaL_error(L, &quot;name conflict for module &quot; LUA_QS, libname);lua_pushvalue(L, -1);lua_setfield(L, -3, libname); /* _LOADED[libname] = new table */&#125;lua_remove(L, -2); /* remove _LOADED table */lua_insert(L, -(nup+1)); /* move library table to below upvalues */&#125;for (; l-&gt;name; l++) &#123;int i;for (i=0; i&lt;nup; i++) /* copy upvalues to the top */lua_pushvalue(L, -nup);lua_pushcclosure(L, l-&gt;func, nup);lua_setfield(L, -(nup+2), l-&gt;name);&#125;lua_pop(L, nup); /* remove upvalues */&#125; luaL_register\\luaI_openlib\\luaL_openlib 三个函数都提供了注册函数列表到 table 的功能。luaL_register 是通过调用 luaI_openlib 函数来实现，提供了无闭包函数的功能。luaI_openlib 与 luaL_openlib 是同一个函数都会将函数注册到 table 中，nup 指定”上值“数量。luaI_openlib 思路是操作栈，将需要注册的函数保存到栈底的 table 中，函数执行完毕后栈底保留原先 table。 四 参考链接 Storing State in C Function The Registry References Upvalues","categories":[{"name":"Lua","slug":"Lua","permalink":"https://juzipeek.github.io/categories/Lua/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"Lua","slug":"Lua","permalink":"https://juzipeek.github.io/tags/Lua/"}]},{"title":"lua c api - userdata","slug":"lua-2019-07-28-lua-c-api-userdata","date":"2022-09-03T14:47:43.664Z","updated":"2022-09-03T14:51:13.270Z","comments":true,"path":"2022/09/03/lua-2019-07-28-lua-c-api-userdata/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/lua-2019-07-28-lua-c-api-userdata/","excerpt":"","text":"一 概述在 Lua 中使用 userdata 表示 C 中的复杂数据类型（其实是一块内存区域），对于 uerdata 没有预定义的操作。light userdata 表示指针类型数据，并不需要创建（它是指针值），同时，**light userdata 不被 gc 管理**。ligth userdata 的主要用途是用户自己管理内存，避免 gc 管理内存。 二 使用 userdata 实现数组在 lua 中使用 table 作为数组，在数组变大时会耗费非常多的内存，使用 userdata 能够降低内存使用。userdata 可以有 metatable，对 userdata 类型进行识别（判断 C 类型是否正确）增加元方法。 1. 示例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &quot;lua.h&quot;#include &quot;lauxlib.h&quot;#include &quot;lualib.h&quot;typedef struct NumArray &#123; int size; double values[1]; /* variable part */&#125; NumArray;/******************************************************************************* 创建 array******************************************************************************/static int newarray(lua_State *L) &#123; int n = luaL_checkint(L, 1); size_t nbytes = sizeof(NumArray) + (n - 1)*sizeof(double); NumArray *a = (NumArray *)lua_newuserdata(L, nbytes); luaL_getmetatable(L, &quot;LuaBook.array&quot;); lua_setmetatable(L, -2); a-&gt;size = n; return 1; /* new userdatum is already on the stack */&#125;static NumArray *checkarray(lua_State *L) &#123; void *ud = luaL_checkudata(L, 1, &quot;LuaBook.array&quot;); luaL_argcheck(L, ud != NULL, 1, &quot;`array&#x27; expected&quot;); return (NumArray *)ud;&#125;/******************************************************************************* 更新 array 中内容* @param userdata array* @param index* @para value******************************************************************************/static int setarray(lua_State *L) &#123; //NumArray *a = (NumArray *)lua_touserdata(L, 1); NumArray *a = checkarray(L); luaL_argcheck(L, a != NULL, 1, &quot;`array&#x27; expected&quot;); int index = luaL_checkint(L, 2); luaL_argcheck(L, 1 &lt;= index &amp;&amp; index &lt;= a-&gt;size, 2, &quot;index out of range&quot;); double value = luaL_checknumber(L, 3); a-&gt;values[index-1] = value; return 0;&#125;/******************************************************************************* 获得 array 中内容* @param userdata array* @param index******************************************************************************/static int getarray(lua_State *L) &#123; //NumArray *a = (NumArray *)lua_touserdata(L, 1); NumArray *a = checkarray(L); luaL_argcheck(L, a != NULL, 1, &quot;`array&#x27; expected&quot;); int index = luaL_checkint(L, 2); luaL_argcheck(L, 1 &lt;= index &amp;&amp; index &lt;= a-&gt;size, 2, &quot;index out of range&quot;); lua_pushnumber(L, a-&gt;values[index-1]); return 1;&#125;/******************************************************************************* 获得 array 大小* @param userdata array******************************************************************************/static int getsize(lua_State *L) &#123; // NumArray *a = (NumArray *)lua_touserdata(L, 1); NumArray *a = checkarray(L); luaL_argcheck(L, a != NULL, 1, &quot;`array&#x27; expected&quot;); lua_pushnumber(L, a-&gt;size); return 1;&#125;static const struct luaL_reg array_lib[] = &#123; &#123;&quot;new&quot;, newarray&#125;, &#123;&quot;set&quot;, setarray&#125;, &#123;&quot;get&quot;, getarray&#125;, &#123;&quot;size&quot;, getsize&#125;, &#123;NULL, NULL&#125;&#125;;/******************************************************************************* 注册函数******************************************************************************/int luaopen_userdata(lua_State *l) &#123; // 创建 metatable，使用 array.new 创建的数组元表是同一个元表 luaL_newmetatable(l, &quot;LuaBook.array&quot;); luaL_openlib(l, &quot;array&quot;, array_lib, 0); return 1;&#125; 2. 调用示例1234$ /usr/local/lua5.1.5/bin/lua -e &quot;require &#x27;userdata&#x27;; arr = array.new(20); print(type(arr)); array.set(arr,1,20);print(&#x27;arr[1]=&#x27;,array.get(arr,1));print(&#x27;size:&#x27;,array.size(arr))&quot;userdataarr[1]= 20size: 20 三 添加元方法在创建元表时可以在元表中添加元方法，方便使用 Lua 的 __index、__newindex 方法。修改 luaopen_userdata 方法实现： 1234567891011121314151617181920int luaopen_userdata(lua_State *l) &#123; // 创建 metatable，使用 array.new 创建的数组元表是同一个元表 luaL_newmetatable(l, &quot;LuaBook.array&quot;); luaL_openlib(l, &quot;array&quot;, array_lib, 0); /* now the stack has the metatable at index 1 and `array&#x27; at index 2 */ lua_pushstring(l, &quot;__index&quot;); lua_pushstring(l, &quot;get&quot;); lua_gettable(l, -3); /* get array.get on stack top*/ lua_settable(l, -4); /* metatable.__index = array.get */ lua_pushstring(l, &quot;__newindex&quot;); lua_pushstring(l, &quot;set&quot;); lua_gettable(l, -3); /* get array.set */ lua_settable(l, -4); /* metatable.__newindex = array.set */ return 0;&#125; 在这里的栈操作要仔细 调用示例123$ /usr/local/lua5.1.5/bin/lua -e &quot;require &#x27;userdata&#x27;; arr = array.new(20); print(type(arr)); arr[1]=20;print(&#x27;arr[1]=&#x27;,arr[1])&quot;userdataarr[1]= 20 四 函数说明1. lua_newuserdata1void *lua_newuserdata (lua_State *L, size_t size); 创建一块 size 大小的内存区域，将其压入栈顶并返回内存地址指针。 2. luaL_checkudata1void *luaL_checkudata (lua_State *L, int narg, const char *tname); 检查函数的第 narg 参数是否是 tname 类型的 userdata。luaL_checkudata 首先将 narg 转换为 userdata ，然后获得元表；同时，从注册表中根据 tname 获得元表，两者相互比较如果不同触发错误并返回 NULL，如果相同则返回 narg 指向的 userdata。 可以看 luaL_checkudata 代码实现，非常简单。 3. luaL_newmetatable1int luaL_newmetatable (lua_State *L, const char *tname); 创建一个新的可以作为 userdata 类型元表的 table，并使用 tname 作为 key 存储在注册表中。如果注册表中已经存在 tname 类型的值，返回值为 0。 4. luaL_getmetatable1void luaL_getmetatable (lua_State *L, const char *tname); 将注册表中与名称 tname 关联的元表压入栈中。 5. lua_setmetatable1int lua_setmetatable (lua_State *L, int index); 从栈顶弹出一个 table 并将其设置为栈中 index 索引出的值的元表。 五 参考资料 programming in lua lua 5.1 manual","categories":[{"name":"Lua","slug":"Lua","permalink":"https://juzipeek.github.io/categories/Lua/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"Lua","slug":"Lua","permalink":"https://juzipeek.github.io/tags/Lua/"}]},{"title":"lua c api - array and table operation","slug":"lua-2019-07-13-lua-c-api-array-and-table-operation","date":"2022-09-03T14:47:43.663Z","updated":"2022-09-03T14:50:47.980Z","comments":true,"path":"2022/09/03/lua-2019-07-13-lua-c-api-array-and-table-operation/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/lua-2019-07-13-lua-c-api-array-and-table-operation/","excerpt":"","text":"一 概述在 C 中使用 API 通过栈操作表或数组类型的数据，本篇使用示例来演示如果通过栈来操作表。 二 渠道秘钥更新set_channel_key 函数接收一个 table 作为参数，从 table 中获取 channel_name 的值作为 key，之后从动态库的全局渠道秘钥表中获取相应渠道的秘钥，并在 table 中添加或更新 channel_key 条目。 1. 示例代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// gcc -fPIC -I/usr/local/lua5.1.5/include -g -c private_cfg.c -Wall// gcc -shared -I/usr/local/lua5.1.5/include -L/usr/local/lua5.1.5/lib -llua -o private_cfg.so private_cfg.o#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &quot;lua.h&quot;#include &quot;lauxlib.h&quot;#include &quot;lualib.h&quot;typedef struct channel_key_s &#123; char *channel; char *key;&#125; channel_key;static channel_key g_channel_keys[] = &#123; &#123;&quot;mobile&quot;, &quot;mobile key&quot;&#125;, &#123;&quot;pc&quot;, &quot;pc key&quot;&#125;, &#123;NULL, NULL&#125;,&#125;;/******************************************************************************* * 从全局渠道秘钥表获取秘钥 ******************************************************************************/static char *get_key(char *channel_name) &#123; char *key = NULL; channel_key *p = g_channel_keys; for (;p-&gt;channel;p++) &#123; if (!strcmp(p-&gt;channel, channel_name)) &#123; key = p-&gt;key; break; &#125; &#125; return key;&#125;/******************************************************************************* * do_set_channel_key * 函数接收一个 table 作为参数，从 table 中获取 channel_name 的值作为 key， * 之后从全局渠道秘钥表中获取相应渠道的秘钥，并在 table 中添加 channel_key 条目。 ******************************************************************************/static intdo_set_channel_key(lua_State *L) &#123; // 参数必须是 table if (!lua_istable(L, -1)) &#123; return luaL_error(L, &quot;type error, should use table as param!&quot;); &#125; // 将 table 的 key `channel` 压入栈顶 lua_pushstring(L, &quot;channel_name&quot;); // 从 table 中获取 channel 字段，并其放到栈顶 // 注意：此时栈顶是 channel 值，栈顶第二个元素是 table。 // 原先栈顶的 &quot;channel&quot; 字符串已经被使用并移出栈。 lua_gettable(L, -2); if (!lua_isstring(L, -1)) &#123; return luaL_error(L, &quot;channel type error, should use string as param!&quot;); &#125; // 取出 channel 名 char *channel_name = (char *)lua_tostring(L, -1); // 将栈顶的 channel 值出栈，此时栈顶元素是 table lua_pop(L, 1); char *key = get_key(channel_name); // 在表中添加记录 lua_pushstring(L, &quot;channel_key&quot;); lua_pushstring(L, key); lua_settable(L, -3); return 0;&#125;static const struct luaL_reg private_cfg[] = &#123; &#123;&quot;set_channel_key&quot;, do_set_channel_key&#125;, &#123;NULL, NULL&#125;&#125;;/******************************************************************************* 注册函数******************************************************************************/int luaopen_private_cfg(lua_State *l) &#123; luaL_openlib(l, &quot;private_cfg&quot;, private_cfg, 0); return 1;&#125; 2. 执行1234requrie &quot;private_cfg&quot;tb = &#123;channel_name = &#x27;mobile&#x27;, channel_key = &#x27;no&#x27;&#125;private_cfg.set_channel_key(tb)print(tb[&#x27;channel_key&#x27;]) --&gt; mobile key 三 函数说明1. 访问表123void lua_gettable(lua_State *L, int index);void lua_rawget(lua_State *L, int index);void lua_rawgeti(lua_State *L, int index, int n); lua_gettable 将 t[k] 的值压入栈顶，表是由 index 索引确定的栈上元素，k 使用栈顶元素。函数会将栈顶的 k 元素 pop 出栈。 lua_rawget 与 lua_gettable 函数功能相似，只是 lua_rawget 不会使用表的元方法（metamethods）。 lua_rawgeti 将 t[n] 值压入栈，t 由 index 索引指定，n 为字面值，不会使用元方法。 2. 更新表123void lua_settable(lua_State *L, int index);void lua_rawset(lua_State *L, int index);void lua_rawseti(lua_State *L, int index, int n); lua_settable 与 lua 中的 t[k] = v 语义相同，表 t 是由 index 索引确定的栈上元素，v 是当前栈顶元素，k 是当前次栈顶元素。此函数会将栈顶、次栈顶元素 pop 出栈。 lua_rawset 与 lua_settable 函数功能相似，只是 lua_rawset 不会使用表的元方法（metamethods）。 lua_rawseti 与 lua 中的 t[n] = v 语义相同，表 t 是由 index 索引确定的栈上元素，v 是当前栈顶元素，n 为字面值，该函数不会使用元方法。 3. 错误输出1int luaL_error (lua_State *L, const char *fmt, ...); 触发错误，并输出 fmt 格式的错误信息，如果能获取文件名或行号会添加这些信息。 四 参考 programming in lua lua 5.1 c api 手册","categories":[{"name":"Lua","slug":"Lua","permalink":"https://juzipeek.github.io/categories/Lua/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"Lua","slug":"Lua","permalink":"https://juzipeek.github.io/tags/Lua/"}]},{"title":"lua c api - calling lua function","slug":"lua-2019-07-21-lua-c-api-calling-lua-function","date":"2022-09-03T14:47:43.663Z","updated":"2022-09-03T14:51:04.409Z","comments":true,"path":"2022/09/03/lua-2019-07-21-lua-c-api-calling-lua-function/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/lua-2019-07-21-lua-c-api-calling-lua-function/","excerpt":"","text":"一 概述很多情况下有这种需求：在特定的框架中针对不同的业务做少量修改。使用 C/C++ 开发稳定的框架，调用针对不同业务开发的 Lua 函数可以实现需求。其实从 C/C++ 调用 Lua 函数非常简单，调用时将 Lua 函数压入栈、将函数参数压入栈，调用 lua_pcall 完成调用；调用后从栈获得调用函数返回结果。 二 示例1. 程序示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &quot;lua.h&quot;#include &quot;lauxlib.h&quot;#include &quot;lualib.h&quot;/****************************************************************************** * 函数结构体定义 ******************************************************************************/typedef struct function_buf_s &#123; char *name; // 函数名 int nargs; // 参数数量 int nret; // 返回值数量 char *chunk; // 函数体&#125; function_buf;// 此处 function 不应该使用 function f() ... end 方式编写，写出的函数其实不会被执行static function_buf lua_function[] = &#123; &#123;&quot;sayhi&quot;, 1, 1, &quot;local name = ...\\n&quot; &quot;return string.format(&#x27;hi %s!&#x27;, name)\\n&quot; &#125;, &#123;&quot;echo&quot;, 1, 1, &quot;function echo(msg)\\n&quot; &quot; return msg\\n&quot; &quot;end\\n&quot; &quot;local msg = ...\\n&quot; &quot;return echo(msg)\\n&quot; &#125;, &#123;NULL, 0, 0,NULL&#125;&#125;;static int sayHi(lua_State *L) &#123; function_buf *function = &amp;lua_function[0]; int ret = luaL_loadbuffer(L, function-&gt;chunk, strlen(function-&gt;chunk), function-&gt;name); if (ret) &#123; return luaL_error(L, &quot;call loadbuffer fail ret:%d, code:%s&quot;, ret, function-&gt;chunk); &#125; lua_pushstring(L, &quot;lua&quot;); ret = lua_pcall(L, 1, 1, 0); if (ret != 0) &#123; return luaL_error(L, &quot;lua_pcall fail ret:%d %s&quot;, ret, lua_tostring(L, -1)); &#125; // 输出类型 printf(&quot;typename %s\\n&quot;, luaL_typename(L, -1)); if (!lua_isstring(L, -1)) &#123; return luaL_error(L, &quot;lua_pcall ret not string&quot;); &#125; // 函数执行结果在栈中，取出来再放入栈 const char *msg = lua_tostring(L, -1); lua_pop(L, -1); lua_pushfstring(L, &quot;sayhi say:%s&quot;, msg); return 1;&#125;/****************************************************************************** * 通用入口函数 * 调用时首先将函数名压入栈，之后是其他参数 ******************************************************************************/static intcommon_entry(lua_State *L) &#123; if (!lua_isstring(L, 1)) &#123; return luaL_error(L, &quot;first arg should be function name, string type&quot;); &#125; const char * function_name = lua_tostring(L, 1); function_buf *function = lua_function; for (;function-&gt;name; function++) &#123; if (!strcmp(function-&gt;name, function_name)) break; &#125; if (!function-&gt;name) &#123; return luaL_error(L, &quot;not found:%s function in array&quot;, function_name); &#125; int ret = luaL_loadbuffer(L, function-&gt;chunk, strlen(function-&gt;chunk), function-&gt;name); if (ret) &#123; return luaL_error(L, &quot;call loadbuffer fail ret:%d, code:%s&quot;, ret, function-&gt;chunk); &#125; int i; for(i=2; i &lt;= function-&gt;nargs+1; i++) &#123; lua_pushstring(L, lua_tostring(L, i)); &#125; ret = lua_pcall(L, function-&gt;nargs, function-&gt;nret, 0); if (ret != 0) &#123; return luaL_error(L, &quot;lua_pcall fail ret:%d %s&quot;, ret, lua_tostring(L, -1)); &#125; int nret = function-&gt;nret; for (i=-1; i &gt;= -nret; i--)&#123; printf(&quot;ret:%d is:%s\\n&quot;, -i, lua_tostring(L, i)); &#125; return nret;&#125;static const struct luaL_reg call_function_lib[] = &#123; &#123;&quot;sayHi&quot;, sayHi&#125;, &#123;&quot;common_entry&quot;, common_entry&#125;, &#123;NULL, NULL&#125;&#125;;/******************************************************************************* 注册函数******************************************************************************/int luaopen_call_function(lua_State *l) &#123; luaL_openlib(l, &quot;call_function&quot;, call_function_lib, 0); return 1;&#125; 程序中有两个示例，sayHi 函数接收一个 string 参数并返回一个 string 参数；common_entry 函数可以根据函数名选择相应的函数体进行执行，更加灵活。 在函数定义中需要注意，luaL_loadbuffer 系列函数会将字符串当做程序段载入并放在栈顶，但是并未执行函数。如果载入的代码段是 function f()…end 格式，使用 lua_pcall 调用代码段时函数 f 仅做了定义，未执行函数体。 2. 调用示例1234567$ /usr/local/lua5.1.5/bin/lua -e &quot;require &#x27;call_function&#x27;; ret = call_function.sayHi(&#x27;lua&#x27;); print(ret)&quot;typename stringsayhi say:hi lua!$ /usr/local/lua5.1.5/bin/lua -e &quot;require &#x27;call_function&#x27;; ret = call_function.common_entry(&#x27;echo&#x27;,&#x27;lua is cool&#x27;); print(ret)&quot;ret:1 is:lua is coollua is cool 三 函数说明1. luaL_error1int luaL_error (lua_State *L, const char *fmt, ...); 触发错误，并使用 fmt 与后续参数格式化输出错误消息字符串。luaL_error 函数并不会退出，通常的是否用法为： 1return luaL_error(args); 四 参考资料-programming in lua -lua 5.1 手册","categories":[{"name":"Lua","slug":"Lua","permalink":"https://juzipeek.github.io/categories/Lua/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"Lua","slug":"Lua","permalink":"https://juzipeek.github.io/tags/Lua/"}]},{"title":"lua c api - stack","slug":"lua-2019-07-13-lua-c-api-stack","date":"2022-09-03T14:47:43.662Z","updated":"2022-09-03T14:50:56.278Z","comments":true,"path":"2022/09/03/lua-2019-07-13-lua-c-api-stack/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/lua-2019-07-13-lua-c-api-stack/","excerpt":"","text":"一 概述《lua c api》系列文章描述的是 C 语言作为宿主语言，与 Lua 程序通讯的 API 接口。 二 stackLua 使用虚拟的栈与宿主 C 语言进行通讯，在栈中的每个元素都是 Lua 识别的数据类型。每当 Lua 调用 C 时，被调用的 C 函数都会得到一个新的栈，该栈独立于以前的栈和仍处于活跃状态的 C 函数栈。在此堆栈包含 lua 调用 C 函数的所有参数，C 函数应该将需要返回的结果压入此堆栈中（是否需要清空栈）。 为了方便，在 C 中操作栈时并未严格遵守栈操作语义，可以使用“索引”来查询栈中的元素。正数索引从栈底开始计数，栈底索引为 1；负数索引从栈顶开始计数，栈顶索引为 -1。示例结构： 123456---------------------------------------| 正数索引 | 数据 | 负数索引 | 栈中位置 |---------------------------------------| 3 | nil | -1 | 栈顶 || 2 | 2 | -2 | 中间 || 1 | &quot;hi&quot; | -3 | 栈底 | 注意，使用 0 作为索引会出错。 三 示例使用 lua5.1.5 版本 1. 程序在示例中 echo 函数会返回所有调用参数，在返回时栈底元素作为第一个返回值，栈顶元素作为最后一个返回值；sayhi 会清空栈顶并返回一个 “hi” 字符串。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// gcc -fPIC -I/usr/local/lua5.1.5/include -g -c stack.c// gcc -shared -I/usr/local/lua5.1.5/include -L/usr/local/lua5.1.5/lib -llua -o stack.so stack.o#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &quot;lua.h&quot;#include &quot;lauxlib.h&quot;#include &quot;lualib.h&quot;/****************************************************************************** * sayhi 函数 * 清空栈，并将 hi 字符串压入栈顶 ******************************************************************************/static int sayhi(lua_State *L) &#123; lua_settop(L, 0); lua_pushstring(L, &quot;hi&quot;); return 1;&#125;/****************************************************************************** * echo 函数会返回所有输入参数 ******************************************************************************/static intecho(lua_State *L) &#123; int num = lua_gettop(L); return num;&#125;static const struct luaL_reg stack_lib[] = &#123; &#123;&quot;sayhi&quot;, sayhi&#125;, &#123;&quot;echo&quot;, echo&#125;, &#123;NULL, NULL&#125;&#125;;/****************************************************************************** * 注册函数 * 注意 luaopen_xxx 中 xxx 为 lua 中 require 库名称 ******************************************************************************/int luaopen_stack(lua_State *l) &#123; luaL_openlib(l, &quot;stack&quot;, stack_lib, 0); return 1;&#125; 编译命令在代码开始处 2. 调用在解释器中可以调用测试： 12345678Lua 5.1.5 Copyright (C) 1994-2012 Lua.org, PUC-Rio&gt; require &quot;stack&quot;&gt; r1,r2 = stack.echo(&quot;a&quot;,&quot;b&quot;)&gt; print(r1,r2)a b&gt; r = stack.sayhi()&gt; print(r)hi 四 函数说明1. 栈顶索引操作1void lua_settop (lua_State *L, int index); 函数功能：将 L 的栈顶设置到 index 指定的索引处。如果 index 比现有的栈顶高，会扩充栈，扩充的栈中值为 nil。如果 index 比现有的栈顶低，那么 index 到历史栈顶之间的元素会被删除。如果 index 为 0，那么栈中所有元素都将被删掉。 2. 字符串压入栈1void lua_pushstring (lua_State *L, const char *s); 将 s 指向的字符串压入 L 的栈顶。字符串会以 “\\0” 结束。需要注意：**lua_pushstring 会做值拷贝，不需要担心调用栈退出后内存回收导致 coredump 问题**。 3. 获得栈顶索引1int lua_gettop (lua_State *L); 获得栈顶元素的索引。因为栈底索引是 1 所以栈顶元素索引等价于调用栈中所有元素数量。如果返回值为 0 说明栈为空。 五 参考 lua 5.1 手册","categories":[{"name":"Lua","slug":"Lua","permalink":"https://juzipeek.github.io/categories/Lua/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"Lua","slug":"Lua","permalink":"https://juzipeek.github.io/tags/Lua/"}]},{"title":"epoll","slug":"linux-2018-12-22-epoll","date":"2022-09-03T14:47:35.236Z","updated":"2022-09-03T14:56:56.724Z","comments":true,"path":"2022/09/03/linux-2018-12-22-epoll/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/linux-2018-12-22-epoll/","excerpt":"","text":"概述epoll 系列描述符用来监控多个文件描述符是否可用。epoll 系列相关函数包括：epoll_create、epoll_ctl、epoll_wait，其中： epoll_create 创建一个 epoll 实例，并返回一个引用该实例的文件描述符。 epoll_ctl 通过 epoll_ctl 将感兴趣的文件描述符注册到 epoll 实例。 epoll_wait 等待 IO 事件发生，如果当前无事件则阻塞当前线程。 123int epoll_create(int size)；// 创建一个 epoll 句柄，size 参数已被忽略int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout); epoll_create创建一个 epoll 的句柄，2.6.8 以后版本 size 被忽略。返回的 epoll 示例实际是一个文件描述符，在使用完毕时需要关闭。 epoll_ctl1int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)； 对 epoll 实例进行操作。op 参数可选值： EPOLL_CTL_ADD：添加参数 fd 的监听事件 EPOLL_CTL_DEL：删除参数 fd 的监听事件 EPOLL_CTL_MOD：修改参数 fd 的监听事件 struct epoll_event 结构如下： 1234567891011typedef union epoll_data &#123; void *ptr; int fd; uint32_t u32; uint64_t u64;&#125; epoll_data_t;struct epoll_event &#123; uint32_t events; /* Epoll events */ epoll_data_t data; /* User data variable */&#125;; 结构体中 events 成员描述关注的事件类型掩码，取值范围如下： EPOLLIN 表示对应的文件描述符可以读 EPOLLOUT 表示对应的文件描述符可以写 EPOLLPRI 表示对应的文件描述符有紧急的数据可读，一般是带外数据 EPOLLERR 表示对应的文件描述符发生错误 EPOLLET 将文件描述符设置为边沿触发模式 EPOLLEXCLUSIVE Linux 4.5 内核添加，在操作系统内核级别解决了“惊群”问题 epoll_wait1int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); 等待 epfd 关联的 poll 实例上发生事件。参数 events 用来从内核接收发生的事件，maxevents 设置最多返回的事件数目，timeout 为超时时间。与 epoll_wait 相似的函数 epoll_pwait 可以忽略信号产生，仅当事件发生或超时函数才返回。 边沿触发与水平触发epoll 对于 fd 支持边沿触发（ET，edge trigger）和水平触发（LT，level trigger）两种模式。man 手册（man 7 epoll）有两者区别的讲解。假设有如下场景： 在一个线程 A 将管道描述符写关闭，将管道描述符（rfd）在 epoll 实例上注册，并调用 epoll_wait 等待事件发生。 另一个线程 B 将管道描述符的读关闭，在管道上写入 2kB 的数据。 在线程 A 中，rfd 作为已准备好事件被 epoll_wait 返回。 线程 A 读取 rfd 中的 1kB 数据。 对 epoll_wait 的调用已完成。 如果在第一步中添加 rfd 到 epoll 实例时设置触发方式为 EPOLLET 模式，在 5 步完成 epoll_wait 的调用后即使 rdf 中有可读数据，rfd 的事件也不会触发，此时请求被 hang（线程 B 在等待线程 A 的应答数据，线程 A 在继续等待请求数据）。这是因为 EPOLLET 模式仅当变化发生在文件描述符上时才会触发事件。因此在第 5 步中，线程 A 一直在等待已经存在与 rfd 缓冲区中的数据。在上面的示例中，第 2 步因为写数据导致 rfd 的可读事件触发，同时此事件在第 3 步被消费。由于第 4 步读操作并未将所有可读数据读取，因此在第 5 步完成对 epoll_wait 的调用后，有可能导致此缓冲区中的数据一直未被读取。 使用 EPOLLET 模式的应用程序应该使用非阻塞文件描述符，以避免在处理多个文件描述符是阻塞读或写数据。将 epoll 用作 EPOLLET 模式的建议如下： 使用非阻塞文件描述符 在进行 read 或 write 操作时等待 EAGAIN 错误发生才认为事件处理结束 使用示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 #define MAX_EVENTS 10struct epoll_event ev, events[MAX_EVENTS];int listen_sock, conn_sock, nfds, epollfd;/* Code to set up listening socket, &#x27;listen_sock&#x27;, (socket(), bind(), listen()) omitted */// listen_sock 已设置为非阻塞套接字epollfd = epoll_create1(0);if (epollfd == -1) &#123; perror(&quot;epoll_create1&quot;); exit(EXIT_FAILURE);&#125;ev.events = EPOLLIN;ev.data.fd = listen_sock;if (epoll_ctl(epollfd, EPOLL_CTL_ADD, listen_sock, &amp;ev) == -1) &#123; perror(&quot;epoll_ctl: listen_sock&quot;); exit(EXIT_FAILURE);&#125;for (;;) &#123; nfds = epoll_wait(epollfd, events, MAX_EVENTS, -1); if (nfds == -1) &#123; perror(&quot;epoll_wait&quot;); exit(EXIT_FAILURE); &#125; for (n = 0; n &lt; nfds; ++n) &#123; if (events[n].data.fd == listen_sock) &#123; conn_sock = accept(listen_sock, (struct sockaddr *) &amp;addr, &amp;addrlen); if (conn_sock == -1) &#123; perror(&quot;accept&quot;); exit(EXIT_FAILURE); &#125; setnonblocking(conn_sock); ev.events = EPOLLIN | EPOLLET; // 边沿触发模式 ev.data.fd = conn_sock; if (epoll_ctl(epollfd, EPOLL_CTL_ADD, conn_sock, &amp;ev) == -1) &#123; perror(&quot;epoll_ctl: conn_sock&quot;); exit(EXIT_FAILURE); &#125; &#125; else &#123; // 函数 do_use_fd（）使用新的就绪文件描述符，直到 read 或 write 返回 EAGAIN。 // 事件驱动的状态机应用程序应在收到 EAGAIN 后记录其当前状态，以便在下次调用 do_use_fd（）时，它将继续从之前停止的位置 read 或 write。 do_use_fd(events[n].data.fd); &#125; &#125;&#125; 出于性能原因，使用边缘触发接口时可以通过指定（EPOLLIN | EPOLLOUT）在 epoll 接口 EPOLL_CTL_ADD 中添加文件描述符一次。 这允许您使用 EPOLL_CTL_MOD 调用 epoll_ctl，避免在 EPOLLIN 和 EPOLLOUT 之间连续切换。 manpage QA本节摘选自 man 7 epoll QA 部分： What happens if you register the same file descriptor on an epoll instance twice? You will probably get EEXIST. However, it is possible to add a duplicate (dup(2), dup2(2), fcntl(2) F_DUPFD) file descriptor to the same epoll instance. This can be a useful technique for filtering events, if the duplicate file descriptors are registered with different events masks. Can two epoll instances wait for the same file descriptor? If so, are events reported to both epoll file descriptors? Yes, and events would be reported to both. However, careful programming may be needed to do this correctly. Is the epoll file descriptor itself poll/epoll/selectable? Yes. If an epoll file descriptor has events waiting, then it will indicate as being readable. What happens if one attempts to put an epoll file descriptor into its own file descriptor set? The epoll_ctl(2) call will fail (EINVAL). However, you can add an epoll file descriptor inside another epoll file descriptor set. Can I send an epoll file descriptor over a UNIX domain socket to another process? Yes, but it does not make sense to do this, since the receiving process would not have copies of the file descriptors in the epoll set. Will closing a file descriptor cause it to be removed from all epoll sets automatically? Yes, but be aware of the following point. A file descriptor is a reference to an open file description (see open(2)). Whenever a file descriptor is duplicated via dup(2), dup2(2), fcntl(2) F_DUPFD, or fork(2), a new file descriptor referring to the same open file description is created. An open file description continues to exist until all file descriptors referring to it have been closed. A file descriptor is removed from an epoll set only after all the file descriptors referring to the underlying open file description have been closed (or before if the file descriptor is explicitly removed using epoll_ctl(2) EPOLL_CTL_DEL). This means that even after a file descriptor that is part of an epoll set has been closed, events may be reported for that file descriptor if other file descriptors referring to the same underlying file description remain open. If more than one event occurs between epoll_wait(2) calls, are they combined or reported separately? They will be combined. Does an operation on a file descriptor affect the already collected but not yet reported events? You can do two operations on an existing file descriptor. Remove would be meaningless for this case. Modify will reread available I/O. Do I need to continuously read/write a file descriptor until EAGAIN when using the EPOLLET flag (edge-triggered behavior) ? Receiving an event from epoll_wait(2) should suggest to you that such file descriptor is ready for the requested I/O operation. You must consider it ready until the next (nonblocking) read/write yields EAGAIN. When and how you will use the file descriptor is entirely up to you. For packet/token-oriented files (e.g., datagram socket, terminal in canonical mode), the only way to detect the end of the read/write I/O space is to continue to read/write until EAGAIN. For stream-oriented files (e.g., pipe, FIFO, stream socket), the condition that the read/write I/O space is exhausted can also be detected by checking the amount of data read from / written to the target file descriptor. For example, if you call read(2) by asking to read a certain amount of data and read(2) returns a lower number of bytes, you can be sure of having exhausted the read I/O space for the file descriptor. The same is true when writing using write(2). (Avoid this latter technique if you cannot guarantee that the monitored file descriptor always refers to a stream-oriented file.)","categories":[{"name":"Linux","slug":"Linux","permalink":"https://juzipeek.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://juzipeek.github.io/tags/Linux/"}]},{"title":"","slug":"linux-2019-03-08-kernel","date":"2022-09-03T14:47:35.236Z","updated":"2022-09-03T14:47:35.236Z","comments":true,"path":"2022/09/03/linux-2019-03-08-kernel/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/linux-2019-03-08-kernel/","excerpt":"","text":"kernel 编译12345678910111213# 安装依赖sudo apt-get install libncurses5-dev libssl-devsudo apt-get install build-essential opensslsudo apt-get install zlibc minizipsudo apt-get install libidn11-dev libidn11# 下载内核 # 解压# 添加 openssl 库目录vi MakefileHOSTCFLAG = .... -L/usr/local/lib","categories":[],"tags":[]},{"title":"静态定义探针 - USDT","slug":"linux-2020-12-20-USDT","date":"2022-09-03T14:47:35.236Z","updated":"2022-09-03T15:19:01.817Z","comments":true,"path":"2022/09/03/linux-2020-12-20-USDT/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/linux-2020-12-20-USDT/","excerpt":"","text":"一 概述用户静态定义探针简称 USDT(User Statically Defined Tracing), 支持用户在代码中添加探针, 实现对程序的观测. 二 USDT 探针实现概述在用户代码中使用 DTRACE_PROBE 系列宏添加探针(需要引入 sys/sdt.h 头文件, 由 systemtap-sdt-devel 提供), 代码编译后源码中添加的 DTRACE_PROBE 会编译为 nop 指令, 并在 ELF 文件中添加 .note.stapstd 段. 此时代码在执行过程中与无探针代码不同, 仅增加了一条 nop 指令(每个探针增加一个 nop 指令). 当用户需要对应用程序进行观测, 注册 USDT 探针时, USDT 工具会读取 ELF 中 nop 指令修改为调试中断(int 3). 此时, 当程序执行到 DTRACE_PROBE 代码处时会触发中断, 内核会执行与此探针关联的 eBPF 程序. 在用户对应用程序观测结束时, ELF 被修改的 nop 指令会被恢复. 三 测试验证1. 安装依赖测试环境是 CentOS-7, 安装依赖 USDT 软件包: 1yum install -y systemtap systemtap-runtime systemtap-devel systemtap-sdt-devel 使用 bcc 对应用程序注册探针并进行观测, 安装 bcc 工具包: 1yum install -y kernel-devel kernel-debug-devel bpftrace bpftrace-tools bpftrace-docs bcc-static bcc-tools 2. 代码示例应用程序代码: 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/sdt.h&gt;void foo(int a, int b) &#123; // 添加探针 DTRACE_PROBE2(demo, foo, a, b); printf(&quot;a:%d b:%d\\n&quot;, a, b);&#125;int main() &#123; int a = 10; int b = 20; int i = 0; for (i = 0; i&lt;10000; i++) &#123; foo(a, b); sleep(5); &#125;&#125; 使用 bcc 对应用程序进行观测, 代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041bpf_text = &quot;&quot;&quot;...BPF_PERF_OUTPUT(events);typedef struct msg_s &#123; int a; int b;&#125; msg_t;int do_trace(struct pt_regs *ctx) &#123; msg_t msg = &#123;&#125;; bpf_usdt_readarg(1, ctx, &amp;msg.a); bpf_usdt_readarg(2, ctx, &amp;msg.b); events.perf_submit(ctx, &amp;msg, sizeof(msg)); return 0;&#125;;&quot;&quot;&quot;u = USDT(path=&quot;./demo&quot;)u.enable_probe(probe=&quot;foo&quot;, fn_name=&quot;do_trace&quot;)b = BPF(text=bpf_text, usdt_contexts=[u])class Msg(ctypes.Structure): _fields_ = [(&quot;a&quot;, ctypes.c_int), (&quot;b&quot;, ctypes.c_int)]def print_event(cpu, data, size): event = ctypes.cast(data, ctypes.POINTER(Msg)).contents print(&quot;print event a:%d b:%d&quot; % (event.a, event.b))b[&quot;events&quot;].open_perf_buffer(print_event)while True: try: b.perf_buffer_poll() except KeyboardInterrupt: break 3. 测试操作123456789# 启动应用程序./demo &gt;/dev/null &amp;# 执行观测程序python trace.py# 使用 gdb 查看代码gdb attach -p [pid]disass foo 应用程序在被观测时汇编代码: 1234567891011121314151617(gdb) disassemble fooDump of assembler code for function foo: 0x000000000040057d &lt;+0&gt;: push %rbp 0x000000000040057e &lt;+1&gt;: mov %rsp,%rbp 0x0000000000400581 &lt;+4&gt;: sub $0x10,%rsp 0x0000000000400585 &lt;+8&gt;: mov %edi,-0x4(%rbp) 0x0000000000400588 &lt;+11&gt;: mov %esi,-0x8(%rbp) 0x000000000040058b &lt;+14&gt;: int3 // &lt;--- here 0x000000000040058c &lt;+15&gt;: mov -0x8(%rbp),%edx 0x000000000040058f &lt;+18&gt;: mov -0x4(%rbp),%eax 0x0000000000400592 &lt;+21&gt;: mov %eax,%esi 0x0000000000400594 &lt;+23&gt;: mov $0x400690,%edi 0x0000000000400599 &lt;+28&gt;: mov $0x0,%eax 0x000000000040059e &lt;+33&gt;: callq 0x400450 &lt;printf@plt&gt; 0x00000000004005a3 &lt;+38&gt;: leaveq 0x00000000004005a4 &lt;+39&gt;: retqEnd of assembler dump. 注意地址 0x000000000040058b 处指令变为 int3. 关闭观测程序, 再次进行反汇编查看: 1234567891011121314151617(gdb) disassemble fooDump of assembler code for function foo: 0x000000000040057d &lt;+0&gt;: push %rbp 0x000000000040057e &lt;+1&gt;: mov %rsp,%rbp 0x0000000000400581 &lt;+4&gt;: sub $0x10,%rsp 0x0000000000400585 &lt;+8&gt;: mov %edi,-0x4(%rbp) 0x0000000000400588 &lt;+11&gt;: mov %esi,-0x8(%rbp) 0x000000000040058b &lt;+14&gt;: nop // &lt;--- here 0x000000000040058c &lt;+15&gt;: mov -0x8(%rbp),%edx 0x000000000040058f &lt;+18&gt;: mov -0x4(%rbp),%eax 0x0000000000400592 &lt;+21&gt;: mov %eax,%esi 0x0000000000400594 &lt;+23&gt;: mov $0x400690,%edi 0x0000000000400599 &lt;+28&gt;: mov $0x0,%eax 0x000000000040059e &lt;+33&gt;: callq 0x400450 &lt;printf@plt&gt; 0x00000000004005a3 &lt;+38&gt;: leaveq 0x00000000004005a4 &lt;+39&gt;: retqEnd of assembler dump. 此时地址 0x000000000040058b 处指令变为 nop. 在生产代码中应该使用 dtrace 生产辅助代码, 而非直接使用 DTRACE 宏, 参考代码链接. 四 参考链接 USDT for reliable Userspace event tracing Exploring USDT Probes on Linux UserSpaceProbeImplementation Adding User Space Probing to an Application (heapsort example) usdt-sample perf-tools bcc 项目","categories":[{"name":"Linux","slug":"Linux","permalink":"https://juzipeek.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://juzipeek.github.io/tags/Linux/"},{"name":"USDT","slug":"USDT","permalink":"https://juzipeek.github.io/tags/USDT/"},{"name":"Dtrace","slug":"Dtrace","permalink":"https://juzipeek.github.io/tags/Dtrace/"},{"name":"eBPF","slug":"eBPF","permalink":"https://juzipeek.github.io/tags/eBPF/"}]},{"title":"coredumpctl","slug":"linux-2018-12-21-coredumpctl","date":"2022-09-03T14:47:35.235Z","updated":"2022-09-03T14:56:49.421Z","comments":true,"path":"2022/09/03/linux-2018-12-21-coredumpctl/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/linux-2018-12-21-coredumpctl/","excerpt":"","text":"概述coredumpctl 用来从 systemd-journald 中检索 coredump，非 systemd 进程的 coredump 不能使用。 使用12345678# 列出日志系统收集的 coredumpcoredumpctl list# infocoredumpctl info [PID]# 获得 coredump 文件coredumpctl dump -o pid.coredump [PID] systemd使用 systemd 管理服务时需要进行特殊配置才能产生 coredump 文件（现在我还找到可行配置）。对于被管理的 NGINX 服务需要进行 stop 然后使用 /srv/nginx/sbin/nginx 进行启动，才能保证生成 coredump 文件。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://juzipeek.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://juzipeek.github.io/tags/Linux/"}]},{"title":"Getting Started with goa","slug":"go-2018-12-10-Getting-Started-with-goa","date":"2022-09-03T14:47:35.234Z","updated":"2022-09-03T14:54:42.263Z","comments":true,"path":"2022/09/03/go-2018-12-10-Getting-Started-with-goa/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/go-2018-12-10-Getting-Started-with-goa/","excerpt":"","text":"概述对 goa 框架示例 Getting Started wit goa 的翻译，看中文版本更方便。创建一个名叫 cellar （地窖）的服务：使用 GET 请求获取瓶子（bottle）模版是否存在。 依赖安装 goa 和 goagen 12go get -u github.com/goadesign/goa/... 设计第一步，使用 goa 的 DSL 语言来描述 API 服务接口。在 $GOPATH/src 下创建一个项目目录，可以使用目录：$GOPATH/src/cellar。在 cellar 目录下创建一个子目录，用来保存接口设计文件，目录结构可以是 $GOPATH/src/cellar/design/design.go。 design.go 内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445package design // 当前目录为 design 所以包名也该是 designimport ( . &quot;github.com/goadesign/goa/design&quot; // 使用 . 导入保证 DSL 功能启用；以下并没有使用这两个包 . &quot;github.com/goadesign/goa/design/apidsl&quot;)var _ = API(&quot;cellar&quot;, func() &#123; // API 函数定义了微服务的端点以及其他全局属性。在设计中必须只存在一个 API 定义。 Title(&quot;The virtual wine cellar&quot;) Description(&quot;A simple goa service&quot;) Scheme(&quot;http&quot;) Host(&quot;localhost:8080&quot;)&#125;)var _ = Resource(&quot;bottle&quot;, func() &#123; // 使用 Resource 函数定义一个名为 bottle 的资源。 BasePath(&quot;/bottles&quot;) DefaultMedia(BottleMedia) Action(&quot;show&quot;, func() &#123; // 使用 Action 函数定义一个资源行为，资源行为定义在 Resource 内部。 Description(&quot;Get bottle by id&quot;) Routing(GET(&quot;/:bottleID&quot;)) Params(func() &#123; Param(&quot;bottleID&quot;, Integer, &quot;Bottle ID&quot;) &#125;) Response(OK) Response(NotFound) &#125;)&#125;)// BottleMedia defines the media type used to render bottles.var BottleMedia = MediaType(&quot;application/vnd.goa.example.bottle+json&quot;, func() &#123; Description(&quot;A bottle of wine&quot;) Attributes(func() &#123; // Attributes define the media type shape. Attribute(&quot;id&quot;, Integer, &quot;Unique bottle ID&quot;) Attribute(&quot;href&quot;, String, &quot;API href for making requests on the bottle&quot;) Attribute(&quot;name&quot;, String, &quot;Name of wine&quot;) Required(&quot;id&quot;, &quot;href&quot;, &quot;name&quot;) &#125;) View(&quot;default&quot;, func() &#123; // View defines a rendering of the media type. Attribute(&quot;id&quot;) // Media types may have multiple views and must Attribute(&quot;href&quot;) // have a &quot;default&quot; view. Attribute(&quot;name&quot;) &#125;)&#125;) API：API 函数定义了微服务的端点以及其他全局属性。在设计中必须只存在一个 API 定义。 Resource：使用 Resource 函数定义一个名为 bottle 的资源。 Action：使用 Action 函数定义行为端点、参数、包体和应答。goa 框架已经为标准 HTTP 状态码定义了默认的应答模版，应答模版描述了应答的 HTTP 状态码、内容类型和 HTTP 头。使用 ResponseTemplate 可以自定义应答模版。 MediaType：使用 MediaType 函数定义资源类型。在之前的 Resource 中引用到全局变量 BottleMedia。 实现使用 goagen 工具根据 design.go 的设计来生成微服务代码。使用以下命令，将微服务代码生成在目录 $GOPATH/src/cellar 中： 1goagen bootstrap -d cellar/design 生成的微服务目录结构应该如下： 1234567891011121314151617181920212223appapp/contexts.goapp/controllers.goapp/hrefs.goapp/media_types.goapp/user_types.goapp/testapp/test/bottle.gomain.gobottle.gotool/cellar-clitool/cliclientclienttool/cellar-cli/main.gotool/cli/commands.goclient/client.goclient/bottle.goclient/datatypes.goswaggerswagger/swagger.jsonswagger/swagger.yaml goagen 创建的 main.go 作为应用， bottle.go 作为逻辑控制。可以从这两个文件进行新的开发，当重新运行 goagen 进行代码生成时这两个文件不会被覆盖，只有 app、client、tool 和 swagger 目录中的文件会重新生成。 目录功能说明： app：用于将 HTTP 请求路由到应用代码。 client：客户端实现。 tool：当前服务器（cellar）的命令行接口。 swagger：JSON 和 YAML 格式定义的接口。 app 目录中文件介绍： controllers.go：controller 接口定义。设计中定义的每个 Resource 都有一个这样的接口，文件内还包含将这些控制器接口的实现“安装”到服务上的代码。 contexts.go：包含 context 数据结构定义。Context 的作用类似 Martini 框架中的 martini.Context，goji 框架中的 web.C 或者 echo 框架的 echo.Context。使用一个不太准确的比喻，它们作为所有控制器操作的第一个参数给出，并提供帮助方法来访问请求状态并写入响应。 hrefs.go：提供构建资源连接的全局函数。资源连接可以使响应链接到相关资源。goa知道如何通过查看资源“规范”操作的请求路径来构建这些 href。 media_types.go：包含用于构建响应的媒体类型数据结构。 user_types.go：包含通过 Type 设计语言函数定义的数据结构。这些类型可用于定义请求有包体和响应包体。 test/bottle.go：包含测试助手，通过控制器输入调用动作实现并验证生成的媒体类型，可以方便地测试控制器代码。 现在 goagen 已经完成了设计工作，需要我们自己实现 bottle 控制器。生成的控制器如下： 12345type BottleController interface &#123; goa.Muxer Show(*ShowBottleContext) error&#125; 看下 app/contexts.go 中的 ShowBottleContext: 12345678// ShowBottleContext provides the bottle show action context.type ShowBottleContext struct &#123; context.Context *goa.ResponseData *goa.RequestData BottleID int&#125; ShowBottleContext 上下文数据结构包含声明为 int 类型的 BottleID，这是在之前的 DSL 中定义的。它还包含匿名字段，用于访问原始底层请求和响应状态（包括访问 http.Request 和 http.ResponseWriter 对象）。goa 上下文数据结构还实现了 golang context.Context 接口，该接口使得可以例如在涉及处理请求的不同 goroutine 中携带截止时间和取消信号。 app/contexts.go 文件还定义了上下文数据结构的两个方法： 123456789101112// OK sends a HTTP response with status code 200.func (ctx *ShowBottleContext) OK(r *GoaExampleBottle) error &#123; ctx.ResponseData.Header().Set(&quot;Content-Type&quot;, &quot;application/vnd.goa.example.bottle&quot;) return ctx.Service.Send(ctx.Context, 200, r)&#125;// NotFound sends a HTTP response with status code 404.func (ctx *ShowBottleContext) NotFound() error &#123; ctx.ResponseData.WriteHeader(404) return nil&#125; goagen 还在 bottle.go 中生成了一个空的控制器实现，所以我们剩下要做的就是提供一个实际的实现。打开文件 bottle.go 并用现有的 Show 方法替换： 123456789101112131415161718// Show implements the &quot;show&quot; action of the &quot;bottles&quot; controller.func (c *BottleController) Show(ctx *app.ShowBottleContext) error &#123; if ctx.BottleID == 0 &#123; // Emulate a missing record with ID 0 return ctx.NotFound() &#125; // Build the resource using the generated data structure bottle := app.GoaExampleBottle&#123; ID: ctx.BottleID, Name: fmt.Sprintf(&quot;Bottle #%d&quot;, ctx.BottleID), Href: app.BottleHref(ctx.BottleID), &#125; // Let the generated code produce the HTTP response using the // media type described in the design (BottleMedia). return ctx.OK(&amp;bottle)&#125; 在我们构建和运行应用程序之前，让我们先来看看 main.go：该文件包含 main 的默认实现，它实例化一个新的 goa 服务，初始化默认中间件，安装 bottle 控制器并运行 HTTP 服务器。 1234567891011121314151617181920func main() &#123; // Create service service := goa.New(&quot;cellar&quot;) // Mount middleware service.Use(middleware.RequestID()) service.Use(middleware.LogRequest(true)) service.Use(middleware.ErrorHandler(service, true)) service.Use(middleware.Recover()) // Mount &quot;bottle&quot; controller c := NewBottleController(service) app.MountBottleController(service, c) // Start service if err := service.ListenAndServe(&quot;:8080&quot;); err != nil &#123; service.LogError(&quot;startup&quot;, &quot;err&quot;, err) &#125;&#125; 将控制器安装到服务上会将所有控制器操作端点注册到路由器。该代码还确保不同操作的路由之间不存在冲突。 现在编译并运行服务： 123go build -o cellar./cellar 应该会有如下输出： 1232016/04/10 16:20:37 [INFO] mount ctrl=Bottle action=Show route=GET /bottles/:bottleID2016/04/10 16:20:37 [INFO] listen transport=http addr=:8080 使用 curl 进行测试： 123456789curl -i localhost:8080/bottles/1HTTP/1.1 200 OKContent-Type: application/vnd.goa.example.bottleDate: Sun, 10 Apr 2016 23:21:19 GMTContent-Length: 48&#123;&quot;href&quot;:&quot;/bottles/1&quot;,&quot;id&quot;:1,&quot;name&quot;:&quot;Bottle #1&quot;&#125; 您可以通过传递无效（非整数）id 来执行由 goagen 生成的验证代码： 123456789curl -i localhost:8080/bottles/nHTTP/1.1 400 Bad RequestContent-Type: application/vnd.api.error+jsonDate: Sun, 10 Apr 2016 23:22:46 GMTContent-Length: 117&#123;&quot;code&quot;:&quot;invalid_request&quot;,&quot;status&quot;:400,&quot;detail&quot;:&quot;invalid value \\&quot;n\\&quot; for parameter \\&quot;bottleID\\&quot;, must be a integer&quot;&#125; 我们不使用 curl，而是使用生成的 CLI 工具向服务发出请求。首先让我们编译 CLI 客户端： 1234cd tool/cellar-cligo build -o cellar-cli./cellar-cli 下面的命令打印 cli 用法， -help 标志还提供上下文帮助： 12./cellar-cli show bottle --help 下面的命令显示了如何调用 show bottle 动作： 12345./cellar-cli show bottle /bottles/12016/04/10 16:26:34 [INFO] started id=Vglid/lF GET=http://localhost:8080/bottles/12016/04/10 16:26:34 [INFO] completed id=Vglid/lF status=200 time=773.145µs&#123;&quot;href&quot;:&quot;/bottles/1&quot;,&quot;id&quot;:1,&quot;name&quot;:&quot;Bottle #1&quot;&#125; 项目示例结束。","categories":[{"name":"Go","slug":"Go","permalink":"https://juzipeek.github.io/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://juzipeek.github.io/tags/Go/"}]},{"title":"Gokit 简介","slug":"go-2019-02-02-Gokit简介","date":"2022-09-03T14:47:35.234Z","updated":"2022-09-03T14:56:20.757Z","comments":true,"path":"2022/09/03/go-2019-02-02-Gokit简介/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/go-2019-02-02-Gokit%E7%AE%80%E4%BB%8B/","excerpt":"","text":"一 Gokit 是什么Gokit 是用来构建微服务的一系列库，如果想在项目中引入微服务模式可以使用 Gokit，同时 Gokit 已经是生产标准。Gokit 与 Micro 相同的地方是都是微服务工具包，不过 Micro 同时是一个微服务生态系统。Micro 的目标是构建一个平台，而 Gokit 的目标是用来整合客户的平台。 二 Gokit 架构与设计1. 核心概念Gokit 服务分为三层： 传输层端点层服务层请求在第一层（传输层）进入服务，向下流到第三层，响应采用相反的过程。 2. 传输层传输域绑定到 HTTP 或 gRPC 等具体传输。同一个微服务同时支持多种传输是非常有用的，你可以在一个微服务中支持旧的 HTTP API 和新的 gRPC 服务。 3. 端点层端点就像 controller 上的动作或处理程序，如果实现了两种传输层（HTTP 和 gRPC），你可以使用两种方法将请求发送到同一个端点。 4. 服务层服务是所有业务逻辑的实现，一个服务通常将多个端点粘合在一起。在 Gokit 中服务通常使用接口建立模型，接口的实现包含业务逻辑。使用 Gokit 构建的服务应该努力遵守 CleanArchitecture 架构或 Hexagonal 架构。也就是说业务逻辑不该了解端点或传输域相关概念：服务不应该知道有关 HTTP 头或 gRPC 错误代码的任何信息。 5. 中间件Gokit 试图使用中间件模式或装饰器模式来强制分离关注点，中间件可以包装端点或服务以添加功能，例如日志记录、速率限制、负责均衡或分布式跟踪。在端点或服务周边连接多个中间件是非常常见的。 6. GoKit 微服务是如何建模的将所有这些概念放在一起，可以发现 Gokit 微服务模型类似洋葱，有很多层。这些层可以分为三个域，最内层的服务域是一切基于特定服务的定义以及所有业务逻辑的实现；中间的端点域是将服务的每个方法抽象为通用端点的地方；最外层的传输域是端点绑定到 HTTP 或 gRPC 等具体传输的地方。通过为服务定义接口并提供具体实现来实现核心业务逻辑，然后编写服务中间件以提供其他功能，例如日志记录、分析、检测 - 任何需要了解业务领域的内容。Gokit 提供端点和传输域中间件，用于速率限制、断路、负载均衡和分布式追踪等功能 - 所有这些通常都与业务无关。简而言之，Gokit 试图通过合理使用中间件模式来强制分离关注点。 7. 依赖注入Gokit 鼓励用户将服务设计为多个交互组件，包括多个单用途中间件。经验告诉我们，在微服务中定义和连接组件图的最易理解、可维护和富有表现力的方法是在 main 方法中显示和声明性组合。 控制反转是其他框架的共同特征，通过依赖注入或服务定位模式实现。但是在 Gokit 中，应该在 main 函数中连接整个组件图。这中方式强化了两个优点：通过严格保持组件生命周期在 main 函数中，可以避免使用全局变量，这对测试非常重要；如果组件的作用域为 main，那么将他们作为依赖项提供给其他组件的唯一方法是将他们作为参数显示传递给其构造函数，这样可以明确依赖关系。 8. 更多细节Gokit 支持传输协议有哪些？ HTTP、gRPC、Thrift、net/rpc，使用其他协议也非常简单。","categories":[{"name":"Go","slug":"Go","permalink":"https://juzipeek.github.io/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://juzipeek.github.io/tags/Go/"}]},{"title":"Gokit example - stringsvc","slug":"go-2019-02-03-Gokit-example-stringsvc","date":"2022-09-03T14:47:35.234Z","updated":"2022-09-03T14:56:32.269Z","comments":true,"path":"2022/09/03/go-2019-02-03-Gokit-example-stringsvc/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/go-2019-02-03-Gokit-example-stringsvc/","excerpt":"","text":"一 极简 stringsvc 微服务使用单个 main.go 文件构建一个 stringsvc 微服务，提供以下两个功能： Uppercase 将字符串转换为大写 Count 计算字符串长度 1 服务接口定义首先将微服务功能抽象为接口： 1234type StringService interface &#123; Uppercase(string) (string, error) Count(string) int&#125; 接口实现（服务实现）： 12345678910111213141516171819import ( &quot;context&quot; &quot;errors&quot; &quot;strings&quot;)type stringService struct&#123;&#125;func (stringService) Uppercase(s string) (string, error) &#123; if s == &quot;&quot; &#123; return &quot;&quot;,ErrEmpty &#125; return strings.ToUpper(s), nil&#125;func (stringService) Count(s string) int &#123; return len(s)&#125;var ErrEmpty = errors.New(&quot;Empty string&quot;) 2 请求与应答在 Gokit 中主要的消息传递模式是 RPC，因此我们接口中的每个方法都将被建模为远程过程调用。对于每个方法，我们定义请求和响应结构，分别捕获所有输入和输出参数。 12345678910111213141516type uppercaseRequest struct &#123; S string `json:&quot;s&quot;`&#125;type uppercaseResponse struct &#123; V string `json:&quot;v&quot;` Err string `json:&quot;err,omitempty&quot;` // errors do not JSON-marshal, so we use a string&#125;type countRequest struct &#123; S string `json:&quot;s&quot;`&#125;type countResponse struct &#123; V int `json:&quot;v&quot;`&#125; 3 端点Gokit 的绝大多数功能是通过在抽象的端点层提供的。端点定义如下： 1type EndPoint func(ctx context.Context, request interface&#123;&#125;)(response interface&#123;&#125;, err error) 一个端点代表一个 RPC，也就是说我们的服务接口中有个一方法。我们编写简单的适配器，将每个服务的方法转换为端点。每个适配器都接受一个 StringService，并返回一个与其中一个方法对应的端点。 1234567891011121314151617181920212223import ( &quot;context&quot; &quot;github.com/go-kit/kit/endpoint&quot;)func makeUppercaseEndpoint(svc StringService) endpoint.Endpoint &#123; return func(_ context.Context, request interface&#123;&#125;) (interface &#123;&#125;, error) &#123; req := request.(uppercaseRequest) v, err := svc.Uppercase(req.S) if err != nil &#123; return uppercaseResponse&#123;v, err.Error()&#125;, nil &#125; return uppercaseResponse&#123;v, &quot;&quot;&#125;, nil &#125;&#125;func makeCountEndPoint(svc StringService) endpoint.Endpoint &#123; return func(_ context.Context, request interface&#123;&#125;) (interface&#123;&#125;, error) &#123; req := request.(countRequest) v := svc.Count(req.S) return countResponse&#123;v&#125;, nil &#125;&#125; 4 传输层设置现在需要将服务暴露，以便调用。以下代码使用 json over HTTP 方式暴露服务： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import ( &quot;context&quot; &quot;encoding/json&quot; &quot;log&quot; &quot;net/http&quot; httptransport &quot;github.com/go-kit/kit/transport/http&quot;)func main()&#123; svc := stringService&#123;&#125; uppercaseHandler := httptransport.NewServer( makeUppercaseEndpoint(svc), decodeUppercaseRequest, encodeResponse, ) countHandler := httptransport.NewServer( makeCountEndpoint(svc), decodeCountRequest, encodeResponse, ) http.Handle(&quot;/uppercase&quot;, uppercaseHandler) http.Handle(&quot;/count&quot;, countHandler) log.Fatal(http.ListenAndServe(&quot;:8080&quot;, nil))&#125;func decodeUppercaseRequest(_ context.Context, r *http.Request) (interface&#123;&#125;, error) &#123; var request uppercaseRequest if err := json.NewDecoder(r.Body).Decode(&amp;request); err !=nil &#123; return nil, err &#125; return request, nil&#125;func decodeCountRequest(_ context.Context, r *http.Request)(interface&#123;&#125;, error) &#123; var request countRequest if err := json.NewDecoder(r.Body).Decode(&amp;request); err != nil &#123; return nil, err &#125; return request, nil&#125;func encodeResponse(_ context.Context, w http.ResponseWriter, response interface&#123;&#125;) error &#123; return json.NewEncoder(w).Encode(response)&#125; 可以下载完整示例.执行命令运行服务： 12345go run stringsvc1.go# 测试curl -X POST -d&#x27;&#123;&quot;s&quot;:&quot;hello, world&quot;&#125;&#x27; localhost:8080/uppercasecurl -X POST -d&#x27;&#123;&quot;s&quot;:&quot;hello, world&quot;&#125;&#x27; localhost:8080/count 二 添加中间件1. 关注点分割将调用流程的每一层分割成单独的文件，可以在增加服务端点时更轻松的阅读 go-kit 项目。在上面的示例中我们将所有的层都放在同一个 main.go 文件中，在我们增加更多复杂代码之前将代码分割成以下文件，并将所有代码保留在 main.go 中。 将服务层相关的类型和功能放到 service.go 文件中： 123type StringServicetype stringServicevar ErrEmpty 将传输层相关的类型和功能放到 transport.go 文件中： 123456789func makeUppercaseEndpointfunc makeCountEndpointfunc decodeUppercaseRequestfunc decodeCountRequestfunc encodeResponsetype uppercaseRequesttype uppercaseResponsetype countRequesttype countResponse 2. 传输层日志任何需要进行日志记录的组件需要将 logger 当做一项依赖，与数据库连接相同。因此我们在 main 函数中创建 logger 并将其传递给其他组件，而不是使用全局 logger。 在 stringService 中，我们可以直接将 logger 传递给 stringService 对象，也可以使用中间件（或者叫做装饰器）模式。所谓的中间件就是入参是 Endpoint 返回值同样是 Endpoint： 1type Middleware func(Endpoint) Endpoint go-kit 已经定义 Middleware，不再需要自己定义。 以下是一个基础的日志中间件实现： 123456789func loggingMiddleware(logger log.Logger) Middleware &#123; return func(next endpoint.Endpoint) endpoint.Endpoint &#123; return func(_ context.Context, request interface&#123;&#125;) (interface&#123;&#125;, error) &#123; logger.Log(&quot;msg&quot;, &quot;calling endpoint&quot;) defer logger.Log(&quot;msg&quot;, &quot;called endpoint&quot;) return next(request) &#125; &#125;&#125; 将中间件添加到处理函数中： 1234567891011121314151617181920212223logger := log.NewLogfmtLogger(os.Stderr)svc := stringService&#123;&#125;var uppercase endpoint.Endpointuppercase = makeUppercaseEndpoint(svc)uppercase = loggingMiddleware(log.With(logger, &quot;method&quot;, &quot;uppercase&quot;))(uppercase)var count endpoint.Endpointcount = makeCountEndpoint(svc)count = loggingMiddleware(log.With(logger, &quot;method&quot;, &quot;count&quot;))(count)uppercaseHandler := httptransport.NewServer( // ... uppercase, // ...)countHandler := httptransport.NewServer( // ... count, // ...) 3. 服务层日志我们同样可以在服务层定义中间件，既然 StringService 定义为一个接口，我们只需要定义一个新类型对原有 StringService 进行包裹，并负责日志职责。代码如下： 123456789101112131415161718192021222324252627282930313233type loggingMiddleware struct &#123; logger log.Logger next StringService&#125;func (mw loggingMiddleware) Uppercase(s string) (output string, err error) &#123; defer func(begin time.Time) &#123; mw.logger.Log( &quot;method&quot;, &quot;uppercase&quot;, &quot;input&quot;, s, &quot;output&quot;, output, &quot;err&quot;, err, &quot;took&quot;, time.Since(begin), ) &#125;(time.Now()) output, err = mw.next.Uppercase(s) return&#125;func (mw loggingMiddleware) Count(s string) (n int) &#123; defer func(begin time.Time) &#123; mw.logger.Log( &quot;method&quot;, &quot;count&quot;, &quot;input&quot;, s, &quot;n&quot;, n, &quot;took&quot;, time.Since(begin), ) &#125;(time.Now()) n = mw.next.Count(s) return&#125; 并将其添加到 main 函数中： 12345678910111213141516171819202122232425262728import ( &quot;os&quot; &quot;github.com/go-kit/kit/log&quot; httptransport &quot;github.com/go-kit/kit/transport/http&quot;)func main() &#123; logger := log.NewLogfmtLogger(os.Stderr) var svc StringService svc = stringService&#123;&#125; svc = loggingMiddleware&#123;logger, svc&#125; // ... uppercaseHandler := httptransport.NewServer( // ... makeUppercaseEndpoint(svc), // ... ) countHandler := httptransport.NewServer( // ... makeCountEndpoint(svc), // ... )&#125; 在端点层使用中间件可以关注于传输域中的问题，例如断路或速率限制。在服务层使用中间件可以关注于业务域中的问题，例如日志记录、仪表盘。仪表盘中间件： 1234567891011121314151617181920212223242526272829type instrumentingMiddleware struct &#123; requestCount metrics.Counter requestLatency metrics.Histogram countResult metrics.Histogram next StringService&#125;func (mw instrumentingMiddleware) Uppercase(s string) (output string, err error) &#123; defer func(begin time.Time) &#123; lvs := []string&#123;&quot;method&quot;, &quot;uppercase&quot;, &quot;error&quot;, fmt.Sprint(err != nil)&#125; mw.requestCount.With(lvs...).Add(1) mw.requestLatency.With(lvs...).Observe(time.Since(begin).Seconds()) &#125;(time.Now()) output, err = mw.next.Uppercase(s) return&#125;func (mw instrumentingMiddleware) Count(s string) (n int) &#123; defer func(begin time.Time) &#123; lvs := []string&#123;&quot;method&quot;, &quot;count&quot;, &quot;error&quot;, &quot;false&quot;&#125; mw.requestCount.With(lvs...).Add(1) mw.requestLatency.With(lvs...).Observe(time.Since(begin).Seconds()) mw.countResult.Observe(float64(n)) &#125;(time.Now()) n = mw.next.Count(s) return&#125; 将其集成到服务中： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import ( stdprometheus &quot;github.com/prometheus/client_golang/prometheus&quot; kitprometheus &quot;github.com/go-kit/kit/metrics/prometheus&quot; &quot;github.com/go-kit/kit/metrics&quot;)func main() &#123; logger := log.NewLogfmtLogger(os.Stderr) fieldKeys := []string&#123;&quot;method&quot;, &quot;error&quot;&#125; requestCount := kitprometheus.NewCounterFrom(stdprometheus.CounterOpts&#123; Namespace: &quot;my_group&quot;, Subsystem: &quot;string_service&quot;, Name: &quot;request_count&quot;, Help: &quot;Number of requests received.&quot;, &#125;, fieldKeys) requestLatency := kitprometheus.NewSummaryFrom(stdprometheus.SummaryOpts&#123; Namespace: &quot;my_group&quot;, Subsystem: &quot;string_service&quot;, Name: &quot;request_latency_microseconds&quot;, Help: &quot;Total duration of requests in microseconds.&quot;, &#125;, fieldKeys) countResult := kitprometheus.NewSummaryFrom(stdprometheus.SummaryOpts&#123; Namespace: &quot;my_group&quot;, Subsystem: &quot;string_service&quot;, Name: &quot;count_result&quot;, Help: &quot;The result of each count method.&quot;, &#125;, []string&#123;&#125;) // no fields here var svc StringService svc = stringService&#123;&#125; svc = loggingMiddleware&#123;logger, svc&#125; svc = instrumentingMiddleware&#123;requestCount, requestLatency, countResult, svc&#125; uppercaseHandler := httptransport.NewServer( makeUppercaseEndpoint(svc), decodeUppercaseRequest, encodeResponse, ) countHandler := httptransport.NewServer( makeCountEndpoint(svc), decodeCountRequest, encodeResponse, ) http.Handle(&quot;/uppercase&quot;, uppercaseHandler) http.Handle(&quot;/count&quot;, countHandler) http.Handle(&quot;/metrics&quot;, promhttp.Handler()) logger.Log(&quot;msg&quot;, &quot;HTTP&quot;, &quot;addr&quot;, &quot;:8080&quot;) logger.Log(&quot;err&quot;, http.ListenAndServe(&quot;:8080&quot;, nil))&#125; 整个服务代码示例在此。 三 调用其他服务假设我们的字符串服务需要使用其他字符串服务来实现 Uppercase 方法，我们使用代理将请求转向另外一个服务，采用与日志中间件相同方式，我们将代理中间件实现为服务中间件。 12345678// proxmw 实现 StringService，同时将 Uppercase 请求转发到 uppercase 端点，并使用 StringService 类型的 next 成员处理其他请求 // proxymw implements StringService, forwarding Uppercase requests to the// provided endpoint, and serving all other (i.e. Count) requests via the// next StringService.type proxymw struct &#123; next StringService // Serve most requests via this service... uppercase endpoint.Endpoint // ...except Uppercase, which gets served by this endpoint&#125; 要调用客户端点只需要进行一些简单转换： 1234567891011func (mw proxymw) Uppercase(s string) (string, error) &#123; response, err := mw.uppercase(uppercaseRequest&#123;S: s&#125;) if err != nil &#123; return &quot;&quot;, err &#125; resp := response.(uppercaseResponse) if resp.Err != &quot;&quot; &#123; return resp.V, errors.New(resp.Err) &#125; return resp.V, nil&#125; 现在，为了构建这些代理中间件之一，我们将代理 URL 字符串转换为端点。如果我们通过 HTTP 传输 JSON，我们可以使用 transport / http 包中的帮助函数。 123456789101112131415161718import ( httptransport &quot;github.com/go-kit/kit/transport/http&quot;)func proxyingMiddleware(proxyURL string) ServiceMiddleware &#123; return func(next StringService) StringService &#123; return proxymw&#123;next, makeUppercaseProxy(proxyURL)&#125; &#125;&#125;func makeUppercaseProxy(proxyURL string) endpoint.Endpoint &#123; return httptransport.NewClient( &quot;GET&quot;, mustParseURL(proxyURL), encodeUppercaseRequest, decodeUppercaseResponse, ).Endpoint()&#125; TODO 将上面的添加到服务中，并测试。四 服务发现和负载均衡Gokit 为不同的服务发现系统提供适配器，以获取最新的实例集，作为单独的端点公开，这些适配器被称为 subscribers。 123type Subscriber interface &#123; Endpoints()([]endpoint.Endpoint, error)&#125; 在内部，subscriber 使用工厂函数将发现的每个实例字符串转换为可用的端点。 1type Factory func(instance string) (endpoint.Endpoint, error) 到目前为止工厂函数 makeUppercaseProxy 只是直接调用 URL，但是将一些安全中间件（断路器限流器）放入工厂函数也是否重要。 1234var e endpoint.Endpointe = makeUppercaseProxy(instance)e = circuitbreaker.Gobreaker(gobreaker.NewCircuitBreaker(gobreaker.Settings&#123;&#125;))(e)e = kitratelimit.NewTokenBucketLimiter(jujuratelimit.NewBucketWithRate(float64(maxQPS), int64(maxQPS)))(e) 现在我们已经有了一组端点，可以使用负载均衡器选择其中一个端点。Gokit 提供了一系列负载均衡器组件，当然也可以编写自己的负载均衡器。负载均衡器定义： 123type Balancer interface &#123; Endpoint() (endpoint.Endpoint, error)&#125; 可以使用重试策略包装负载均衡器，返回一个可用端点，使用重试策略将重试失败的请求，直到达到最大尝试次数或超时。 1func Retry(max int, timeout time.Duration, lb Balancer) endpoint.Endpoint 最终实现： 1234567891011121314151617181920212223242526272829303132333435363738394041func proxyingMiddleware(instances string, logger log.Logger) ServiceMiddleware &#123; // If instances is empty, don&#x27;t proxy. if instances == &quot;&quot; &#123; logger.Log(&quot;proxy_to&quot;, &quot;none&quot;) return func(next StringService) StringService &#123; return next &#125; &#125; // Set some parameters for our client. var ( qps = 100 // beyond which we will return an error maxAttempts = 3 // per request, before giving up maxTime = 250 * time.Millisecond // wallclock time, before giving up ) // Otherwise, construct an endpoint for each instance in the list, and add // it to a fixed set of endpoints. In a real service, rather than doing this // by hand, you&#x27;d probably use package sd&#x27;s support for your service // discovery system. var ( instanceList = split(instances) subscriber sd.FixedSubscriber ) logger.Log(&quot;proxy_to&quot;, fmt.Sprint(instanceList)) for _, instance := range instanceList &#123; var e endpoint.Endpoint e = makeUppercaseProxy(instance) e = circuitbreaker.Gobreaker(gobreaker.NewCircuitBreaker(gobreaker.Settings&#123;&#125;))(e) e = kitratelimit.NewTokenBucketLimiter(jujuratelimit.NewBucketWithRate(float64(qps), int64(qps)))(e) subscriber = append(subscriber, e) &#125; // Now, build a single, retrying, load-balancing endpoint out of all of // those individual endpoints. balancer := lb.NewRoundRobin(subscriber) retry := lb.Retry(maxAttempts, maxTime, balancer) // And finally, return the ServiceMiddleware, implemented by proxymw. return func(next StringService) StringService &#123; return proxymw&#123;next, retry&#125; &#125;&#125; 完整示例 可以使用 Gokit 为服务创建客户端软件包，以便从其他 Go 程序消费服务。实际上，您的客户端软件包将提供服务接口的实现，该接口使用特定传输调用远程服务实例。 示例代码1 示例代码2","categories":[{"name":"Go","slug":"Go","permalink":"https://juzipeek.github.io/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://juzipeek.github.io/tags/Go/"}]},{"title":"Context 包简介","slug":"go-2018-10-23-context","date":"2022-09-03T14:47:35.233Z","updated":"2022-09-03T14:54:17.311Z","comments":true,"path":"2022/09/03/go-2018-10-23-context/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/go-2018-10-23-context/","excerpt":"","text":"Context 包使用 context 可以关闭所有依赖于此的协程，适用于复杂情景。 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package mainimport ( &quot;context&quot; &quot;fmt&quot; &quot;time&quot;)func main() &#123; ctx, cancel := context.WithCancel(context.Background()) valueCtx1 := context.WithValue(ctx, &quot;key&quot;, &quot;【监控1】&quot;) valueCtx2 := context.WithValue(ctx, &quot;key&quot;, &quot;【监控2】&quot;) valueCtx3 := context.WithValue(ctx, &quot;key&quot;, &quot;【监控3】&quot;) go watch(valueCtx1, &quot;【监控1】&quot;) go watch(valueCtx2, &quot;【监控2】&quot;) go watch(valueCtx3, &quot;【监控3】&quot;) time.Sleep(10 * time.Second) fmt.Println(&quot;可以了，通知监控停止&quot;) cancel() //为了检测监控过是否停止，如果没有监控输出，就表示停止了 time.Sleep(5 * time.Second)&#125;func watch(ctx context.Context, name string) &#123; go watch2(ctx, name+&quot;1&quot;) for &#123; select &#123; case &lt;-ctx.Done(): fmt.Println(name, ctx.Value(&quot;key&quot;), &quot;监控退出，停止了...&quot;) return default: fmt.Println(name, ctx.Value(&quot;key&quot;), &quot;goroutine监控中...&quot;) time.Sleep(2 * time.Second) &#125; &#125;&#125;func watch2(ctx context.Context, name string) &#123; for &#123; select &#123; case &lt;-ctx.Done(): fmt.Println(name, &quot;监控退出，停止了...&quot;) return default: fmt.Println(name, &quot;goroutine监控中...&quot;) time.Sleep(2 * time.Second) &#125; &#125;&#125;","categories":[{"name":"Go","slug":"Go","permalink":"https://juzipeek.github.io/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://juzipeek.github.io/tags/Go/"}]},{"title":"httprouter 介绍","slug":"go-2019-01-13-httprouter-介绍","date":"2022-09-03T14:47:35.233Z","updated":"2022-09-03T14:55:58.670Z","comments":true,"path":"2022/09/03/go-2019-01-13-httprouter-介绍/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/go-2019-01-13-httprouter-%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"前言Gin 使用 httprouter 用作请求路由。本文看下其实现以及与 NGINX 的 location 查找做对比。 httprouter 使用以下是 httprouter 的简单使用示例 1234567891011121314151617181920212223242526272829303132333435package mainimport ( &quot;net/http&quot; &quot;os&quot; &quot;github.com/gogap/logrus&quot; &quot;github.com/julienschmidt/httprouter&quot;)func init() &#123; logrus.SetOutput(os.Stdout) logrus.SetLevel(logrus.DebugLevel) logrus.SetFormatter(&amp;logrus.TextFormatter&#123;&#125;)&#125;func main() &#123; r := httprouter.New() r.GET(&quot;/hi/:name/:act&quot;, comHandler) r.GET(&quot;/catch-all/*all&quot;, comHandler) http.ListenAndServe(&quot;:8080&quot;, r)&#125;func comHandler(resp http.ResponseWriter, req *http.Request, params httprouter.Params) &#123; logrus.Debugf(&quot;request client ip:%s uri:%s&quot;, req.RemoteAddr, req.RequestURI) for k, v := range req.Header &#123; logrus.Debugf(&quot;header [%s]=[%s]&quot;, k, v) &#125; for _, p := range params &#123; logrus.Debugf(&quot;params [%s]=[%s]&quot;, p.Key, p.Value) &#125; resp.Write([]byte(&quot;hello...&quot;))&#125; 测试命令： 12345curl -i &quot;http://localhost:8080/hi/zhoucj/sayhi&quot;curl -i &quot;http://localhost:8080/catch-all/zhoucj/sayhi&quot;# 日志输出如下：# DEBU[0006] params [all]=[/zhoucj/sayhi] 在 httprouter.router 源文件中有注释： 12345678910111213141516171819202122232425262728293031323334353637383940414243// The router matches incoming requests by the request method and the path.// If a handle is registered for this path and method, the router delegates the// request to that function.// For the methods GET, POST, PUT, PATCH and DELETE shortcut functions exist to// register handles, for all other methods router.Handle can be used.//// The registered path, against which the router matches incoming requests, can// contain two types of parameters:// Syntax Type// :name named parameter// *name catch-all parameter//// Named parameters are dynamic path segments. They match anything until the// next &#x27;/&#x27; or the path end:// Path: /blog/:category/:post//// Requests:// /blog/go/request-routers match: category=&quot;go&quot;, post=&quot;request-routers&quot;// /blog/go/request-routers/ no match, but the router would redirect// /blog/go/ no match// /blog/go/request-routers/comments no match//// Catch-all parameters match anything until the path end, including the// directory index (the &#x27;/&#x27; before the catch-all). Since they match anything// until the end, catch-all parameters must always be the final path element.// Path: /files/*filepath//// Requests:// /files/ match: filepath=&quot;/&quot;// /files/LICENSE match: filepath=&quot;/LICENSE&quot;// /files/templates/article.html match: filepath=&quot;/templates/article.html&quot;// /files no match, but the router would redirect//// The value of parameters is saved as a slice of the Param struct, consisting// each of a key and a value. The slice is passed to the Handle func as a third// parameter.// There are two ways to retrieve the value of a parameter:// // by the name of the parameter// user := ps.ByName(&quot;user&quot;) // defined by :user or *user//// // by the index of the parameter. This way you can also get the name (key)// thirdKey := ps[2].Key // the name of the 3rd parameter// thirdValue := ps[2].Value // the value of the 3rd parameter 对于参数（动态）路由，httprouter 支持两种类型：命名参数路由、所有路由。 命名参数 将路径上的参数依次作为命名参数。/hi/:name/:act 会匹配 /hi/joy/sayhi，并且参数“name”、“act”依次为“joy”、“sayhi”。 catch-all 路由 从路径索引开始匹配到路径截止。/catch-all/*all 会匹配以 /catch-all 开始的路径，/catch-all 之后的所有参数会被作为 all 参数处理。 实现阅读 httprouter 源码，可以发现： Router 中每种 HTTP 方法单独一棵树 Router.trees 存储路径对应的处理函数 NGINX 静态 location 查找在 NGINX 内部静态 location 以二叉树存储，查找时需要进行二叉树查找。","categories":[{"name":"Go","slug":"Go","permalink":"https://juzipeek.github.io/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://juzipeek.github.io/tags/Go/"}]},{"title":"gcache","slug":"go-2019-06-26-gcache","date":"2022-09-03T14:47:35.233Z","updated":"2022-09-03T14:50:10.410Z","comments":true,"path":"2022/09/03/go-2019-06-26-gcache/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/go-2019-06-26-gcache/","excerpt":"","text":"概述GCache 是带有自动载入、过期机制的缓存库。所谓自动载入是指，GCache 可以自定义载入 Handler，当缓存中不存在 key 时调用 Handler 载入 key。 示例1. 安装1go get github.com/bluele/gcache 2. 基础使用示例1234567891011121314151617181920// 将输出:// Get: okpackage mainimport ( &quot;github.com/bluele/gcache&quot; &quot;fmt&quot;)func main() &#123; gc := gcache.New(20). LRU(). Build() gc.Set(&quot;key&quot;, &quot;ok&quot;) value, err := gc.Get(&quot;key&quot;) if err != nil &#123; panic(err) &#125; fmt.Println(&quot;Get:&quot;, value)&#125; 3. 过期 key 使用12345678910111213141516171819202122232425262728// Get: ok// 10 seconds later, new attempt:// panic: ErrKeyNotFoundpackage mainimport ( &quot;github.com/bluele/gcache&quot; &quot;fmt&quot; &quot;time&quot;)func main() &#123; gc := gcache.New(20). LRU(). Build() gc.SetWithExpire(&quot;key&quot;, &quot;ok&quot;, time.Second*10) value, _ := gc.Get(&quot;key&quot;) fmt.Println(&quot;Get:&quot;, value) // Wait for value to expire time.Sleep(time.Second*10) value, err = gc.Get(&quot;key&quot;) if err != nil &#123; panic(err) &#125; fmt.Println(&quot;Get:&quot;, value)&#125; 4. 自动载入示例123456789101112131415161718192021// Get: okpackage mainimport ( &quot;github.com/bluele/gcache&quot; &quot;fmt&quot;)func main() &#123; gc := gcache.New(20). LRU(). LoaderFunc(func(key interface&#123;&#125;) (interface&#123;&#125;, error) &#123; return &quot;ok&quot;, nil &#125;). Build() value, err := gc.Get(&quot;key&quot;) if err != nil &#123; panic(err) &#125; fmt.Println(&quot;Get:&quot;, value)&#125; 参考 项目地址","categories":[{"name":"Go","slug":"Go","permalink":"https://juzipeek.github.io/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://juzipeek.github.io/tags/Go/"},{"name":"gcache","slug":"gcache","permalink":"https://juzipeek.github.io/tags/gcache/"},{"name":"cache","slug":"cache","permalink":"https://juzipeek.github.io/tags/cache/"}]},{"title":"truss 使用","slug":"go-2019-02-01-truss-使用","date":"2022-09-03T14:47:35.232Z","updated":"2022-09-03T14:56:10.713Z","comments":true,"path":"2022/09/03/go-2019-02-01-truss-使用/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/go-2019-02-01-truss-%E4%BD%BF%E7%94%A8/","excerpt":"","text":"一 安装1234go get -v -u -d github.com/metaverse/trusscd $GOPATH/src/github.com/metaverse/trussmake dependenciesmake 二 proto 内容说明在 .proto 文件中定义通讯接口。truss 将基于 package 指定的包名称定义服务的名称，为保证代码可读性 package 指定名称应该与 service 指定名称相同。如下： 123// echo.protopackage echo;service Echo&#123;...&#125; 一个 API 服务是通过 rpc 调用以及 rpc 调用的参数消息和响应消息构成。请求和响应消息中的字段是枚举类型（protobuf 序列化要求）。 1234message LouderRequest &#123; string In = 1; // In is the string to echo back int32 Loudness = 2; // Loudness is the number of exclamations marks to add to the echoed string&#125; 在使用 rpc 描述 API 接口时可以添加 HTTP 注解使接口支持 HTTP 调用（需要导入谷歌注解包）。 123456789101112import &quot;github.com/metaverse/truss/deftree/googlethirdparty/annotations.proto&quot;;service Echo &#123;... rpc Echo (EchoRequest) returns (EchoResponse) &#123; option (google.api.http) = &#123; // All message fields are query parameters of the http request unless otherwise specified get: &quot;/echo&quot; &#125;; &#125;...&#125; 除了想上面使用 GET 方法，还可以使用 POST 方法，从 HTTP Body 中获取参数（如果 API 接口中包含 map 类型变量，必须使用 POST 方法，将参数放在 Body 中）： 123456rpc Louder (LouderRequest) returns (EchoResponse) &#123; option (google.api.http) = &#123; post: &quot;/louder/&#123;Loudness&#125;&quot; // Loudness is accepted in the http path body: &quot;*&quot; // All other fields (In) are located in the body of the http/json request &#125;;&#125; 一个服务（service）可以被分割到多个 proto 文件中定义，但最好在一个文件中。 三 生成目录结构说明使用 truss *.proto 会在 *.proto 同一目录下生成服务代码目录（echo-service）。服务目录（echo-service 目录）内部结构如下： 123456789101112131415.├── echo-service| ├── cmd| │ ├── echo| │ │ └── main.go| │ └── echo-server| │ └── main.go| ├── echo.pb.go| ├── handlers| │ ├── handlers.go| │ ├── hooks.go| │ └── middlewares.go| └── svc| └── ...└── echo.proto 目录功能说明： srv ：包含服务通讯所需的编解码代码（已生成）handlers/handlers.go ：在其中添加业务逻辑代码，调用桩代码handlers/middlewares.go : 对端点或服务添加中间件，例如：访问日志、检测cmd/echo/ ：包含客户端代码，测试有用cmd/echo-server/ ：服务入口，在其中构建服务echo.pb.go ：包含已从 echo.proto 转换为 golang 的 RPC 接口定义和支持结构 重新运行 truss 会将除 handlers 目录外的所有文件覆盖。 四 添加业务逻辑在 handlers/handlers.go 中添加业务逻辑： 1234567func (s echoService) Echo(ctx context.Context, in *pb.EchoRequest) (*pb.EchoResponse, error) &#123; var resp pb.EchoResponse resp = pb.EchoResponse&#123; Out: in.In, // 将请求参数回传 &#125; return &amp;resp, nil&#125; 可以新建包添加业务逻辑代码，只在 handlers.go 中进行耦合。 五 构建代码1go build echo-service/echo 六 truss 命令行参数1. 指定代码输出目录使用 --svcout 可以指定代码数据路径，路径必须是 GOPATH 格式，因为在代码中会使用路径引用代码。示例： 1truss src/git.du.com/audit/audit.proto --svcout git.du.com/audit 2. 指定 pb 输出目录使用 --pbout 指定生成的 pb 文件保存目录，同样是 GOPATH 格式。新版本不再支持。 七 更多细节1. 端口相关truss 生成的服务同时支持 HTTP 和 gRPC 协议，程序运行是会有如下输出： 1234$ ./audit-server2019/02/01 22:41:08 transport gRPC addr :50402019/02/01 22:41:08 transport HTTP addr :50502019/02/01 22:41:08 transport debug addr :5060 服务的地址和端口可以通过命令行或环境变量设置，命令行方法： 1./audit-server --http.addr &quot;:8080&quot; --grpc.addr &quot;:9090&quot; 2. 请求处理与协程绑定gRPC 实现中每个请求会单独创建一个协程进行处理。可以在 google.golang.org/grpc/server.go 中看到： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697// Serve accepts incoming connections on the listener lis, creating a new// ServerTransport and service goroutine for each. The service goroutines// read gRPC requests and then call the registered handlers to reply to them.// Serve returns when lis.Accept fails with fatal errors. lis will be closed when// this method returns.// Serve will return a non-nil error unless Stop or GracefulStop is called.func (s *Server) Serve(lis net.Listener) error &#123; s.mu.Lock() s.printf(&quot;serving&quot;) s.serve = true if s.lis == nil &#123; // Serve called after Stop or GracefulStop. s.mu.Unlock() lis.Close() return ErrServerStopped &#125; s.serveWG.Add(1) defer func() &#123; s.serveWG.Done() select &#123; // Stop or GracefulStop called; block until done and return nil. case &lt;-s.quit: &lt;-s.done default: &#125; &#125;() ls := &amp;listenSocket&#123;Listener: lis&#125; s.lis[ls] = true if channelz.IsOn() &#123; ls.channelzID = channelz.RegisterListenSocket(ls, s.channelzID, &quot;&quot;) &#125; s.mu.Unlock() defer func() &#123; s.mu.Lock() if s.lis != nil &amp;&amp; s.lis[ls] &#123; ls.Close() delete(s.lis, ls) &#125; s.mu.Unlock() &#125;() var tempDelay time.Duration // how long to sleep on accept failure for &#123; rawConn, err := lis.Accept() if err != nil &#123; if ne, ok := err.(interface &#123; Temporary() bool &#125;); ok &amp;&amp; ne.Temporary() &#123; if tempDelay == 0 &#123; tempDelay = 5 * time.Millisecond &#125; else &#123; tempDelay *= 2 &#125; if max := 1 * time.Second; tempDelay &gt; max &#123; tempDelay = max &#125; s.mu.Lock() s.printf(&quot;Accept error: %v; retrying in %v&quot;, err, tempDelay) s.mu.Unlock() timer := time.NewTimer(tempDelay) select &#123; case &lt;-timer.C: case &lt;-s.quit: timer.Stop() return nil &#125; continue &#125; s.mu.Lock() s.printf(&quot;done serving; Accept = %v&quot;, err) s.mu.Unlock() select &#123; case &lt;-s.quit: return nil default: &#125; return err &#125; tempDelay = 0 // Start a new goroutine to deal with rawConn so we don&#x27;t stall this Accept // loop goroutine. // // Make sure we account for the goroutine so GracefulStop doesn&#x27;t nil out // s.conns before this conn can be added. s.serveWG.Add(1) go func() &#123; s.handleRawConn(rawConn) s.serveWG.Done() &#125;() &#125;&#125; 3. graceful shutdown不支持，需要自己写代码集成到服务中。","categories":[{"name":"Go","slug":"Go","permalink":"https://juzipeek.github.io/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://juzipeek.github.io/tags/Go/"}]},{"title":"The goa API Design Language","slug":"go-2018-12-11-The-goa-API-Design-Language","date":"2022-09-03T14:47:35.232Z","updated":"2022-09-03T14:54:58.881Z","comments":true,"path":"2022/09/03/go-2018-12-11-The-goa-API-Design-Language/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/go-2018-12-11-The-goa-API-Design-Language/","excerpt":"","text":"概述goa API 设计语言是 Go 中实现的 DSL，可以描述任意微服务API。虽然主要关注的是基于 REST 的 HTTP API，但该语言足够灵活，可以描述遵循其他方法的 API。使用插件可以扩展核心 DSL 以允许描述微服务的其他方面，例如数据库模型，服务发现集成，故障处理程序等。 设计定义设计语言的核心是由链接在一起描述定义的函数组成。goa 设计语言根定义是 API 定义，定义它的 DSL 如下所示： 123456789101112131415import ( . &quot;github.com/goadesign/goa/design&quot; . &quot;github.com/goadesign/goa/design/apidsl&quot;)var _ = API(&quot;My API&quot;, func() &#123; // &quot;My API&quot; is the name of the API used in docs Title(&quot;Documentation title&quot;) // Documentation title Description(&quot;The next big thing&quot;) // Longer documentation description Host(&quot;goa.design&quot;) // Host used by Swagger and clients Scheme(&quot;https&quot;) // HTTP scheme used by Swagger and clients BasePath(&quot;/api&quot;) // Base path to all API endpoints Consumes(&quot;application/json&quot;) // Media types supported by the API Produces(&quot;application/json&quot;) // Media types generated by the API&#125;) 关于“点导入”的旁注通常会出现这个问题：goa API 设计语言是在 Go 中实现的 DSL，而不是 Go（“点导入”的含义就是这个包导入之后在调用这个包的函数时，可以省略前缀的包名）。生成的代码或 goa 中的任何实际 Go 代码都不使用“点导入”。将此技术用于 DSL 可以获得更清晰的代码。它还允许透明地混合来自插件的 DSL，等待。 DSL 大量使用匿名函数来递归地描述各种定义。在上面的示例中，API 函数接受 API 的名称作为第一个参数，并接受匿名函数作为第二个参数。此匿名函数在本文档中也称为DSL，它定义了 API 的其他属性。许多其他 DSL 函数同样使用此模式（名称 + DSL）。 API 函数定义 API 的一般属性：文档中使用的 Title 和 Description，服务条款（上面的示例中未显示）文档和客户端中使用的默认主机和协议方案以及所有 API 端点的基本路径（可选地还通过基本路径中定义的通配符捕获相应的基本参数）。 该函数还定义了 API 支持的媒体类型。Consumes 和 Produces 函数可以为请求（Consumes）和响应（Produces）定义支持媒体类型，也可以指定生成的代码用于解码请求包体和编码响应包体的编码包。 API 函数中还可以定义许多其他属性，从附加元数据（联系信息）到安全定义，CORS 策略和响应模板。有关完整列表，请参阅参考资料。 API 端点除了根 API 定义之外，goa API 设计语言还可以描述实现端点以及请求和响应的详细信息。Resource 函数定义了一组相关的 API 端点 - 如果 API 是 RESTful，则为资源。使用 Action 函数描述每个实际端点。以下是一个简单的 Operands 资源示例，公开了一个添加操作（API 端点）： 123456789101112131415var _ = Resource(&quot;Operands&quot;, func() &#123; // Defines the Operands resource Action(&quot;add&quot;, func() &#123; // Defines the add action Routing(GET(&quot;/add/:left/:right&quot;)) // The relative path to the add endpoint Description(&quot;add returns the sum of :left and :right in the response body&quot;) Params(func() &#123; // Defines the request parameters // found in the URI (wildcards) and querystring Param(&quot;left&quot;, Integer, &quot;Left operand&quot;) // Defines left parameter as path segment // captured by :left Param(&quot;right&quot;, Integer, &quot;Right operand&quot;) // Define right parameter as path segment // captured by :right &#125;) Response(OK, &quot;plain/text&quot;) // Defines response &#125;)&#125;) 一个 Resource 函数可以定义任意数量的 Action。Resource 可定义公共基本路径，公共路径参数和其他的属性可以被 Resource 的参数共享。一个 Action 可以定义多个路由（Routing 函数的参数是可变参数），同一个 API 端点可以通过不同的路由或使用不同的 HTTP 方法访问。 在 DSL 中用于定义 Action 的参数可以指定参数的验证规则，范围从整数和数字的最小值和最大值到通过字符串参数的正则表达式定义的模式： 1234Param(&quot;left&quot;, Integer, &quot;Left operand&quot;, func() &#123; Minimum(0) // Do not allow for negative values.&#125;) 文件服务器Files 函数可以在资源上定义文件服务器。文件服务器可以提供对单个静态文件或如果路由以以 * 开头的通配符结束，则在给定文件路径下的所有文件。Files 函数可选择接受子 DSL（匿名函数作为最后一个参数）来定义安全方案。语法与用于定义操作的安全方案的语法相同。 以下演示了一个名叫 public 的资源，里面有两个文件服务器，一个为发送到 /swagger.json 的请求提供文件 public/swagger/swagger.json，另一个是发送到 /js/*filepath的public/js/ 下的所有其他文件，其中 *filepath 的值对应于相对于 /public/js 的文件路径。swagger 端点还定义了一个安全方案，要求客户端在能够检索 swagger 规范之前进行身份验证。 12345678910111213var _ = Resource(&quot;public&quot;, func() &#123; Origin(&quot;*&quot;, func() &#123; // CORS policy that applies to all actions and file servers Methods(&quot;GET&quot;) // of &quot;public&quot; resource &#125;) Files(&quot;/swagger.json&quot;, &quot;public/swagger/swagger.json&quot;, func() &#123; Security(&quot;basic_auth&quot;) // Security scheme implemented by /swagger.json endpoint &#125;) Files(&quot;/js/*filepath&quot;, &quot;public/js/&quot;) // Serve all files under the public/js directory&#125;) 数据类型goa API 设计语言可以描述任意的数据类型，API 可用于定义请求包体和响应媒体类型。Type 函数通过使用 Attribute 函数列出每个字段来描述数据结构，它还可以使用ArrayOf 函数来定义数组或数组。以下为示例： 123456789101112// Operand describes a single operand with a name and an integer value.var Operand = Type(&quot;Operand&quot;, func() &#123; Attribute(&quot;name&quot;, String, &quot;Operand name&quot;, func() &#123; // Attribute name of type string Pattern(&quot;^x&quot;) // with regex validation &#125;) Attribute(&quot;value&quot;, Integer, &quot;Operand value&quot;) // Attribute value of type integer Required(&quot;value&quot;) // only value is required&#125;)// Series represents an array of operands.var Series = ArrayOf(Operand) 请注意，与 API 函数一样，Type 函数接受两个参数：名称和描述类型属性的 DSL。Type DSL类型包含三个功能： Description：设置类型描述 Attribute：定义单个类型字段 Required：列出必填字段：必须始终存在于该类型实例中的字段 Type 函数可用于定义 Action 有效负载（以及其他内容）： 12345678Action(&quot;sum&quot;, func() &#123; // Defines the sum action Routing(POST(&quot;/sum&quot;)) // The relative path to the add endpoint Description(&quot;sum returns the sum of all the operands in the response body&quot;) Payload(Series) // Defines the action request body shape using the Series // type defined above. Response(OK, &quot;plain/text&quot;) // Defines a response&#125;) AttributesAttribute 在 goa DSL 中扮演着特殊的角色，它们是用于定义数据结构的基础。Attribute DSL 用于描述类型字段，请求参数，请求有效负载，响应头，响应主体等基本上任何需要定义数据结构的地方。定义属性的语法非常灵活，允许根据需要指定尽可能少的或完整的定义： 12Attribute(&lt;name&gt;, &lt;type&gt;, &lt;description&gt;, &lt;dsl&gt;) 只需要第一个参数，所有其他参数都是可选的。默认属性类型是 String。属性的可能类型是： Name Go equivalent JSON equivalent Boolean bool “true” or “false” Integer int number Number float number String string string DateTime time.Time RFC3339 string UUID uuid.UUID RFC4122 string Any interface{} ? 另外，可以使用 ArrayOf 或 HashOf 或使用递归 DSL 定义类型字段： 12345678910111213var User = Type(&quot;user&quot;, func() &#123; Description(&quot;A user of the API&quot;) Attribute(&quot;name&quot;) // Simple string attribute Attribute(&quot;address&quot;, func() &#123; // Nested definition, defines a struct in Go Attribute(&quot;number&quot;, Integer, &quot;Street number&quot;) Attribute(&quot;street&quot;, String, &quot;Street name&quot;) Attribute(&quot;city&quot;, String, &quot;City&quot;) Required(&quot;city&quot;) // The address must contain at least a city &#125;) Attribute(&quot;friends&quot;, ArrayOf(&quot;user&quot;)) Attribute(&quot;data&quot;, HashOf(String, String))&#125;) 请注意使用 “user” 类型名称来定义 friends 字段，而不是引用 User 类型变量。其实两种语法（使用“user”类型或“User”变量定义数组）都被接受。使用名称而不是变量引用允许构建递归定义。 示例 Github 存储库包含一个类型目录，其中包含许多示例，用于演示设计类型和生成的代码之间的映射。 ResponsesResponse Media Types接下来查看响应，goa 设计语言 MediaType 函数描述了表示响应主体的媒体类型。MediaType 的定义类似于 Type 的定义（媒体类型是一种特殊类型）但 MediaType 有两个独特的属性： Views：可以描述相同 MediaType 的不同渲染。通常，API 在列出请求时使用资源的“短”表示，并在返回单个资源的请求中使用更详细的表示。视图通过提供定义这些不同表示的方式来涵盖该用例。MediaType 定义必须定义用于呈现资源的默认视图（恰当地命名为 default）。 Links：表示应该嵌入在响应中的相关 MediaType。用于呈现链接的视图是链接，这意味着链接到的媒体类型必须定义链接视图。链接在媒体类型定义中的 Links 函数下列出。然后，视图可以使用指定 links 属性来呈现所有链接。 以下是 MediaType 定义的示例： 1234567891011121314151617181920212223242526272829303132333435363738394041// Results is the media type that defines the shape of the &quot;add&quot; action response.var Results = MediaType(&quot;vnd.application/goa.results&quot;, func() &#123; Description(&quot;The results of an operation&quot;) Attributes(func() &#123; // Defines the media type attributes Attribute(&quot;value&quot;, Integer, &quot;Results value&quot;) // Operation results attribute Attribute(&quot;requester&quot;, User) // Requester attribute &#125;) Links(func() &#123; // Defines the links embedded in the media type Link(&quot;requester&quot;) // One link to the requester, will be rendered // using the &quot;link&quot; view of User media type. &#125;) View(&quot;default&quot;, func() &#123; // Defines the default view Attribute(&quot;value&quot;) // Includes the &quot;value&quot; field in the default view Attribute(&quot;links&quot;) // And render links &#125;) View(&quot;extended&quot;, func() &#123; // Defines the extended view Attribute(&quot;value&quot;) // Includes the value field Attribute(&quot;requester&quot;) // and the requester field &#125;)&#125;)// User is the media type used to render user resources.var User = MediaType(&quot;vnd.application/goa.users&quot;, func() &#123; Description(&quot;A user of the API&quot;) Attributes(func() &#123; Attribute(&quot;id&quot;, UUID, &quot;Unique identifier&quot;) Attribute(&quot;href&quot;, String, &quot;User API href&quot;) Attribute(&quot;email&quot;, String, &quot;User email&quot;, func() &#123; Format(&quot;email&quot;) &#125;) &#125;) View(&quot;default&quot;, func() &#123; Attribute(&quot;id&quot;) Attribute(&quot;href&quot;) Attribute(&quot;email&quot;) &#125;) View(&quot;link&quot;, func() &#123; // The view used to render links to User media types. Attribute(&quot;href&quot;) // Here only the href attribute is rendered in links. &#125;)&#125;) Defining ResponsesResponse 函数用于 Action 声明以定义特定的潜在响应，它描述了响应状态代码，如果响应包含正文和标题，则为媒体类型。每个 Response 必须在 Action 范围内具有唯一名称，与大多数其他 DSL 功能一样，名称是第一个参数。以下 DSL 定义了一个名为“NoContent”的响应，该响应使用 HTTP 状态代码 204： 1234Response(&quot;NoContent&quot;, func() &#123; Description(&quot;This is the response returned in case of success&quot;) Status(204)&#125;) 请注意，此示例以及本节中的所有其他示例不使用响应模板，因此定义响应的所有属性，包括其名称。实际上，在大多数情况下，使用其中一个内置模板定义响应实现上面的响应（不添加描述）可以省略到： 1Response(NoContent) 响应模板将在下面的部分中详细介绍，但在我们讲解它们之前，我们必须首先了解 Response 的工作原理。 如果 Response 包含正文，则使用 Media 函数指定相应的媒体类型。此函数接受媒体类型标识符或实际媒体类型值作为第一个参数，并可选择接受用于呈现响应正文的媒体类型视图的名称。该视图是可选的，因为相同的 Action 可以根据请求状态返回不同的视图。以下是使用状态代码 200 和结果媒体类型的“OK”响应的 Results 定义示例： 12345Response(&quot;OK&quot;, func() &#123; Description(&quot;This is the success response&quot;) Status(200) Media(Results)&#125;) 为方便起见，响应的媒体类型可以作为 Response 函数的第二个参数提供（这在使用响应模板时特别有用，如下面相应部分所述）。因此上面的代码等同于如下代码： 1234Response(&quot;OK&quot;, Results, func() &#123; Description(&quot;This is the success response&quot;) Status(200)&#125;) 假设 Results 的标识符是 application/vnd.example.results，则上述内容相当于： 1234Response(&quot;OK&quot;, &quot;application/vnd.example.results&quot;, func() &#123; Description(&quot;This is the success response&quot;) Status(200)&#125;) 请注意，媒体类型标识符（上例中的 application/vnd.example.results）可能对应于通过 MediaType 函数定义的媒体类型的标识符。当媒体类型标识符与设计中定义的媒体类型不匹配时，生成的代码使用 Go 语言中 []byte 来定义响应主体的类型。 如果父操作始终返回默认视图，则响应可以定义为： 12345Response(&quot;OK&quot;, func() &#123; Description(&quot;This is the success response&quot;) Status(200) Media(Results, &quot;default&quot;)&#125;) 响应包头是使用 Headers 函数定义的，定义每个包头的语法与用于定义属性的语法相同： 12345678910Response(&quot;OK&quot;, func() &#123; Status(200) Media(Results, &quot;default&quot;) Headers(func() &#123; Header(&quot;Location&quot;, String, &quot;Resource location&quot;, func() &#123; Pattern(&quot;/results/[0-9]+&quot;) &#125;) Header(&quot;ETag&quot;) // assumes String type as with Attribute &#125;)&#125;) 使用默认 MediaTypeResource 可以为所有操作定义默认媒体类型。定义默认媒体类型有两个效果： 默认媒体类型用于返回状态代码 200 且未定义媒体类型的所有响应。 在响应包体、操作参数和响应媒体类型上定义的属性与默认媒体类型上定义的属性名称匹配，自动从其继承所有属性（描述，类型，验证等） 请考虑以下资源定义，该定义使用上面定义的 Results 媒体类型作为默认媒体类型，并利用它定义 add 动作的 OK 响应： 1234567891011var _ = Resource(&quot;Operands&quot;, func() &#123; DefaultMedia(Results) Action(&quot;add&quot;, func() &#123; Routing(GET(&quot;/add/:left/:right&quot;)) Params(func() &#123; Param(&quot;left&quot;, Integer, &quot;Left operand&quot;) Param(&quot;right&quot;, Integer, &quot;Right operand&quot;) &#125;) Response(OK) // Uses the resource default media type &#125;)&#125;) 现在假设 Results 媒体类型还返回用于计算总和的初始操作数： 123456789101112131415var Results = MediaType(&quot;vnd.application/goa.results&quot;, func() &#123; Description(&quot;The results of an operation&quot;) Attributes(func() &#123; Attribute(&quot;left&quot;, Integer, &quot;Left operand&quot;) Attribute(&quot;right&quot;, Integer, &quot;Right operand&quot;) Attribute(&quot;value&quot;, Integer, &quot;Results value&quot;) Attribute(&quot;requester&quot;, User) &#125;) View(&quot;default&quot;, func() &#123; Attribute(&quot;left&quot;) Attribute(&quot;right&quot;) Attribute(&quot;value&quot;) Attribute(&quot;requester&quot;) &#125;)&#125;) add 操作定义可以利用这一点来避免必须重复 left、right 参数的类型和注释： 1234567891011var _ = Resource(&quot;Operands&quot;, func() &#123; DefaultMedia(Results) Action(&quot;add&quot;, func() &#123; Routing(GET(&quot;/add/:left/:right&quot;)) Params(func() &#123; Param(&quot;left&quot;) // Inherits type and description from default media type Param(&quot;right&quot;) // Inherits type and description from default media type &#125;) Response(OK) // Uses the resource default media type &#125;)&#125;) 响应模版goa API 设计语言允许在 API 级别定义响应模板，任何操作都可以利用它来定义响应。此类模板可以接受任意数量的字符串参数来定义任何响应属性。使用以下语法定义模板： 123456789101112var _ = API(&quot;My API&quot;, func() &#123; ResponseTemplate(&quot;created&quot;, func(hrefPattern string) &#123; // Defines the &quot;created&quot; template Description(&quot;Resource created&quot;) // that takes one argument &quot;hrefPattern&quot; Status(201) // using status code 201 Headers(func() &#123; Header(&quot;Location&quot;, func() &#123; // and contains the &quot;Location&quot; header Pattern(hrefPattern) // with a regex validation defined by the // value of the &quot;hrefPattern&quot; argument. &#125;) &#125;) &#125;)&#125;) 然后在定义响应时通过名称简单地引用模板来使用模板： 12345Action(&quot;sum&quot;, func() &#123; Routing(POST(&quot;/accounts&quot;)) Payload(AccountPayload) Response(&quot;created&quot;, &quot;^/results/[0-9]+&quot;) // Response uses the &quot;created&quot; response template.&#125;) goa 框架所有标准 HTTP 状态码提供响应模板，因此不需要为简单情况定义模板。内置模板的名称与相应 HTTP 状态代码的名称匹配。例如： 1234567Action(&quot;show&quot;, func() &#123; Routing(GET(&quot;/:id&quot;)) Response(&quot;ok&quot;, func() &#123; Status(200) Media(AccountMedia) &#125;)&#125;) 等价于： 1234Action(&quot;show&quot;, func() &#123; Routing(GET(&quot;/:id&quot;)) Response(OK, AccountMedia) // Uses the built-in &quot;OK&quot; response template that defines status 200&#125;) 总结goa 设计语言还包含很多内容，但是这个概述应该让你了解它的工作原理。goa 设计语言不需要很长时间就能运用自如，从而可以快速迭代和完善设计。可以与其他开发者共享 Swagger 定义以收集反馈进行迭代。一旦完成，goagen 将生成 API 脚手架，从设计中请求上下文和验证代码，从而将其实现。该设计成为一个始终与实施最新的生动文档。","categories":[{"name":"Go","slug":"Go","permalink":"https://juzipeek.github.io/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://juzipeek.github.io/tags/Go/"}]},{"title":"Working with Data Types","slug":"go-2018-12-13-Working-with-Data-Types","date":"2022-09-03T14:47:35.231Z","updated":"2022-09-03T14:55:13.610Z","comments":true,"path":"2022/09/03/go-2018-12-13-Working-with-Data-Types/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/go-2018-12-13-Working-with-Data-Types/","excerpt":"","text":"1. 概述goa DSL 的一个重要方面在于如何定义和使用类型。概述介绍了使用类型和媒体类型的基础知识，本文档退后一步，解释了 DSL 的基本原理。 设计中使用 Attribute 函数或其别名之一（Member，Header 或 Param）描述数据结构。这种描述客观存在 - 即它与给定语言（例如Go）或技术无关。这使得可以生成许多输出，范围从 Go 代码到 JSON 格式和 Swagger 形式的文档或绑定到其他语言（例如 JavaScript 客户端）。DSL 包括概述中列出的许多基本类型，但也可以通过 Type 函数递归地描述任意数据结构。 2. 请求包体以这种方式定义的类型的主要应用之一是描述给定动作的请求包体，请求包体描述请求主体的类型。goagen 使用该描述生成操作方法在其请求上下文中接收的相应 Go 结构。有效负载可以内联定义如下： 1234567Action(&quot;create&quot;, func() &#123; Routing(POST(&quot;&quot;)) Payload(func() &#123; Member(&quot;name&quot;) &#125;) Response(Created, &quot;/accounts/[0-9]+&quot;)&#125;) 或者可以使用预先定义的类型： 123456789var CreatePayload = Type(&quot;CreatePayload&quot;, func() &#123; Attribute(&quot;name&quot;)&#125;)Action(&quot;create&quot;, func() &#123; Routing(POST(&quot;&quot;)) Payload(CreatePayload) Response(Created, &quot;/accounts/[0-9]+&quot;)&#125;) 前一种表示法最终会创建一个由生成器内部使用的匿名类型。请注意，DSL 是递归的，上面的示例没有指定 name 属性的类型，因此默认为 String。但它可以使用任何其他类型，包括内联定义的数据结构或通过预定义类型： 12345678910Action(&quot;create&quot;, func() &#123; Routing(POST(&quot;&quot;)) Payload(func() &#123; Member(&quot;address&quot;, func() &#123; Attribute(&quot;street&quot;) Attribute(&quot;number&quot;, Integer) &#125;) &#125;) Response(Created, &quot;/accounts/[0-9]+&quot;)&#125;) 或者： 1234567Action(&quot;create&quot;, func() &#123; Routing(POST(&quot;&quot;)) Payload(func() &#123; Member(&quot;name&quot;, Address) // where Address is a predefined type &#125;) Response(Created, &quot;/accounts/[0-9]+&quot;)&#125;) 无论在何处使用属性，都存在相同的灵活性。 可以使用如上所示的变量或使用其名称来引用预定义类型，即 Payload(CreatePayload) 也可以写为 Payload(&quot;CreatePayload&quot;)，因为 “CreatePayload” 是 CreatePayload 类型定义中给出的名称。他可以定义相互依赖的类型，而不会让 Go 编译器出现依赖循环。 3. 媒体类型类型的另一个常见用途是描述响应媒体类型。响应媒体类型定义响应包体的类型。媒体类型与类型的不同之处在于它们还定义了视图和链接，有关详细信息请参阅概述。基本媒体类型定义可能如下所示： 12345678var MT = MediaType(&quot;application/vnd.app.mt&quot;, func() &#123; Attributes(func() &#123; Attribute(&quot;name&quot;) &#125;) View(&quot;default&quot;, func() &#123; Attribute(&quot;name&quot;) &#125;)&#125;) MediaType 的第一个参数是 RFC 6838 定义的媒体类型标识符。DSL 列出的属性类似于如何在类型中定义属性，视图以及可选的链接到其他媒体类型，这里有 default 默认视图。然后可以使用这种媒体类型来定义动作的响应，如下所述： 12345678910Action(&quot;show&quot;, func() &#123; Routing(GET(&quot;/:accountID&quot;)) Params(func() &#123; Param(&quot;accountID&quot;, Integer, &quot;Account ID&quot;) &#125;) Response(OK, func() &#123; Media(MT) &#125;) Response(NotFound)&#125;) 这相当于： 12345678Action(&quot;show&quot;, func() &#123; Routing(GET(&quot;/:accountID&quot;)) Params(func() &#123; Param(&quot;accountID&quot;, Integer, &quot;Account ID&quot;) &#125;) Response(OK, MT) Response(NotFound)&#125;) 或者这样： 12345678Action(&quot;show&quot;, func() &#123; Routing(GET(&quot;/:accountID&quot;)) Params(func() &#123; Param(&quot;accountID&quot;, Integer, &quot;Account ID&quot;) &#125;) Response(OK, &quot;application/vnd.app.mt&quot;) Response(NotFound)&#125;) 可以使用变量或媒体类型标识符来引用媒体类型，类似于如何使用变量或其名称引用类型。 通常情况是使用相同的属性来定义动作请求包体和响应媒体类型。REST API 尤其如此，其中在响应中返回它的表示形式与请求的形式相同。goa 设计语言通过提供可以在 Type 和 MediaType 函数调用中使用的 Reference 函数来帮助解决这种常见情况。此函数接受一个参数，该参数可以是包含类型或媒体类型的变量，也可以是类型或媒体类型的名称。使用 Reference 函数可以重用所引用类型的属性，而无需重新定义其所有属性（类型，描述，示例，验证等）。给出以下类型定义： 1234567var CreatePayload = Type(&quot;CreatePayload&quot;, func() &#123; Attribute(&quot;name&quot;, String, &quot;Name of thingy&quot;, func() &#123; MinLength(5) MaxLength(256) Pattern(&quot;^[a-zA-Z]([a-zA-Z ]+)&quot;) &#125;)&#125;) 媒体类型可以利用 name 属性定义，如下所示： 123456789var MT = MediaType(&quot;application/vnd.app.mt&quot;, func() &#123; Reference(CreatePayload) Attributes(func() &#123; Attribute(&quot;name&quot;) &#125;) View(&quot;default&quot;, func() &#123; Attribute(&quot;name&quot;) &#125;)&#125;) name 属性自动继承相应 CreatePayload 属性中定义的类型，描述和验证。请注意，媒体类型定义仍然需要列出所引用的属性的名称，这使得可以选择要“继承”的属性。如果需要，媒体类型也可以覆盖 name 属性的属性（例如，改变类型，描述，验证等）。 媒体类型也可以使用媒体类型标识符来引用自己。这使得定义递归媒体类型成为可能，并且不让 Go 编译器产生循环依赖： 12345678910var MT = MediaType(&quot;application/vnd.app.mt&quot;, func() &#123; Reference(CreatePayload) Attributes(func() &#123; Attribute(&quot;name&quot;) Attribute(&quot;children&quot;, CollectionOf(&quot;application/vnd.app.mt&quot;)) &#125;) View(&quot;default&quot;, func() &#123; Attribute(&quot;name&quot;) &#125;)&#125;) 4. 混合 Type 和 MediaType我们已经看到了 Reference 如何在类型和媒体类型之间重用属性定义，媒体类型是一种特殊的类型。这意味着它们可以用于代替可以使用 Type 的类型（在定义属性的任何地方）。最佳实践包括仅使用媒体类型来定义响应主体，如上所示，并使用其他所有类型。这是因为媒体类型定义了其他属性，例如仅适用于该用例的标识符，视图和链接。因此，在 Type 和 MediaType 之间共享相同的属性时，定义 Type 并利用 Reference 关键字。","categories":[{"name":"Go","slug":"Go","permalink":"https://juzipeek.github.io/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://juzipeek.github.io/tags/Go/"}]},{"title":"goa-call_me service","slug":"go-2018-12-17-goa-call-me","date":"2022-09-03T14:47:35.231Z","updated":"2022-09-03T14:53:58.511Z","comments":true,"path":"2022/09/03/go-2018-12-17-goa-call-me/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/go-2018-12-17-goa-call-me/","excerpt":"","text":"概述goa 框架 demo。创建了一个名为 call_me 的服务，支持使用 GET 请求，url 中有 uid 参数。请求和应答包体均为 json 格式。 代码生成1234cd ~/Documents/00Code/call_me/srcgoagen bootstrap -d call_me/designgo build -o run 日志封装在 goa 框架内部使用 logrus 日志。其实在框架内封装了 logrus 的适配器，使用还是比较方便，但是 goa 的官方文档并没有做详细介绍。 logrus 设置方法： 创建 logrus 的 logger 使用 gologrus.New 函数创建 goa.LogAdapter 对象 使用 service.WithLogger(goalogrus.New(logger)) 将 goa.LogAdapter 设置到 service 对象 logrus 使用： 使用 goalogrus.Entry(ctx) 将 ctx 中 logrus.Entry 取出 使用 logru.Entry 对象进行日志打印 middleware在 goa 中可以使用 middleware 添加（HTTP）请求处理阶段。使用 comm_middleware.NewEntryMiddleware 创建新的 middleware，将其注册进 goa .Service 内。middleware 创建方法： 1234567891011121314151617func NewEntryMiddleware() goa.Middleware &#123; return func(h goa.Handler) goa.Handler &#123; return func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error &#123; goa.LogInfo(ctx, &quot;NewEntryMiddleware entry&quot;) // real process err := h(ctx, rw, req) resp := goa.ContextResponse(ctx) code := resp.ErrorCode goa.LogInfo(ctx, &quot;NewEntryMiddleware end&quot;, &quot;status&quot;, resp.Status, &quot;error&quot;, code, &quot;bytes&quot;, resp.Length, &quot;ctrl&quot;, goa.ContextController(ctx), &quot;action&quot;, goa.ContextAction(ctx)) return err &#125; &#125;&#125; 其中必须有 err := h(ctx, rw, req)，保证请求正常进行。 使用示例： 123456789package main....func main() &#123; service := goa.New(&quot;call_me&quot;) service.Use(comm_middleware.NewEntryMiddleware()) ...&#125; 测试命令接口测试命令： 12345678910111213curl -i -X GET \\ -H &quot;X-CallMeHeader:Test&quot; \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123;&quot;name&quot;:&quot;Beauty&quot;,&quot;age&quot;:18,&quot;gender&quot;:&quot;male&quot;,&quot;phone_no&quot;:&quot;132xxxx2638&quot;&#125;&#x27; \\ &quot;http://localhost:8080/meet/1&quot;# 压力测试ab -n 1000 -c 10 \\ -p call_me.json -m GET \\ -T application/json \\ -H &quot;X-CallMeHeader:Test&quot; \\ -H &quot;Content-Type: application/json&quot; \\ &quot;http://localhost:8080/meet/1&quot; call_me.json 中上报内容： 1&#123;&quot;name&quot;:&quot;zhoucj&quot;,&quot;age&quot;:18,&quot;gender&quot;:&quot;male&quot;,&quot;phone_no&quot;:&quot;13288882638&quot;&#125; 细节在使用 goa 进行设计时发现在一个微服务项目中只能有一个 API、Resource 函数。还有另外一个问题，如果已经存在了 Controller 文件之后不会再生成 Controller 文件。取巧的解决方法，将生成的 Controller 文件保存到另外一个文件中，删除生成的 Controller；当更新了设计接口时可以直接重新运行 goagen 命令。 项目链接 [demo]（https://github.com/juzipeek/call_me）","categories":[{"name":"Go","slug":"Go","permalink":"https://juzipeek.github.io/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://juzipeek.github.io/tags/Go/"}]},{"title":"Gin 框架","slug":"go-2019-01-13-Gin-框架","date":"2022-09-03T14:47:35.230Z","updated":"2022-09-03T14:55:51.853Z","comments":true,"path":"2022/09/03/go-2019-01-13-Gin-框架/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/go-2019-01-13-Gin-%E6%A1%86%E6%9E%B6/","excerpt":"","text":"概述本文摘取网上文章汇总。Gin 是一个 golang 的微框架，封装比较优雅，相对于 echo，Gin 更适用于企业开发。 一 Gin 安装1go get -v -u github.com/gin-gonic/gin 二 路由使用1. 默认中间件使用123456789101112131415// default.gopackage mainimport &quot;github.com/gin-gonic/gin&quot;func main() &#123; // gin.Default() 创建默认路由 r := gin.Default() r.GET(&quot;/ping&quot;, func(c *gin.Context) &#123; c.JSON(200, gin.H&#123; &quot;message&quot;: &quot;pong&quot;, &#125;) &#125;) r.Run() // 在 0.0.0.0:8080 上监听并服务&#125; 2. 无中间件的路由12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// customer.gopackage mainimport ( &quot;os&quot; &quot;github.com/gin-gonic/gin&quot; &quot;github.com/gogap/logrus&quot;)func init() &#123; logrus.SetOutput(os.Stdout) logrus.SetLevel(logrus.DebugLevel) logrus.Debug(&quot;logrus init&quot;)&#125;func middleware1(params string) gin.HandlerFunc &#123; return func(c *gin.Context) &#123; logrus.Debugf(&quot;middleware1:%s&quot;, params) c.Next() &#125;&#125;func middleware2(params string) gin.HandlerFunc &#123; return func(c *gin.Context) &#123; logrus.Debugf(&quot;middleware1:%s&quot;, params) c.Next() &#125;&#125;func pingEndPoint(c *gin.Context) &#123; c.JSON(200, gin.H&#123; &quot;message&quot;: &quot;pong&quot;, &#125;)&#125;func main() &#123; // 创建一个默认的没有任何中间件的路由 r := gin.New() // 全局中间件 // Logger 中间件将写日志到 gin.DefaultWriter ,即使你设置 GIN_MODE=release 。 // 默认 gin.DefaultWriter = os.Stdout r.Use(gin.Logger()) // Recovery 中间件从任何 panic 恢复，如果出现 panic，它会写一个 500 错误。 r.Use(gin.Recovery()) // 对所有路径都生效 r.Use(middleware1(&quot;comm&quot;)) // 每个路由的中间件, 能添加任意数量的中间件 r.GET(&quot;/ping&quot;, middleware2(&quot;ping&quot;), pingEndPoint) r.GET(&quot;/ping1&quot;, pingEndPoint) // 监听并服务于 0.0.0.0:8080 r.Run(&quot;:8080&quot;)&#125; 3. 动态路由有时候我们需要动态的路由，如 /user/:id，通过调用的 url 来传入不同的 id .在 Gin 中很容易处理这种路由： 12345678910111213141516171819202122232425262728293031package mainimport ( &quot;net/http&quot; &quot;github.com/gin-gonic/gin&quot;)func main() &#123; router := gin.Default() // 注册一个动态路由 // 可以匹配 /user/joy // 不能匹配 /user 和 /user/ router.GET(&quot;/user/:name&quot;, func(c *gin.Context) &#123; // 使用 c.Param(key) 获取 url 参数 name := c.Param(&quot;name&quot;) c.String(http.StatusOK, &quot;Hello %s&quot;, name) &#125;) // 注册一个高级的动态路由 // 该路由会匹配 /user/john/ 和 /user/john/send // 如果没有任何路由匹配到 /user/john, 那么他就会重定向到 /user/john/，从而被该方法匹配到 router.GET(&quot;/user/:name/*action&quot;, func(c *gin.Context) &#123; name := c.Param(&quot;name&quot;) action := c.Param(&quot;action&quot;) message := name + &quot; is &quot; + action c.String(http.StatusOK, message) &#125;) router.Run(&quot;:8080&quot;)&#125; 4. 路由组一些情况下，我们会有统一前缀的 url 的需求，典型的如 Api 接口版本号 /v1/something。Gin 可以使用 Group 方法统一归类到路由组中： 1234567891011121314151617181920212223242526272829303132333435363738package mainimport ( &quot;github.com/gin-gonic/gin&quot;)func newEndPoint(name string) gin.HandlerFunc &#123; return func(c *gin.Context) &#123; c.String(200, &quot;request[%s] ok!&quot;, name) &#125;&#125;func main() &#123; loginEndpoint := newEndPoint(&quot;login&quot;) submitEndpoint := newEndPoint(&quot;submit&quot;) readEndpoint := newEndPoint(&quot;read&quot;) router := gin.Default() // 定义一个组前缀 // /v1/login 就会匹配到这个组 v1 := router.Group(&quot;/v1&quot;) &#123; v1.GET(&quot;/login&quot;, loginEndpoint) v1.GET(&quot;/submit&quot;, submitEndpoint) v1.GET(&quot;/read&quot;, readEndpoint) &#125; // 定义一个组前缀 // 不用花括号包起来也是可以的。上面那种只是看起来会统一一点。看你个人喜好 v2 := router.Group(&quot;/v2&quot;) v2.GET(&quot;/login&quot;, loginEndpoint) v2.GET(&quot;/submit&quot;, submitEndpoint) v2.GET(&quot;/read&quot;, readEndpoint) router.Run(&quot;:8080&quot;)&#125; 三 查询参数1. URL 查询参数假定一个 url 为 /welcome?firstname=Jane&amp;lastname=Doe，我们想获取参数 firstname 的内容，可以使用c.Query方法。该方法始终返回一个 string 类型的数据。 12345678910111213141516171819202122232425package mainimport ( &quot;net/http&quot; &quot;github.com/gin-gonic/gin&quot;)func main() &#123; router := gin.Default() // 注册路由和Handler // url 为 /welcome?firstname=Jane&amp;lastname=Doe router.GET(&quot;/welcome&quot;, func(c *gin.Context) &#123; // 获取参数内容 // 获取的所有参数内容的类型都是 string // 如果不存在，使用第二个当做默认内容 firstname := c.DefaultQuery(&quot;firstname&quot;, &quot;Guest&quot;) // 获取参数内容，没有则返回空字符串 lastname := c.Query(&quot;lastname&quot;) c.String(http.StatusOK, &quot;Hello %s %s&quot;, firstname, lastname) &#125;) router.Run(&quot;:8080&quot;)&#125; 2. 其他格式的数据一些复杂的场景下，如用户直接 POST一段 json字符串到应用中，我们需要获取原始数据，这时需要用 c.GetRawData来获取原始字节。 1234567891011121314151617181920212223242526272829package mainimport ( &quot;os&quot; &quot;github.com/gin-gonic/gin&quot; &quot;github.com/gogap/logrus&quot;)func init() &#123; logrus.SetOutput(os.Stdout) logrus.SetLevel(logrus.DebugLevel) logrus.Debug(&quot;logrus init&quot;)&#125;func main() &#123; router := gin.Default() router.POST(&quot;/post&quot;, func(c *gin.Context) &#123; // 获取原始字节 d, err := c.GetRawData() if err != nil &#123; logrus.Fatalln(err) &#125; logrus.Println(string(d)) c.String(200, &quot;ok&quot;) &#125;) router.Run(&quot;:8080&quot;)&#125; 测试： 1curl -v -X POST http://localhost:8080/post -H &#x27;content-type: application/json&#x27; -d &#x27;&#123; &quot;name&quot;: &quot;joy&quot;,&quot;address&quot;:&quot;beijing&quot; &#125;&#x27; 四 数据绑定Gin 提供了非常方便的数据绑定功能，可以将用户传来的参数自动跟我们定义的结构体绑定在一起。 1. 只绑定 URL 查询参数使用 c.ShouldBindQuery方法，可以自动绑定 Url 查询参数到 struct 1234567891011121314151617181920212223242526272829303132333435363738package mainimport ( &quot;os&quot; &quot;github.com/Sirupsen/logrus&quot; &quot;github.com/gin-gonic/gin&quot;)// 定义一个 Person 结构体，用来绑定 url querytype Person struct &#123; Name string `form:&quot;name&quot;` // 使用成员变量标签定义对应的参数名 Address string `form:&quot;address&quot;`&#125;func init() &#123; logrus.SetOutput(os.Stdout) logrus.SetLevel(logrus.DebugLevel) logrus.Debug(&quot;logrus init&quot;)&#125;func main() &#123; route := gin.Default() // 任何 HTTP 方法 route.Any(&quot;/bind&quot;, startPage) route.Run(&quot;:8080&quot;)&#125;func startPage(c *gin.Context) &#123; var person Person // 将 url 查询参数和person绑定在一起 if c.ShouldBindQuery(&amp;person) == nil &#123; logrus.Info(&quot;====== Only Bind By Query String ======&quot;) logrus.Info(person.Name) logrus.Info(person.Address) &#125; c.String(200, &quot;Success&quot;)&#125; 测试 1curl -v -X POST &quot;http://localhost:8080/bind?name=joy&amp;address=beijing&quot; 2. 绑定 URL 查询参数和 POST 参数使用 c.ShouldBind方法，可以将参数自动绑定到 struct.该方法是会检查 Url 查询字符串和 POST 的数据，而且会根据 content-type类型，优先匹配JSON或者 XML,之后才是 Form. 有关详情查阅 这里 12345678910111213141516171819202122232425262728293031323334353637383940package mainimport ( &quot;log&quot; &quot;time&quot; &quot;github.com/Sirupsen/logrus&quot; &quot;github.com/gin-gonic/gin&quot;)// 定义一个 Person 结构体，用来绑定数据type Person struct &#123; Name string `form:&quot;name&quot;` Address string `form:&quot;address&quot;` Birthday time.Time `form:&quot;birthday&quot; time_format:&quot;2006-01-02&quot; time_utc:&quot;1&quot;`&#125;func main() &#123; route := gin.Default() // middleware 与 endpoint 处理函数是等价的，只是 endpoint 不需要 c.Next() 调用 route.Any(&quot;/bind&quot;, startPage, lastMiddleware) route.Run(&quot;:8080&quot;)&#125;func lastMiddleware(c *gin.Context) &#123; logrus.Info(&quot;last middleware&quot;)&#125;func startPage(c *gin.Context) &#123; var person Person // 绑定到 person if c.ShouldBind(&amp;person) == nil &#123; log.Println(person.Name) log.Println(person.Address) log.Println(person.Birthday) &#125; c.String(200, &quot;Success&quot;) c.Next()&#125; 测试 123456789101112131415# 此时获取 body 中内容进行绑定curl -v -X POST &quot;http://localhost:8080/bind?name=joy&amp;address=beijing&quot; -H &#x27;content-type: application/json&#x27; -d &#x27;&#123; &quot;name&quot;: &quot;joy1&quot;,&quot;address&quot;:&quot;beijing1&quot; &#125;&#x27;# 获取 url 参数内容进行绑定curl -v -X GET &quot;http://localhost:8080/bind?name=joy&amp;address=beijing&quot;# 能获取到 url 参数内容并进行绑定curl -v -X POST &quot;http://localhost:8080/bind?name=joy&amp;address=beijing&quot;# 能获取到 url 参数内容并进行绑定curl -v -X POST &quot;http://localhost:8080/bind?name=joy&amp;address=beijing&quot; -d &#x27;&#x27;# 无法获取到 url 参数自动进行绑定curl -v -X POST &quot;http://localhost:8080/bind?name=joy&amp;address=beijing&quot; -H &#x27;content-type: application/json&#x27;curl -v -X POST &quot;http://localhost:8080/bind?name=joy&amp;address=beijing&quot; -H &#x27;content-type: application/json&#x27; -d &#x27;&#x27; 五 生产环境运行变量更改 Gin 运行模式为发布模式 设置环境变量: export GIN_MODE=release在代码中设置: gin.SetMode(gin.ReleaseMode) 链接 中文说明文档","categories":[{"name":"Go","slug":"Go","permalink":"https://juzipeek.github.io/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://juzipeek.github.io/tags/Go/"}]},{"title":"grpc gateway 介绍","slug":"go-2019-04-05-grpc-gateway","date":"2022-09-03T14:47:35.230Z","updated":"2022-09-03T14:49:49.965Z","comments":true,"path":"2022/09/03/go-2019-04-05-grpc-gateway/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/go-2019-04-05-grpc-gateway/","excerpt":"","text":"一 概述本文主要介绍 grpc-gateway 使用以及实现原理。 二 grpc-gateway 基础1. 是什么grpc-gateway 是 protobuf 生成器 protoc 的一个插件。 2. 能做什么在 protobuf 的定义文件中添加 google.api.http 注解，grpc-gateway 可以读取 protobuf 定义文件并且生成反向代理服务，用来将 RESTful JSON 接口转换为gRPC 格式。 3. 安装grpc-gateway 依赖 ProtocolBuffer，需要先安装 ProtoBuffer： 12345678910mkdir tmpcd tmp# or wget https://github.com/protocolbuffers/protobuf/archive/v3.7.1.tar.gzgit clone https://github.com/google/protobufcd protobuf./autogen.sh./configuremakemake checksudo make install 安装 grpc-gateway： 12345678910111213141516# 下载 genprotocd $GOPATH/src/google.golang.orggit clone https://github.com/google/go-genproto.gitmv go-genproto/ genproto/# gopm get -v github.com/grpc-ecosystem/grpc-gateway/protoc-gen-grpc-gatewaygo get -u github.com/grpc-ecosystem/grpc-gateway/protoc-gen-grpc-gatewaygo install github.com/grpc-ecosystem/grpc-gateway/protoc-gen-grpc-gateway# gopm get -v github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swaggergo get -u github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swaggergo install github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swagger# gopm get -v github.com/golang/protobuf/protoc-gen-gogo get -u github.com/golang/protobuf/protoc-gen-gogo install github.com/golang/protobuf/protoc-gen-go 三 完整示例创建一个 SayHi 服务，接收 name 参数并返回 echo 消息。 1. 定义 gRPC 服务创建 say_hi.proto 文件，文件内容如下： 1234567891011121314151617181920212223syntax = &quot;proto3&quot;;package endpoint;import &quot;google/api/annotations.proto&quot;; // 导入注解包message HiReq &#123; string name = 1;&#125;message HiResp &#123; string echo = 2;&#125;service SayHi &#123; rpc SayHi (HiReq) returns (HiResp) &#123; // SayHi 接口的 RESTful 格式选项 option (google.api.http) = &#123; post: &quot;/api/sayhi&quot; body: &quot;*&quot; &#125;; &#125;&#125; 2. 生成 gRPC 桩代码1234protoc -I/usr/local/include -I. \\ -I/home/zhoucj/Project/go_play/src \\ -I/home/zhoucj/Project/go_play/src/github.com/grpc-ecosystem/grpc-gateway/third_party/googleapis \\ --go_out=plugins=grpc:. proto/say_hi.proto 执行完命令后会生成 proto/say_hi.pb.go 桩代码文件。 3. 生成反向代理服务12345protoc -I/usr/local/include -I. \\ -I/home/zhoucj/Project/go_play/src \\ -I/home/zhoucj/Project/go_play/src/github.com/grpc-ecosystem/grpc-gateway/third_party/googleapis \\ --grpc-gateway_out=logtostderr=true:. \\ proto/say_hi.proto 执行完命令后将生成 proto/sai_hi.pb.gw.go 反向代理文件。 4. 实现服务端接口123456789101112131415161718192021222324package srvimport ( &quot;context&quot; &quot;fmt&quot; &quot;endpoint/proto&quot;)func NewSayHiSrv() *SayHiSrv &#123; return &amp;SayHiSrv&#123;&#125;&#125;type SayHiSrv struct &#123;&#125;// 服务实现接口func (s *SayHiSrv) SayHi(c context.Context, req *endpoint.HiReq) (*endpoint.HiResp, error) &#123; fmt.Println(&quot;request name:&quot;, req.Name) msg := fmt.Sprintf(&quot;%s nice to meet u.&quot;, req.Name) resp := &amp;endpoint.HiResp&#123;Echo: msg&#125; fmt.Println(msg) return resp, nil&#125; 以上只需按一般方式实现 grpc server。 5. 将反向代理服务与 grpc server 关联12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package mainimport ( &quot;context&quot; &quot;fmt&quot; &quot;net&quot; &quot;net/http&quot; gw &quot;endpoint/proto&quot; &quot;srv&quot; &quot;github.com/grpc-ecosystem/grpc-gateway/runtime&quot; &quot;google.golang.org/grpc&quot;)const ( grpcAddr = &quot;:8090&quot; // grpc 服务端口 httpAddr = &quot;:8080&quot; // http 协议端口)func main() &#123; &#123; // grpc server rpcServer := grpc.NewServer() // 注册 grpc 处理函数 gw.RegisterSayHiServer(rpcServer, srv.NewSayHiSrv()) lis, _ := net.Listen(&quot;tcp&quot;, grpcAddr) go rpcServer.Serve(lis) &#125; &#123; // grpc gateway server mux := runtime.NewServeMux() ctx, _ := context.WithCancel(context.Background()) opts := []grpc.DialOption&#123;grpc.WithInsecure()&#125; // 注册反向代理服务 err := gw.RegisterSayHiHandlerFromEndpoint(ctx, mux, grpcAddr, opts) if err != nil &#123; fmt.Println(&quot;RegisterSayHiHandlerFromEndpoint error:&quot;, err.Error()) return &#125; // 启动反向代理服务 http.ListenAndServe(httpAddr, mux) &#125;&#125; 6. 编译测试12345go build main.gocurl -i -X POST -d &#x27;&#123;&quot;name&quot;:&quot;jay&quot;&#125;&#x27; &quot;http://localhost:8080/api/sayhi&quot;# 可以看到有 8090、8080 两个端口被监听netstat -ntl 四 深入grpc-gateway 内部实现在完整示例部分展示了如何将 HTTP 服务与 grpc 服务关联起来，其中的关键代码在下面： 1err := gw.RegisterSayHiHandlerFromEndpoint(ctx, mux, grpcAddr, opts) 其调用过程为： 1234567st=&gt;start: maine=&gt;end: Endop1=&gt;operation: RegisterSayHiHandlerFromEndpointop2=&gt;operation: RegisterSayHiHandlerop3=&gt;operation: RegisterSayHiHandlerClientst-&gt;op1-&gt;op2-&gt;op3-&gt;e 1. RegisterSayHiHandlerFromEndpoint123456789101112131415161718192021222324// RegisterSayHiHandlerFromEndpoint is same as RegisterSayHiHandler but// automatically dials to &quot;endpoint&quot; and closes the connection when &quot;ctx&quot; gets done.func RegisterSayHiHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) &#123; conn, err := grpc.Dial(endpoint, opts...) if err != nil &#123; return err &#125; defer func() &#123; if err != nil &#123; if cerr := conn.Close(); cerr != nil &#123; grpclog.Infof(&quot;Failed to close conn to %s: %v&quot;, endpoint, cerr) &#125; return &#125; go func() &#123; &lt;-ctx.Done() if cerr := conn.Close(); cerr != nil &#123; grpclog.Infof(&quot;Failed to close conn to %s: %v&quot;, endpoint, cerr) &#125; &#125;() &#125;() return RegisterSayHiHandler(ctx, mux, conn)&#125; 这个函数的主要功能是创建一个 grpc 连接 conn，并将其作为参数传递给 RegisterSayHiHandler 函数，ctx 在整个调用过链中是为了保证在主调用协程关闭时（调用了 cancel 方法）进行资源清理。 2. RegisterSayHiHandlerClient12345// RegisterSayHiHandler registers the http handlers for service SayHi to &quot;mux&quot;.// The handlers forward requests to the grpc endpoint over &quot;conn&quot;.func RegisterSayHiHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error &#123; return RegisterSayHiHandlerClient(ctx, mux, NewSayHiClient(conn))&#125; 3. RegisterSayHiHandlerClient1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// RegisterSayHiHandlerClient registers the http handlers for service SayHi// to &quot;mux&quot;. The handlers forward requests to the grpc endpoint over the given implementation of &quot;SayHiClient&quot;.// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in &quot;SayHiClient&quot;// doesn&#x27;t go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in// &quot;SayHiClient&quot; to call the correct interceptors.func RegisterSayHiHandlerClient(ctx context.Context, mux *runtime.ServeMux, client SayHiClient) error &#123; mux.Handle(&quot;POST&quot;, pattern_SayHi_SayHi_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) &#123; ctx, cancel := context.WithCancel(req.Context()) defer cancel() // 将 RESTful 请求转换为 protobuf 格式 inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req) rctx, err := runtime.AnnotateContext(ctx, mux, req) if err != nil &#123; runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err) return &#125; // 调用 grpc 接口进行处理 resp, md, err := request_SayHi_SayHi_0(rctx, inboundMarshaler, client, req, pathParams) ctx = runtime.NewServerMetadataContext(ctx, md) if err != nil &#123; runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err) return &#125; // 将 protobuf 应答转换 RESTful 格式应答并发送给客户端 forward_SayHi_SayHi_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...) &#125;) return nil&#125;// Handle associates &quot;h&quot; to the pair of HTTP method and path pattern.func (s *ServeMux) Handle(meth string, pat Pattern, h HandlerFunc) &#123; s.handlers[meth] = append(s.handlers[meth], handler&#123;pat: pat, h: h&#125;)&#125; 本函数是功能的核心，用来将服务接口路径（pattern_SayHi_SayHi_0）与处理函数相关联。处理函数注意有分为三个部分：将 RESTful 请求转换为 protobuf 格式、调用 grpc 接口进行处理、将 protobuf 应答转换 RESTful 格式应答并发送给客户端。 4. 处理 HTTP 请求以上 1 - 3 都在将请求之前的配置过程，在 HTTP 请求到来时怎么做呢？其实核心还是在 ServeMux 中，ServeMux 实现了 net/http.Handler 接口，主程序中已经通过代码 http.ListenAndServe(httpAddr, mux) 将 mux 设置为 HTTP 处理接口。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106// ServeHTTP dispatches the request to the first handler whose pattern matches to r.Method and r.Path.func (s *ServeMux) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123; ctx := r.Context() // 1. 请求格式校验 path := r.URL.Path if !strings.HasPrefix(path, &quot;/&quot;) &#123; if s.protoErrorHandler != nil &#123; _, outboundMarshaler := MarshalerForRequest(s, r) sterr := status.Error(codes.InvalidArgument, http.StatusText(http.StatusBadRequest)) s.protoErrorHandler(ctx, s, outboundMarshaler, w, r, sterr) &#125; else &#123; OtherErrorHandler(w, r, http.StatusText(http.StatusBadRequest), http.StatusBadRequest) &#125; return &#125; // 路径解析 components := strings.Split(path[1:], &quot;/&quot;) l := len(components) var verb string if idx := strings.LastIndex(components[l-1], &quot;:&quot;); idx == 0 &#123; if s.protoErrorHandler != nil &#123; _, outboundMarshaler := MarshalerForRequest(s, r) sterr := status.Error(codes.Unimplemented, http.StatusText(http.StatusNotImplemented)) s.protoErrorHandler(ctx, s, outboundMarshaler, w, r, sterr) &#125; else &#123; OtherErrorHandler(w, r, http.StatusText(http.StatusNotFound), http.StatusNotFound) &#125; return &#125; else if idx &gt; 0 &#123; c := components[l-1] components[l-1], verb = c[:idx], c[idx+1:] &#125; if override := r.Header.Get(&quot;X-HTTP-Method-Override&quot;); override != &quot;&quot; &amp;&amp; s.isPathLengthFallback(r) &#123; r.Method = strings.ToUpper(override) if err := r.ParseForm(); err != nil &#123; if s.protoErrorHandler != nil &#123; _, outboundMarshaler := MarshalerForRequest(s, r) sterr := status.Error(codes.InvalidArgument, err.Error()) s.protoErrorHandler(ctx, s, outboundMarshaler, w, r, sterr) &#125; else &#123; OtherErrorHandler(w, r, err.Error(), http.StatusBadRequest) &#125; return &#125; &#125; // 根据路径匹配处理函数 for _, h := range s.handlers[r.Method] &#123; pathParams, err := h.pat.Match(components, verb) if err != nil &#123; continue &#125; h.h(w, r, pathParams) return &#125; // lookup other methods to handle fallback from GET to POST and // to determine if it is MethodNotAllowed or NotFound. for m, handlers := range s.handlers &#123; if m == r.Method &#123; continue &#125; for _, h := range handlers &#123; pathParams, err := h.pat.Match(components, verb) if err != nil &#123; continue &#125; // X-HTTP-Method-Override is optional. Always allow fallback to POST. if s.isPathLengthFallback(r) &#123; if err := r.ParseForm(); err != nil &#123; if s.protoErrorHandler != nil &#123; _, outboundMarshaler := MarshalerForRequest(s, r) sterr := status.Error(codes.InvalidArgument, err.Error()) s.protoErrorHandler(ctx, s, outboundMarshaler, w, r, sterr) &#125; else &#123; OtherErrorHandler(w, r, err.Error(), http.StatusBadRequest) &#125; return &#125; h.h(w, r, pathParams) return &#125; if s.protoErrorHandler != nil &#123; _, outboundMarshaler := MarshalerForRequest(s, r) sterr := status.Error(codes.Unimplemented, http.StatusText(http.StatusMethodNotAllowed)) s.protoErrorHandler(ctx, s, outboundMarshaler, w, r, sterr) &#125; else &#123; OtherErrorHandler(w, r, http.StatusText(http.StatusMethodNotAllowed), http.StatusMethodNotAllowed) &#125; return &#125; &#125; if s.protoErrorHandler != nil &#123; _, outboundMarshaler := MarshalerForRequest(s, r) sterr := status.Error(codes.Unimplemented, http.StatusText(http.StatusNotImplemented)) s.protoErrorHandler(ctx, s, outboundMarshaler, w, r, sterr) &#125; else &#123; OtherErrorHandler(w, r, http.StatusText(http.StatusNotFound), http.StatusNotFound) &#125;&#125; 五 总结grpc-gateway 的本质是启动另外一个 HTTP 服务，用来将 HTTP 协议请求转换为 grpc 格式请求。 在 ServeMux 中 Handler 的存储结构为 slice，如果 Handler 过多会成为性能瓶颈。 六 其他说明ServeMuxServeMux(grpc-ecosystem/grpc-gateway/runtime.ServeMux)是 grpc-gateway 的请求多路复用器，用来匹配 HTTP 请求并调用相应的处理函数。","categories":[{"name":"Go","slug":"Go","permalink":"https://juzipeek.github.io/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://juzipeek.github.io/tags/Go/"},{"name":"grpc-gateway","slug":"grpc-gateway","permalink":"https://juzipeek.github.io/tags/grpc-gateway/"}]},{"title":"Go 中包划分方法","slug":"go-2018-12-05-Go-中包划分方法","date":"2022-09-03T14:47:35.229Z","updated":"2022-09-03T14:54:25.849Z","comments":true,"path":"2022/09/03/go-2018-12-05-Go-中包划分方法/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/go-2018-12-05-Go-%E4%B8%AD%E5%8C%85%E5%88%92%E5%88%86%E6%96%B9%E6%B3%95/","excerpt":"","text":"package 管理包在 Go 中使用包来组织代码，将一个系统划分为多个小模块，方便后续的维护、测试。之前在项目中使用过按功能划分包，当功能简单或者在最开始的设计阶段因为已经充分考虑了各个包的功能，所有划分还是很明确的。但是当功能复杂或者后续不断的迭代过程中，新加功能的划分就会出现模糊。最近看到一篇文章，里面介绍了一种使用 Go 标准库的划分包方案，摘抄在下面。 按依赖进行包划分这是 Go 标准库最常用的方案，比如 io.Reader、io.Writer、io.Closer 接口，字符串读取(bytes.Reader、strings.Reader)，文件读取(os.File)，网络读取(net.Conn)等都实现了 io.Reader 接口，我们在使用读取相关功能的时候，只需要导入 io 接口包和对应的 Reader 实现包(如 os.File )即可。这种模型的主要思维按照依赖进行划分: root 包: 声明原型和接口，不包含实现。root 包本身不依赖任何包。比如这里的 io 包。 implement 包: 对 root 包中的接口使用和实现。比如这里的 os、net、strings 等。 main 包: 导入 root 包和 implement 包，以 root 包接口为原型，实现对 implement 的桥接和依赖注入。 这种布局有几个好处: 按照依赖划分，更容易适应重构和需求变更 将依赖独立出去，代码变得很容易测试，比如很容易实现一个模拟 DB 操作的 dep 包，而业务逻辑无需任何变更 以接口为契约的包划分，要比直接包划分有更清晰的交互边界，前面提到的两种包划分（按功能模块纵向划分和 MVC 横向划分），做得不好很容易最终只是将代码分了几个目录存放，实际交互仍然混乱(比如直接修改其它包数据) 这种布局其实有点像前面提到的以接口包的形式将 A-&gt;B-&gt;A 的关系变为 IA-&gt;B-&gt;A，后者针对局部关系，而依赖划分强调从整体上思考这个功能模块的原型，然后围绕这些原型(接口)去扩展实现，最后在 main 包中将这些实现组装起来。关于这种包布局在这篇文章有很好的阐述。 标准库中的示例针对上面提到的 io、file 包的划分，摘取标准库中的组织结构展示，更加直观。 目录结构123root─┬─&#123;io&#125; └─&#123;os&#125; io 包中定义了接口，os.File 实现了接口；os 包并没有将代码放入 io 包内部。","categories":[{"name":"Go","slug":"Go","permalink":"https://juzipeek.github.io/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://juzipeek.github.io/tags/Go/"}]},{"title":"GOPATH 设置","slug":"go-2019-01-09-GOPATH-设置","date":"2022-09-03T14:47:35.228Z","updated":"2022-09-03T14:55:36.527Z","comments":true,"path":"2022/09/03/go-2019-01-09-GOPATH-设置/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/go-2019-01-09-GOPATH-%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"概述在写 GO 代码是经常需要设置 GOPATH 变量，有没有脚本来代替 export 操作？ 解决方法使用脚本可以将当前目录设置到 GOPATH 中，但是，这只对当前脚本有效（因为脚本是在单独的进程中执行）。最直接的想法是修改当前 shell 的 GOPATH 环境变量，不过没有找到方法。后面在使用 scl 命令时有了感触，可以使用创建一个新的 shell 环境，附带上想要的 GOPATH 变量。 实现脚本： 1234567891011#! /bin/bash## file : go_setup.sh #old=$GOPATHcwd=`pwd`path_var=&quot;$old:$cwd&quot; cmd=&quot;export GOPATH=$path_var; exec zsh&quot;zsh -c &quot;$cmd&quot; 总结遇到问题换条路走，要灵活，不过说的简单有时候也找不到其他路。","categories":[{"name":"Go","slug":"Go","permalink":"https://juzipeek.github.io/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://juzipeek.github.io/tags/Go/"}]},{"title":"Go 源码","slug":"go-2019-01-09-Go-源码","date":"2022-09-03T14:47:35.227Z","updated":"2022-09-03T14:55:26.510Z","comments":true,"path":"2022/09/03/go-2019-01-09-Go-源码/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/go-2019-01-09-Go-%E6%BA%90%E7%A0%81/","excerpt":"","text":"M在 runtime/proc.go 文件中可以看到函数 newm，跟踪进去会发现其实 M 就是系统线程。 init 所有 init 函数都在同一个 goroutine 内执行。 所有 init 函数结束后才会执行 main.main 函数。 内存分配基本策略 每次从操作系统申请一大块内存(比如 1MB),以减少系统调用。 将申请到的大块内存按照特定大小预先切分成小块,构成链表。 为对象分配内存时,只需从大小合适的链表提取一个小块即可。 回收对象内存时,将该小块内存重新归还到原链表,以便复用。 如闲置内存过多,则尝试归还部分内存给操作系统,降低整体开销。 内存分配器只管理内存块,并不关心对象状态。且不会主动回收内存,由垃圾回收器在完成清理操作后,触发内存分配器回收操作。go 使用 tcmalloc 框架 三色标记法这是让标记和用户代码并发的基本保障,基本原理: 起初所有对象都是白色。扫描找出所有可达对象,标记为灰色,放入待处理队列。从队列提取灰色对象,将其引用对象标记为灰色放入队列,自身标记为黑色。写屏障监视对象内存修改,重新标色或放回队列。 当完成全部扫描和标记工作后,剩余不是白色就是黑色,分别代表要待回收和活跃对象,清理操作只需将白色对象内存收回即可。 并发调度内置运行时,在进程和线程的基础上做更高层次的抽象是现代语言最流行的做法。虽然算不上激进,但 Golang 也设计了全新架构模型,将一切都基于并发体系之上,以适应多核时代。刻意模糊线程或协程概念,通过三种基本对象相互协作,来实现在用户空间管理和调度并发任务。 基本关系示意图: 1234567891011121314151617 +-------------------- sysmon ---------------//------+ | | | | +---+ +---+-------+ +--------+ +---+---+go func() ---&gt; | G | ---&gt; | P | local | &lt;=== balance ===&gt; | global | &lt;--//--- | P | M | +---+ +---+-------+ +--------+ +---+---+ | | | | +---+ | | +----&gt; | M | &lt;--- findrunnable -----+---steal&lt;--//--+ +---+ | | 1. 语句 go func() 创建 G +---- execute &lt;----schedule 2. 放入 P 本地队列（或平衡到全局队列） | | 3. 唤醒或新建 M 执行任务 | | 4. 进入调度循环 schedule +---&gt; G.fn --&gt; goexit--+ 5. 竭力获取待执行 G 任务并执行 6. 清理现场，重新进入调度循环 首先是 Processor(简称 P),其作用类似 CPU 核,用来控制可同时并发执行的任务数量。每个工作线程都必须绑定一个有效 P 才被允许执行任务,否则只能休眠,直到有空闲 P 时被唤醒。P 还为线程提供执行资源,比如对象分配内存、本地任务队列等。线程独享所绑定的 P 资源,可在无锁状态下执行高效操作。基本上,进程内的一切都在以 goroutine(简称 G)方式运行,包括运行时相关服务,以及main.main 入又函数。需要指出,G 并非执行体,它仅仅保存并发任务状态,为任务执行提供所需栈内存空间。G 任务创建后被放置在 P 本地队列或全局队列,等待工作线程调度执行。 实际执行体是系统线程(简称 M),它和 P 绑定,以调度循环方式不停执行 G 并发任务。M 通过修改寄存器,将执行栈指向 G 自带栈内存,并在此空间内分配堆栈帧,执行任务函数。当需要中途切换时,只要将相关寄存器值保存回 G 空间即可维持状态,任何 M 都可据此恢复执行。线程仅负责执行,不再持有状态,这是并发任务跨线程调度,实现多路复用的根本所在。尽管 P/M 构成执行组合体,但两者数量并非一一对应。通常情况下,P 数量相对恒定,默认与 CPU 核数量相同,但也可能更多或更少,而 M 则是调度器按需创建。举例来说,当M 因陷入系统调用而长时间阻塞时,P 就会被监控线程抢回,去新建(或唤醒)一个 M 执行其他任务,如此 M 的数量就会增长。因为 G 初始栈仅有 2KB,且创建操作只是在用户空间简单的对象分配,远比进入内核态分配线程要简单得多。调度器让多个 M 进入调度循环,不停获取并执行任务,所以我们才能创建成千上万个并发任务。 G 状态转换1234-- gfree -----+ |--&gt; IDLE --&gt; DEAD ------&gt; RUNNABLE ---&gt; RUNNING ---&gt; DEAD --- ... --&gt; gfree --&gt; 新建 初始化前 初始化后 调度执行 执行完毕 M 使用注意点我们允许进程里有成千上万的并发任务 G,但最好不要有太多的 M。且不说通过系统调用创建线程本身就有很大的性能损耗,大量闲置且不被回收的线程、M 对象、g0 栈空间都是资源浪费。好在这种情形极少出现,不过还是建议在生产部署前做严格测试。下面是利用 cgo 调用 sleep syscall 来生成大量 M 的示例。 123456789101112131415161718192021// test.gopackage mainimport ( &quot;sync&quot; &quot;time&quot;)// #include &lt;unistd.h&gt;import &quot;C&quot;func main() &#123; var wg sync.WaitGroup wg.Add(1000) for i := 0; i &lt; 1000; i++ &#123; go func() &#123; C.sleep(1) wg.Done() &#125;() &#125; wg.Wait() println(&quot;done!&quot;) time.Sleep(time.Second * 5)&#125; 利用 GODEBUG 输出调度器状态,你会看到大量闲置线程。 12345678910$go build -o test test$ GODEBUG=&quot;schedtrace=1000&quot; ./testSCHED 0ms: gomaxprocs=2 idleprocs=1 threads=3 spinningthreads=0 idlethreads=0 runqueue=0 [0 0]SCHED 1006ms: gomaxprocs=2 idleprocs=0 threads=728 spinningthreads=0 idlethreads=0 runqueue=125 [113 33]SCHED 2009ms: gomaxprocs=2 idleprocs=2 threads=858 spinningthreads=0 idlethreads=590 runqueue=0 [0 0]done!SCHED 3019ms: gomaxprocs=2 idleprocs=2 threads=858 spinningthreads=0 idlethreads=855 runqueue=0 [0 0]SCHED 4029ms: gomaxprocs=2 idleprocs=2 threads=858 spinningthreads=0 idlethreads=855 runqueue=0 [0 0]SCHED 5038ms: gomaxprocs=2 idleprocs=2 threads=858 spinningthreads=0 idlethreads=855 runqueue=0 [0 0]SCHED 6048ms: gomaxprocs=2 idleprocs=2 threads=858 spinningthreads=0 idlethreads=855 runqueue=0 [0 0] 除线程数量外,程序执行时间(user, sys)也有很大差别,可以简单对比一下。 123456789101112func main() &#123; var wg sync.WaitGroup wg.Add(1000) for i := 0; i &lt; 1000; i++ &#123; go func() &#123; C.sleep(1) //1 // time.Sleep(time.Second) // wg.Done() &#125;() &#125; wg.Wait()&#125; 测试： 12345678$ go build -o test1 test.go &amp;&amp; time ./test1real 0m1.159suser 0m0.056ssys 0m0.105s$ go build -o test2 test.go &amp;&amp; time ./test2real 0m1.022suser 0m0.006ssys 0m0.006s 标准库封装的 time.Sleep 针对 goroutine 进行了改进,并未使用 syscall。当然,这个示例和测试结果也仅用于演示,具体问题具体对待。 系统调用为支持并发调度,专门对 syscall、cgo 进行了包装,以便在长时间阻塞时能切换执行其他任务。标准库 syscall 包里,将相关系统调用函数分为 Syscall 和 RawSyscall 两类。最大的不同在于 Syscall 增加 entrysyscall/exitsyscall，这就是允许调度的关键所在。监控线程 sysmon 对 syscall 非常重要,因为它负责将因系统调用而长时间阻塞的 P 抢回，用于执行其他任务。否则,整体性能会严重下降,甚至整个进程被冻结。cgo 使用了相同的封装方式,因为它同样不受调度器管理。cgocall.go ： 123456789101112131415func cgocall(fn, arg unsafe.Pointer) int32 &#123; /* * Announce we are entering a system call * so that the scheduler knows to create another M to run goroutines while we are in * the foreign code. * * The call to asmcgocall is guaranteed not to split the stack and does not allocate * memory, so it is safe to call while &quot;in a system call&quot;, outside the $GOMAXPROCS * accounting. */ entersyscall(0) errno := asmcgocall(fn, arg) exitsyscall(0)&#125; 抢占调用所谓抢占调度要比你想象的简单许多,远不是你以为的 “抢占式多任务操作系统” 那种样子。因为 Golang 调度器并没有真正意义上的时间片概念,只是在目标 G 上设置一个抢占标志,当该任务调用某个函数时,被编译器安插的指令就会检查这个标志,从而决定是否暂停当前任务。 runtime.Goexit用户可调用 runtime.Goexit 立即终止 G 任务,不管当前处于调用堆栈的哪个层次。在终止前,它确保所有 G.defer 被执行。 12345678910// panic.gofunc Goexit() &#123; gp := getg() for &#123; d := gp._defer ... freedefer(d) &#125; goexit1()&#125; 比较有趣的是在 main goroutine 里执行 Goexit,它会等待其他 goroutine 结束后才会崩溃。 chanchannel 中数据类型大小不能超过 64K。sudog 是 channel 与 G 的桥梁，需要使用 sudog 唤醒相应的 G。 defer延迟调用(defer) 最大优势是,即便函数执行出错,依然能保证回收资源等操作得以执行。编译器将 defer 处理成两个函数调用,deferproc 定义一个延迟调用对象,然后在函数结束前通过 deferreturn 完成最终调用。 对象析构示例123456789101112131415package mainimport ( &quot;runtime&quot; &quot;time&quot;)func main() &#123; x := 123 runtime.SetFinalizer(&amp;x, func(x *int) &#123; println(x, *x, &quot;finalizer.&quot;) &#125;) runtime.GC() time.Sleep(time.Minute)&#125; sync.Pool","categories":[{"name":"Go","slug":"Go","permalink":"https://juzipeek.github.io/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://juzipeek.github.io/tags/Go/"}]},{"title":"linux coredump 产生配置","slug":"c-2018-12-20-linux-coredump","date":"2022-09-03T14:47:35.226Z","updated":"2022-09-03T14:47:35.226Z","comments":true,"path":"2022/09/03/c-2018-12-20-linux-coredump/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/c-2018-12-20-linux-coredump/","excerpt":"","text":"概述在开发过程中有可能出现异常，虽然通过 dmesg 可以看到错误的 ip 但是只能定位到错误行号，执行上下文其实是看不到的。系统生成的 coredump 文件可以方便分析执行上下文。 开启 coredump 产生1. limits.conf 配置12345678vi /etc/security/limits.conf# 行未添加* soft core 20480* hard core 20480# 需要重新登录后才能生效ulimit -a 2. core 文件路径1234567vi /etc/sysctl.conf# 添加记录kernel.core_pattern = /tmp/core.%e.%t# 生效sysctl -p nginx 配置可以在 nginx.conf 中配置 coredump 生成路径以及文件名： 12worker_rlimit_core 200m;working_directory /tmp;","categories":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"}]},{"title":"修改常量值","slug":"c-2020-03-19-const-value","date":"2022-09-03T14:47:35.226Z","updated":"2022-09-03T14:47:35.226Z","comments":true,"path":"2022/09/03/c-2020-03-19-const-value/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/c-2020-03-19-const-value/","excerpt":"","text":"一 常量值const 修饰符修饰变量是不可修改的, 如果尝试修改 const 类型变量会编译失败. 但是使用指针修改 const 变量能修改常量. 12345678910111213141516#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123; int const n = 10; printf(&quot;n = [%d]\\n&quot;, n); // 编译错误 // n = 11; // printf(&quot;n = [%d]\\n&quot;, n); // 编译成功, 但是有 discarded-qualifiers 警告 int *p = &amp;n; *p = 12; printf(&quot;n = [%d]\\n&quot;, n);&#125; const 修饰符是在编译时起作用的, 编译出的汇编代码是没有差异的. 可以使用 gcc -S 分别编译两个版本进行对比. 这个特性不应该滥用.","categories":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"}]},{"title":"c call cpp function","slug":"c-2018-12-16-c-call-cpp-function","date":"2022-09-03T14:47:35.225Z","updated":"2022-09-03T14:47:35.225Z","comments":true,"path":"2022/09/03/c-2018-12-16-c-call-cpp-function/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/c-2018-12-16-c-call-cpp-function/","excerpt":"","text":"1. 概述在做开发时项目是用 C 语言写的，有时候需要调用 C++ 接口或库。本文对此进行总结记录，以备不时之需。 2. C++ 函数声明当需要调用 C++ 接口时可以写一个单独的 C++ 源文件实现包裹函数对接口的操作。此时只需要对包裹函数做 extern &quot;C&quot; 声明。如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186// dynamodb.cpp#include &lt;aws/core/Aws.h&gt;#include &lt;aws/core/utils/Outcome.h&gt;#include &lt;aws/dynamodb/DynamoDBClient.h&gt;#include &lt;aws/dynamodb/model/AttributeDefinition.h&gt;#include &lt;aws/dynamodb/model/GetItemRequest.h&gt;#include &lt;aws/dynamodb/DynamoDBErrors.h&gt;#include &quot;dynamodb.h&quot;static Aws::SDKOptions g_sdk_options;static Aws::DynamoDB::DynamoDBClient *g_db_client;/****************************************************************************** * shutdown ******************************************************************************/voiddu_dynamodb_shutdown()&#123; Aws::ShutdownAPI(g_sdk_options);&#125;/****************************************************************************** * init ******************************************************************************/voiddu_dynamodb_init()&#123; Aws::InitAPI(g_sdk_options); Aws::Client::ClientConfiguration cfg; cfg.region = Aws::String(AWS_REGION); cfg.maxConnections = DYNAMODB_MAX_CONNECTION; cfg.connectTimeoutMs = DYNAMODB_CONNECTION_TIMEOUT; cfg.requestTimeoutMs = DYNAMODB_CONNECTION_TIMEOUT; // cfg.tcpKeepAliveIntervalMs = 30; g_db_client = new Aws::DynamoDB::DynamoDBClient(cfg);&#125;/****************************************************************************** * ******************************************************************************/DU_DB_ERRdu_dynamodb_get_idfa_type(const char *did, int *idfa_type)&#123; DU_DB_ERR ret = DU_DB_ERR_INIT; Aws::DynamoDB::DynamoDBErrors dynamodb_err; Aws::DynamoDB::Model::GetItemRequest queryReq; do &#123; queryReq.SetTableName(DEVICE_TABLE); queryReq.SetProjectionExpression(IDFA_TYPE_FIELD); if (!idfa_type) &#123; ret = DU_DB_ERR_BAD_PARAMETER; break; &#125; if (!did) &#123; ret = DU_DB_ERR_BAD_PARAMETER; break; &#125; Aws::DynamoDB::Model::AttributeValue did_key; did_key.SetS(did); queryReq.AddKey(QUERY_DID_FIELD, did_key); const Aws::DynamoDB::Model::GetItemOutcome&amp; result = g_db_client-&gt;GetItem(queryReq); if (!result.IsSuccess()) &#123; dynamodb_err = result.GetError().GetErrorType(); if (Aws::DynamoDB::DynamoDBErrors::NETWORK_CONNECTION == dynamodb_err || Aws::DynamoDB::DynamoDBErrors::REQUEST_TIMEOUT == dynamodb_err) &#123; &#125; du_log(NGX_LOG_ERR, NULL, 0, &quot;GetItem fail! error:%d&quot;, dynamodb_err); ret = DU_DB_ERR_QUERY_FAIL; break; &#125; const Aws::Map&lt;Aws::String, Aws::DynamoDB::Model::AttributeValue&gt;&amp; item = result.GetResult().GetItem(); if (!item.size()) &#123; // find attribute NULL du_log(NGX_LOG_ERR, NULL, 0, &quot;GetResult fail! item size is zero.&quot;); ret = DU_DB_ERR_FETCH_NULL; break ; &#125; try &#123; *idfa_type = atoi(item.at(&quot;idfa_type&quot;).GetN().c_str()); &#125; catch (const std::exception&amp; ex) &#123; // error process // catch(const std::out_of_range&amp; oor) du_log(NGX_LOG_ERR, NULL, 0, &quot;get idfa_type fail! exception:%s&quot;, ex.what()); ret = DU_DB_ERR_FETCH_NULL; break; &#125; ret = DU_DB_OK; &#125; while(0); du_log(NGX_LOG_DEBUG, NULL, 0, &quot;dynamodb_get_idfa_type ret:%d&quot;, ret); return ret;&#125;/******************************************************************************* * ******************************************************************************/DU_DB_ERRdu_dynamodb_get_app_type(const char *table_name, const char *did, const char *ver_q, size_t ver_size, char *ver, int *normal_times, int *duplicate_times, int *recall_times, int *update_times)&#123; DU_DB_ERR ret = DU_DB_ERR_INIT; Aws::DynamoDB::DynamoDBErrors dynamodb_err; Aws::DynamoDB::Model::GetItemRequest queryReq; do &#123; if (!table_name || !did || !ver || !normal_times || !duplicate_times || !update_times || !recall_times) &#123; // param error ret = DU_DB_ERR_BAD_PARAMETER; break; &#125; queryReq.SetTableName(table_name); queryReq.SetProjectionExpression(APP_TYPE_FIELD); Aws::DynamoDB::Model::AttributeValue did_key; did_key.SetS(did); queryReq.AddKey(QUERY_DID_FIELD, did_key); if (ver_q &amp;&amp; strlen(ver_q)) &#123; Aws::DynamoDB::Model::AttributeValue ver_key; ver_key.SetS(ver_q); queryReq.AddKey(QUERY_VER_FIELD, ver_key); &#125; const Aws::DynamoDB::Model::GetItemOutcome&amp; result = g_db_client-&gt;GetItem(queryReq); if (!result.IsSuccess()) &#123; // Not Found Or error dynamodb_err = result.GetError().GetErrorType(); if (Aws::DynamoDB::DynamoDBErrors::NETWORK_CONNECTION == dynamodb_err || Aws::DynamoDB::DynamoDBErrors::REQUEST_TIMEOUT == dynamodb_err) &#123; &#125; du_log(NGX_LOG_ERR, NULL, 0, &quot;GetItem fail! error:%d&quot;, dynamodb_err); ret = DU_DB_ERR_QUERY_FAIL; break; &#125; const Aws::Map&lt;Aws::String, Aws::DynamoDB::Model::AttributeValue&gt;&amp; item = result.GetResult().GetItem(); if (!item.size()) &#123; // find attribute NULL du_log(NGX_LOG_ERR, NULL, 0, &quot;GetResult fail! item size is zero.&quot;); ret = DU_DB_ERR_FETCH_NULL; break; &#125; try &#123; snprintf(ver, ver_size, &quot;%s&quot;, item.at(&quot;ver&quot;).GetS().c_str()); *normal_times = atoi(item.at(&quot;normal&quot;).GetN().c_str()); *duplicate_times = atoi(item.at(&quot;dup&quot;).GetN().c_str()); *recall_times = atoi(item.at(&quot;recall&quot;).GetN().c_str()); *update_times = atoi(item.at(&quot;update&quot;).GetN().c_str()); &#125; catch(const std::exception&amp; ex) &#123; // error process // catch(const std::out_of_range&amp; oor) du_log(NGX_LOG_ERR, NULL, 0, &quot;get app_type fail! exception:%s&quot;, ex.what()); ret = DU_DB_ERR_FETCH_NULL; break; &#125; // success ret = DU_DB_OK; &#125; while(0); du_log(NGX_LOG_DEBUG, NULL, 0, &quot;du_dynamodb_get_app_type ret:%d&quot;, ret); return ret;&#125; 头文件写法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// dynamodb.h#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;time.h&gt;#include &lt;sys/time.h&gt;#include &lt;sys/types.h&gt;#include &quot;log.h&quot;#ifndef _DU_DYNAMODB_H__#define _DU_DYNAMODB_H__#ifdef __cplusplusextern &quot;C&quot;&#123;#endif#define AWS_REGION &quot;us-east-2&quot;#define DEVICE_TABLE &quot;device&quot;#define IDFA_TYPE_FIELD &quot;idfa_type&quot;#define QUERY_DID_FIELD &quot;did&quot;#define APP_TYPE_FIELD &quot;idfa_type&quot;#define QUERY_VER_FIELD &quot;ver&quot;#define DYNAMODB_MAX_CONNECTION 40#define DYNAMODB_CONNECTION_TIMEOUT 1000#define du_log( level, log, errno, fmt, ... ) trace_debug( fmt &quot;\\t&quot;, ##__VA_ARGS__ );/* 数据库操作返回码 */typedef enum du_db_err &#123; DU_DB_OK = 0, DU_DB_DB_OVER_MAX, DU_DB_ERR_BAD_PARAMETER, DU_DB_ERR_INIT, DU_DB_ERR_NEW_URI, DU_DB_ERR_CONNECT, DU_DB_ERR_CONNECT_TOO_OFTEN, DU_DB_ERR_NO_MEMORY, DU_DB_ERR_QUERY_FAIL, DU_DB_ERR_FETCH_NULL,&#125; DU_DB_ERR;voiddu_dynamodb_shutdown();voiddu_dynamodb_init();DU_DB_ERRdu_dynamodb_get_idfa_type(const char *did, int *idfa_type);DU_DB_ERRdu_dynamodb_get_app_type(const char *table_name, const char *did, const char *ver_q, size_t ver_size, char *ver, int *normal_times, int *duplicate_times, int *recall_times, int *update_times);#ifdef __cplusplus&#125;#endif#endif 以上示例并没有涉及到成员函数的调用，如果需要可以参见链接。 3. 编译注意因为项目是用 C 编写，项目的执行文件需要使用 gcc 进行编译（Linux 平台）。此时需要添加链接选项 -lstdc++，不然项目编译会失败。 4. 参考链接 mixing-c-and-cpp How to call C++ class member function from C","categories":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"}]},{"title":"SSDB impl","slug":"c-2019-05-12-SSDB-impl","date":"2022-09-03T14:47:35.225Z","updated":"2022-09-03T14:48:37.486Z","comments":true,"path":"2022/09/03/c-2019-05-12-SSDB-impl/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/c-2019-05-12-SSDB-impl/","excerpt":"","text":"概述SSDB 使用 LevelDB 存储数据，读写数据直接使用 LevelDB 接口实现。在网络时间处理方面使用读/写事件线程池提高处理性能，优先使用 epoll 作为事件处理器，否则降级为 select。 一 网络事件处理在 SSDB 中将事件抽象为 Fdevent 类型，时间处理抽象为 Fdevents。在 Fdevents 中使用 vector 保存需要监听的全部 Fdevent 事件（events 中保存）、以及已经触发的 SSDB 指令事件（ready_events 中保存）。 事件处理循环读起来有些混乱，在整个循环的前部分将需要处理的事件放入 ready_events 中，后半部分将 ready_events 中的事件匹配对应的 Redis 指令处理函数，并将其放入读/写事件处理线程池中。在线程池中，会将指令的处理结果发送给客户端。 [ssdb]/src/net/server.cpp:serve() 事件处理主体 [ssdb]/src/net/server.cpp:serve() const Request *req = link-&gt;recv();：指令解析 int result=this-&gt;proc(job);：将解析出来的指令作为任务添加到线程池中 job-&gt;cmd = proc_map.get_proc(req-&gt;at(0));：设置指令对应的处理函数指针 二 指令处理在读/写线程池中，实际的指令处理函数为 int ProcWorker::proc(ProcJob *job)。所有的函数指针在 SSDBServer 对象创建阶段进行注册（通过 reg_procs 函数进行注册）。根据注册函数表可以找到对应的处理函数，例如注册 REG_PROC(get, &quot;rt&quot;) 找到处理函数为 proc_get，即可以跟踪指令处理。 1. set 指令处理函数调用顺序：proc_set() =&gt; serv-&gt;ssdb-&gt;set() =&gt; binlogs-&gt;Put()/add_log()/commit()从上面的调用流程可以看出数据先保存在 binlog 中（LevelDB）实现。 2. get 指令处理函数调用顺序：proc_get() =&gt; serv-&gt;ssdb-&gt;get() =&gt; ldb-&gt;Get()为什么在 set 指令中将数据保存在 binlog 中，而 get 指令却在 ldb 中进行数据查找？其实 binlog 底层使用 leveldb 进行数据存储，其使用的数据文件即 SSDBImpl::ldb 成员。 123456789101112131415161718192021222324252627282930313233SSDB* SSDB::open(const Options &amp;opt, const std::string &amp;dir)&#123; SSDBImpl *ssdb = new SSDBImpl(); ssdb-&gt;options.max_file_size = 32 * 1048576; // leveldb 1.20 ssdb-&gt;options.create_if_missing = true; ssdb-&gt;options.max_open_files = opt.max_open_files; ssdb-&gt;options.filter_policy = leveldb::NewBloomFilterPolicy(10); ssdb-&gt;options.block_cache = leveldb::NewLRUCache(opt.cache_size * 1048576); ssdb-&gt;options.block_size = opt.block_size * 1024; ssdb-&gt;options.write_buffer_size = opt.write_buffer_size * 1024 * 1024; ssdb-&gt;options.compaction_speed = opt.compaction_speed; if(opt.compression == &quot;yes&quot;)&#123; ssdb-&gt;options.compression = leveldb::kSnappyCompression; &#125;else&#123; ssdb-&gt;options.compression = leveldb::kNoCompression; &#125; leveldb::Status status; status = leveldb::DB::Open(ssdb-&gt;options, dir, &amp;ssdb-&gt;ldb); if(!status.ok())&#123; log_error(&quot;open db failed: %s&quot;, status.ToString().c_str()); goto err; &#125; // binlogs 底层使用 ldb 存储数据 ssdb-&gt;binlogs = new BinlogQueue(ssdb-&gt;ldb, opt.binlog, opt.binlog_capacity); return ssdb;err: if(ssdb)&#123; delete ssdb; &#125; return NULL;&#125;","categories":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"CPP","slug":"CPP","permalink":"https://juzipeek.github.io/tags/CPP/"},{"name":"LevelDB","slug":"LevelDB","permalink":"https://juzipeek.github.io/tags/LevelDB/"},{"name":"SSDB","slug":"SSDB","permalink":"https://juzipeek.github.io/tags/SSDB/"}]},{"title":"动态库中全局变量是否会有冲突","slug":"c-2018-12-14-global-var-in-dynamic-lib","date":"2022-09-03T14:47:35.224Z","updated":"2022-09-03T14:47:35.224Z","comments":true,"path":"2022/09/03/c-2018-12-14-global-var-in-dynamic-lib/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/c-2018-12-14-global-var-in-dynamic-lib/","excerpt":"","text":"概述如果两个动态库中有相同的全局变量会不会冲突？ 测试动态库 1： 12345678910111213141516171819202122232425// dynamic_1.c// gcc -fPIC -shared -Wall -g dynamic_1.c -o libshared_1.so// #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;time.h&gt;#include &lt;sys/time.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/timerfd.h&gt;#include &quot;log.h&quot;#include &quot;local.h&quot;int g_val = 12;int hello() &#123; trace_debug( &quot;in shared_hello static_hello addr:[%p][%d]&quot;, hello, g_val); return 0;&#125; 动态库 2： 12345678910111213141516171819202122232425// dynamic_2.c// gcc -fPIC -shared -Wall -g dynamic_2.c -o libshared_2.so// #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;time.h&gt;#include &lt;sys/time.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/timerfd.h&gt;#include &quot;log.h&quot;#include &quot;local.h&quot;int g_val = 13;int hello() &#123; trace_debug( &quot;in shared_hello static_hello addr:[%p][%d]&quot;, hello, g_val); return 0;&#125; 测试： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// dlopen.c// gcc -rdynamic -Wall -g dlopen.c -ldl -o run// #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;dlfcn.h&gt;#include &lt;time.h&gt;#include &lt;sys/time.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/timerfd.h&gt;#include &quot;log.h&quot;typedef int (*function_hello)();int main(int argc, char **argv) &#123; char log_file[256] = &#123;0&#125;; sprintf( log_file,&quot;%s/log.out&quot;, getenv(&quot;HOME&quot;) ); log_init( log_file ); void *handle1 = dlopen(&quot;./libshared_1.so&quot;, RTLD_NOW); if(!handle1) &#123; trace_debug(&quot;load failed! error:%s&quot;, dlerror()); exit(1); &#125; void *handle2 = dlopen(&quot;./libshared_2.so&quot;, RTLD_NOW); if(!handle2) &#123; trace_debug(&quot;load failed! error:%s&quot;, dlerror()); exit(1); &#125; //clear error info dlerror(); function_hello f1 = (function_hello) dlsym(handle1, &quot;hello&quot;); char *err = dlerror(); if(err) &#123; trace_debug(&quot;can&#x27;t find symbol fcn! %s&quot;, err); exit(1); &#125; function_hello f2 = (function_hello) dlsym(handle2, &quot;hello&quot;); err = dlerror(); if(err) &#123; trace_debug(&quot;can&#x27;t find symbol fcn! %s&quot;, err); exit(1); &#125; f1(); f2(); dlclose(handle1); dlclose(handle2); return 0;&#125; 运行输出： 12PID-TID:12984-12984|19:22:46.383|shared.c| hello| 19|D| in shared_hello static_hello addr:[0x7f2096fee6d0][12]PID-TID:12984-12984|19:22:46.383|shared2.| hello| 20|D| in shared_hello 2 static_hello addr:[0x7f2096dec6d0][13] 说明两个动态库中的全局变量并不会冲突。 TODO原理上解释原因。","categories":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"}]},{"title":"TCMALLOC 使用","slug":"c-2019-01-09-TCMALLOC-使用","date":"2022-09-03T14:47:35.224Z","updated":"2022-09-03T14:47:35.225Z","comments":true,"path":"2022/09/03/c-2019-01-09-TCMALLOC-使用/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/c-2019-01-09-TCMALLOC-%E4%BD%BF%E7%94%A8/","excerpt":"","text":"安装12345678910111213wget https://github.com/gperftools/gperftools/releases/download/gperftools-2.7/gperftools-2.7.tar.gztar zxvf gperftools-2.7.tar.gzcd gperftools-2.7./configure --disable-cpu-profiler --disable-heap-profiler --disable-heap-checker --disable-debugalloc --enable-minimalmake sudo make installsudo ln -s /usr/local/lib/libtcmalloc_minimal.so /usr/local/lib/libtcmalloc.sosudo ln -s /usr/local/lib/libtcmalloc_minimal.so.4 /usr/local/lib/libtcmalloc.so.4sudo ln -s /usr/local/lib/libtcmalloc_minimal.so.4.5.3 /usr/local/lib/libtcmalloc.so.4.5.3 使用代码不需要修改，仅需要链接相应库即可 -ltcmalloc。","categories":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"}]},{"title":"libco 代码阅读","slug":"c-2020-01-02-libco","date":"2022-09-03T14:47:35.222Z","updated":"2022-09-03T14:48:57.846Z","comments":true,"path":"2022/09/03/c-2020-01-02-libco/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/c-2020-01-02-libco/","excerpt":"","text":"目的 使用示例，函数说明 协程切换如何实现 支持哪些异步事件 一 协程相关接口1. 相关数据结构1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 协程结构体struct stCoRoutine_t&#123; stCoRoutineEnv_t *env; pfn_co_routine_t pfn; // 协程入口函数 void *arg; // 协程参数 coctx_t ctx; // 协程上下文，在协程切换时保存寄存器值 // 协程状态标记 char cStart; char cEnd; char cIsMain; char cEnableSysHook; char cIsShareStack; void *pvEnv; //char sRunStack[ 1024 * 128 ]; stStackMem_t* stack_mem; // save stack buffer while conflict on same stack_buffer; char* stack_sp; unsigned int save_size; char* save_buffer; // 协程局部变量 stCoSpec_t aSpec[1024];&#125;;// 协程运行环境，可以理解为虚拟机// 每个协程必定在一个 stCoRoutineEnv_t 中运行struct stCoRoutineEnv_t&#123; // 协程调用栈，最多 128 层 // 这个调用栈的含义是 coroutine-1 创建 coroutine-2... 最大深度 stCoRoutine_t *pCallStack[ 128 ]; int iCallStackSize; // 事件循环驱动 stCoEpoll_t *pEpoll; //for copy stack log lastco and nextco stCoRoutine_t* pending_co; stCoRoutine_t* occupy_co;&#125;;struct stCoEpoll_t&#123; int iEpollFd; static const int _EPOLL_SIZE = 1024 * 10; struct stTimeout_t *pTimeout; struct stTimeoutItemLink_t *pstTimeoutList; struct stTimeoutItemLink_t *pstActiveList; co_epoll_res *result;&#125;; 2. 执行环境协程需要运行在“执行环境”或“虚拟机”中，在使用 libco 时可以不要显示创建协程执行环境，每个线程都会有个默认执行环境“gCoEnvPerThread”。使用 libco 可以使用多线程多协程模式，每个线程与 CPU 绑定，每个线程有独立的协程执行环境。 创建执行环境时会创建一个主协程，不做任何事情，只用来与其他协程进行切换。协程中的 coctx_t 会保存协程切换时的寄存器状态，当再次切换到协程时会执行 co_swap 之后代码。这样就实现了用同步的视角实现异步逻辑。 1234567891011121314151617181920212223static __thread stCoRoutineEnv_t* gCoEnvPerThread = NULL;void co_init_curr_thread_env()&#123; gCoEnvPerThread = (stCoRoutineEnv_t*)calloc( 1, sizeof(stCoRoutineEnv_t) ); stCoRoutineEnv_t *env = gCoEnvPerThread; env-&gt;iCallStackSize = 0; // 创建主协程 struct stCoRoutine_t *self = co_create_env( env, NULL, NULL, NULL ); self-&gt;cIsMain = 1; env-&gt;pending_co = NULL; env-&gt;occupy_co = NULL; coctx_init( &amp;self-&gt;ctx ); env-&gt;pCallStack[ env-&gt;iCallStackSize++ ] = self; // epoll fd stCoEpoll_t *ev = AllocEpoll(); SetEpoll( env,ev );&#125; 3. 创建协程1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/******************************************************************************* * @param co stCoRoutine_t** 创建的协程对象，出参 * @param attr stCoRoutineAttr_t 协程属性，入参，定义栈大小、共享栈属性 * @param routine void*(*func)(void*) 协程执行函数 * @param arg void* 协程执行参数 * @return 返回值无意义 ******************************************************************************/int co_create( stCoRoutine_t **ppco,const stCoRoutineAttr_t *attr,pfn_co_routine_t pfn,void *arg )&#123; if( !co_get_curr_thread_env() ) &#123; co_init_curr_thread_env(); &#125; stCoRoutine_t *co = co_create_env( co_get_curr_thread_env(), attr, pfn,arg ); *ppco = co; return 0;&#125;/******************************************************************************* * 与 co_create 类似，附加参数 env 指定了创建协程的执行环境 * @param env stCoRoutineEnv_t* 协程执行环境 * @param co stCoRoutine_t** 创建的协程对象，出差 * @param attr stCoRoutineAttr_t 协程属性，入参，定义栈大小、共享栈属性 * @param routine void*(*func)(void*) 协程执行函数 * @param arg void* 协程执行参数 * @return 返回值无意义 ******************************************************************************/struct stCoRoutine_t *co_create_env( stCoRoutineEnv_t *env, const stCoRoutineAttr_t* attr, pfn_co_routine_t pfn, void *arg )&#123; stCoRoutineAttr_t at; if( attr ) &#123; memcpy( &amp;at,attr,sizeof(at) ); &#125; if( at.stack_size &lt;= 0 ) &#123; at.stack_size = 128 * 1024; &#125; else if( at.stack_size &gt; 1024 * 1024 * 8 ) &#123; at.stack_size = 1024 * 1024 * 8; &#125; if( at.stack_size &amp; 0xFFF ) &#123; at.stack_size &amp;= ~0xFFF; at.stack_size += 0x1000; &#125; stCoRoutine_t *lp = (stCoRoutine_t*)malloc( sizeof(stCoRoutine_t) ); memset( lp,0,(long)(sizeof(stCoRoutine_t))); lp-&gt;env = env; // 协程执行虚拟机 lp-&gt;pfn = pfn; // 执行函数 lp-&gt;arg = arg; // 执行参数 // 栈内存分配，使用共享栈内存或独立栈内存 // 如果使用共享栈内存会与多个协程共享栈内存空间 stStackMem_t* stack_mem = NULL; if( at.share_stack ) &#123; stack_mem = co_get_stackmem( at.share_stack); at.stack_size = at.share_stack-&gt;stack_size; &#125; else &#123; stack_mem = co_alloc_stackmem(at.stack_size); &#125; lp-&gt;stack_mem = stack_mem; lp-&gt;ctx.ss_sp = stack_mem-&gt;stack_buffer; lp-&gt;ctx.ss_size = at.stack_size; lp-&gt;cStart = 0; lp-&gt;cEnd = 0; lp-&gt;cIsMain = 0; lp-&gt;cEnableSysHook = 0; lp-&gt;cIsShareStack = at.share_stack != NULL; lp-&gt;save_size = 0; lp-&gt;save_buffer = NULL; return lp;&#125; 4. 启动协程使用 co_resume 可以启动协程，在 co_resume 会先创建协程执行上下文。当事件触发时，会再次切换到当前协程，此时调用 CoRoutineFunc 函数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/******************************************************************************* * 当前执行协程让出，切换到 co 协程进行运行 * @param co stCoRoutine_t 待运行协程 ******************************************************************************/void co_resume( stCoRoutine_t *co )&#123; stCoRoutineEnv_t *env = co-&gt;env; // lpCurrRoutine 是正在执行协程 stCoRoutine_t *lpCurrRoutine = env-&gt;pCallStack[ env-&gt;iCallStackSize - 1 ]; // 协程未启动 if( !co-&gt;cStart ) &#123; // 创建协程调用上下文，使用 CoRoutineFunc 函数地址作为执行栈，协程 co，0 作为 CoRoutineFunc 函数的参数。 // CoRoutineFunc 函数作为所有协程的 wrapper 函数。 // coctx_make 需要对 32 位、64 位做兼容，两种的函数调用方式是不同的。 coctx_make( &amp;co-&gt;ctx,(coctx_pfn_t)CoRoutineFunc, co, 0 ); co-&gt;cStart = 1; &#125; // 将当前协程放在执行虚拟机栈上，当前协程是执行协程 env-&gt;pCallStack[ env-&gt;iCallStackSize++ ] = co; // 协程切换，执行当前协程 co co_swap( lpCurrRoutine, co );&#125;#if defined(__i386__)int coctx_make(coctx_t* ctx, coctx_pfn_t pfn, const void* s, const void* s1) &#123; char* sp = ctx-&gt;ss_sp + ctx-&gt;ss_size - sizeof(coctx_param_t); sp = (char*)((unsigned long)sp &amp; -16L); coctx_param_t* param = (coctx_param_t*)sp; void** ret_addr = (void**)(sp - sizeof(void*) * 2); *ret_addr = (void*)pfn; // 参数在栈上 param-&gt;s1 = s; param-&gt;s2 = s1; memset(ctx-&gt;regs, 0, sizeof(ctx-&gt;regs)); // 在 32 位模式下，使用栈传递参数。pfn 函数有两个参数，栈顶需要移动两个指针长度。 ctx-&gt;regs[kESP] = (char*)(sp) - sizeof(void*) * 2; return 0;&#125;#elif defined(__x86_64__)int coctx_make(coctx_t* ctx, coctx_pfn_t pfn, const void* s, const void* s1) &#123; // 栈顶, 64 位使用寄存器传递参数，寄存器不够时才会使用栈。 // pfn 函数只有两个参数，直接使用寄存器，不会在栈上存储参数。 char* sp = ctx-&gt;ss_sp + ctx-&gt;ss_size - sizeof(void*); sp = (char*)((unsigned long)sp &amp; -16LL); // 寄存器置零 memset(ctx-&gt;regs, 0, sizeof(ctx-&gt;regs)); // 函数地址 void** ret_addr = (void**)(sp); *ret_addr = (void*)pfn; ctx-&gt;regs[kRSP] = sp; // kRETAddr 用于存储 IP 寄存器地址。 // 在 coctx_swap 调用中会将 regs[kRETAddr] 入栈，在 coctx_swap 的最后有 ret 指令，触发 pop ip，跳转到 pfn 处执行。 ctx-&gt;regs[kRETAddr] = (char*)pfn; // pfn 函数的第一个参数 ctx-&gt;regs[kRDI] = (char*)s; // pfn 函数的第二个参数 ctx-&gt;regs[kRSI] = (char*)s1; return 0;&#125;#endifstatic int CoRoutineFunc( stCoRoutine_t *co,void * )&#123; if( co-&gt;pfn ) &#123; co-&gt;pfn( co-&gt;arg ); &#125; co-&gt;cEnd = 1; stCoRoutineEnv_t *env = co-&gt;env; co_yield_env( env ); return 0;&#125; 函数 co_swap 是协程切换核心，使用汇编实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172.globl coctx_swap#if !defined( __APPLE__ ).type coctx_swap, @function#endifcoctx_swap:#if defined(__i386__) # 4(%esp) 是调用 coctx_swap 函数的第一个参数 movl 4(%esp), %eax # sp 是 ip 值，ret 指令使用 movl %esp, 28(%eax) movl %ebp, 24(%eax) movl %esi, 20(%eax) movl %edi, 16(%eax) movl %edx, 12(%eax) movl %ecx, 8(%eax) movl %ebx, 4(%eax) # 8(%esp) 是调用 coctx_swap 函数的第二个参数 movl 8(%esp), %eax movl 4(%eax), %ebx movl 8(%eax), %ecx movl 12(%eax), %edx movl 16(%eax), %edi movl 20(%eax), %esi movl 24(%eax), %ebp # 设置栈顶值，当 ret 指令调用时会触发 pop ip，恢复原先的执行 movl 28(%eax), %esp ret#elif defined(__x86_64__) # 函数调用传参，优先将参数传递给寄存器，当寄存器不够用时，会丛右到左压栈，然后再传参给寄存器。 # %rdi，%rsi，%rdx，%rcx，%r8，%r9, 这6个不够用的时候才会借用栈。 # 所以 %rdi 是第一个参数，是保存寄存器组内存的首地址。 leaq (%rsp), %rax movq %rax, 104(%rdi) movq %rbx, 96(%rdi) movq %rcx, 88(%rdi) movq %rdx, 80(%rdi) movq 0(%rax), %rax movq %rax, 72(%rdi) movq %rsi, 64(%rdi) movq %rdi, 56(%rdi) movq %rbp, 48(%rdi) movq %r8, 40(%rdi) movq %r9, 32(%rdi) movq %r12, 24(%rdi) movq %r13, 16(%rdi) movq %r14, 8(%rdi) movq %r15, (%rdi) xorq %rax, %rax movq 48(%rsi), %rbp movq 104(%rsi), %rsp movq (%rsi), %r15 movq 8(%rsi), %r14 movq 16(%rsi), %r13 movq 24(%rsi), %r12 movq 32(%rsi), %r9 movq 40(%rsi), %r8 movq 56(%rsi), %rdi movq 80(%rsi), %rdx movq 88(%rsi), %rcx movq 96(%rsi), %rbx leaq 8(%rsp), %rsp pushq 72(%rsi) // ip 入栈 movq 64(%rsi), %rsi ret#endif 5. 让出执行123456789101112131415161718/******************************************************************************* * 当前协程让出，上层调用栈协程运行 * @param co stCoRoutine_t 待让出协程 ******************************************************************************/void co_yield( stCoRoutine_t *co )&#123; co_yield_env( co-&gt;env );&#125;void co_yield_env( stCoRoutineEnv_t *env )&#123; stCoRoutine_t *last = env-&gt;pCallStack[ env-&gt;iCallStackSize - 2 ]; stCoRoutine_t *curr = env-&gt;pCallStack[ env-&gt;iCallStackSize - 1 ]; env-&gt;iCallStackSize--; co_swap( curr, last);&#125; 6. 设置/获取协程局部变量1234567891011121314151617181920void *co_getspecific(pthread_key_t key)&#123; stCoRoutine_t *co = GetCurrThreadCo(); if( !co || co-&gt;cIsMain ) &#123; return pthread_getspecific( key ); &#125; return co-&gt;aSpec[ key ].value;&#125;int co_setspecific(pthread_key_t key, const void *value)&#123; stCoRoutine_t *co = GetCurrThreadCo(); if( !co || co-&gt;cIsMain ) &#123; return pthread_setspecific( key,value ); &#125; co-&gt;aSpec[ key ].value = (void*)value; return 0;&#125; 7. 协程释放1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/******************************************************************************* * 释放协程对象 co * @param co stCoRoutine_t 待释放协程对象 ******************************************************************************/void co_release( stCoRoutine_t *co )&#123; co_free( co );&#125;void co_free( stCoRoutine_t *co )&#123; if (!co-&gt;cIsShareStack) &#123; free(co-&gt;stack_mem-&gt;stack_buffer); free(co-&gt;stack_mem); &#125; else &#123; if(co-&gt;save_buffer) free(co-&gt;save_buffer); if(co-&gt;stack_mem-&gt;occupy_co == co) co-&gt;stack_mem-&gt;occupy_co = NULL; &#125; free( co );&#125;/******************************************************************************* * @param co stCoRoutine_t 协程对象 ******************************************************************************/void co_reset(stCoRoutine_t * co)&#123; if(!co-&gt;cStart || co-&gt;cIsMain) return; co-&gt;cStart = 0; co-&gt;cEnd = 0; if(co-&gt;save_buffer) &#123; free(co-&gt;save_buffer); co-&gt;save_buffer = NULL; co-&gt;save_size = 0; &#125; // 如果共享栈被当前协程占用，要释放占用标志，否则被切换，会执行save_stack_buffer() if(co-&gt;stack_mem-&gt;occupy_co == co) co-&gt;stack_mem-&gt;occupy_co = NULL;&#125; 二 事件循环1. 等待事件触发函数 co_poll 用来同步或异步等待事件触发。当前协程希望监听某一事件时，向协程执行环境的事件循环实例注册事件监听、超时监听，同时进行协程切换。当事件触发时会切换到当前协程的协程切换点执行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151/******************************************************************************* * 向 event_fd 添加监控事件，之所以使用 fds 数组是为了与 poll 函数兼容。 * 虽然参数格式是数组，但是每次调用都添加一个文件描述符，如果使用多个文件描述符会共享同一个超时时间。 * @param ctx stCoEpoll_t 协程对象 * @param fds struct pollfd 待添加文件描述符 * @param nfds nfds_t 待添加事件数量 * @param timeout_ms int 事件超时时间 ******************************************************************************/int co_poll( stCoEpoll_t *ctx,struct pollfd fds[], nfds_t nfds, int timeout_ms )&#123; return co_poll_inner(ctx, fds, nfds, timeout_ms, NULL);&#125;typedef int (*poll_pfn_t)(struct pollfd fds[], nfds_t nfds, int timeout);int co_poll_inner( stCoEpoll_t *ctx,struct pollfd fds[], nfds_t nfds, int timeout, poll_pfn_t pollfunc)&#123; if (timeout == 0) &#123; return pollfunc(fds, nfds, timeout); &#125; if (timeout &lt; 0) &#123; timeout = INT_MAX; &#125; int epfd = ctx-&gt;iEpollFd; // co_self 获取当前正在执行协程 stCoRoutine_t* self = co_self(); // 1.struct change stPoll_t&amp; arg = *((stPoll_t*)malloc(sizeof(stPoll_t))); memset( &amp;arg, 0, sizeof(arg) ); arg.iEpollFd = epfd; arg.fds = (pollfd*)calloc(nfds, sizeof(pollfd)); arg.nfds = nfds; stPollItem_t arr[2]; if( nfds &lt; sizeof(arr) / sizeof(arr[0]) &amp;&amp; !self-&gt;cIsShareStack) &#123; arg.pPollItems = arr; &#125; else &#123; arg.pPollItems = (stPollItem_t*)malloc( nfds * sizeof( stPollItem_t ) ); &#125; memset( arg.pPollItems, 0, nfds * sizeof(stPollItem_t) ); arg.pfnProcess = OnPollProcessEvent; arg.pArg = GetCurrCo( co_get_curr_thread_env() ); // 2. 增加监听事件 for(nfds_t i=0;i&lt;nfds;i++) &#123; arg.pPollItems[i].pSelf = arg.fds + i; arg.pPollItems[i].pPoll = &amp;arg; arg.pPollItems[i].pfnPrepare = OnPollPreparePfn; struct epoll_event &amp;ev = arg.pPollItems[i].stEvent; if( fds[i].fd &gt; -1 ) &#123; ev.data.ptr = arg.pPollItems + i; ev.events = PollEvent2Epoll( fds[i].events ); int ret = co_epoll_ctl( epfd,EPOLL_CTL_ADD, fds[i].fd, &amp;ev ); if (ret &lt; 0 &amp;&amp; errno == EPERM &amp;&amp; nfds == 1 &amp;&amp; pollfunc != NULL) &#123; if( arg.pPollItems != arr ) &#123; free( arg.pPollItems ); arg.pPollItems = NULL; &#125; free(arg.fds); free(&amp;arg); return pollfunc(fds, nfds, timeout); &#125; &#125; &#125; // 3. 增加超时事件 unsigned long long now = GetTickMS(); arg.ullExpireTime = now + timeout; int ret = AddTimeout( ctx-&gt;pTimeout, &amp;arg,now ); int iRaiseCnt = 0; if( ret != 0 ) &#123; co_log_err(&quot;CO_ERR: AddTimeout ret %d now %lld timeout %d arg.ullExpireTime %lld&quot;, ret,now,timeout,arg.ullExpireTime); errno = EINVAL; iRaiseCnt = -1; &#125; else &#123; // 协程切换 co_yield_env( co_get_curr_thread_env() ); iRaiseCnt = arg.iRaiseCnt; &#125; &#123; // 移除超时事件 RemoveFromLink&lt;stTimeoutItem_t,stTimeoutItemLink_t&gt;( &amp;arg ); // 移除监听事件 for(nfds_t i = 0;i &lt; nfds;i++) &#123; int fd = fds[i].fd; if( fd &gt; -1 ) &#123; co_epoll_ctl( epfd,EPOLL_CTL_DEL,fd,&amp;arg.pPollItems[i].stEvent ); &#125; fds[i].revents = arg.fds[i].revents; &#125; if( arg.pPollItems != arr ) &#123; free( arg.pPollItems ); arg.pPollItems = NULL; &#125; free(arg.fds); free(&amp;arg); &#125; return iRaiseCnt;&#125;void OnPollProcessEvent( stTimeoutItem_t * ap )&#123; stCoRoutine_t *co = (stCoRoutine_t*)ap-&gt;pArg; co_resume( co );&#125;void OnPollPreparePfn( stTimeoutItem_t * ap,struct epoll_event &amp;e,stTimeoutItemLink_t *active )&#123; stPollItem_t *lp = (stPollItem_t *)ap; // 触发的事件 lp-&gt;pSelf-&gt;revents = EpollEvent2Poll( e.events ); stPoll_t *pPoll = lp-&gt;pPoll; pPoll-&gt;iRaiseCnt++; // 有一个事件触发后就会加入活跃事件队列，iAllEventDetach 成员用于避免加入多次 // 此处业务使用 co_poll 时应该添加对一个事件的监听，而非增加多个事件原因，导致了代码逻辑混乱 if( !pPoll-&gt;iAllEventDetach ) &#123; pPoll-&gt;iAllEventDetach = 1; RemoveFromLink&lt;stTimeoutItem_t,stTimeoutItemLink_t&gt;( pPoll ); AddTail( active,pPoll ); &#125;&#125; 2. 主协程事件循环主协程事件循环处理用于协程调度，其核心是使用 epoll_wait 等待事件（异步事件、超时事件）触发，执行事件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/******************************************************************************* * 主协程事件处理循环 * @param ctx stCoEpoll_t 协程对象 * @param pfn pfn_co_eventloop_t 退出检查函数 * @param arg void* 退出检查函数参数 ******************************************************************************/void co_eventloop( stCoEpoll_t *ctx, pfn_co_eventloop_t pfn, void *arg )&#123; if( !ctx-&gt;result ) &#123; ctx-&gt;result = co_epoll_res_alloc( stCoEpoll_t::_EPOLL_SIZE ); &#125; co_epoll_res *result = ctx-&gt;result; for(;;) &#123; int ret = co_epoll_wait( ctx-&gt;iEpollFd, result,stCoEpoll_t::_EPOLL_SIZE, 1 ); stTimeoutItemLink_t *active = (ctx-&gt;pstActiveList); stTimeoutItemLink_t *timeout = (ctx-&gt;pstTimeoutList); memset( timeout,0,sizeof(stTimeoutItemLink_t) ); // 触发事件队列 for(int i=0; i&lt;ret; i++) &#123; stTimeoutItem_t *item = (stTimeoutItem_t*)result-&gt;events[i].data.ptr; if( item-&gt;pfnPrepare ) &#123; item-&gt;pfnPrepare( item, result-&gt;events[i], active ); &#125; else &#123; AddTail( active, item ); &#125; &#125; // 超时事件队列 unsigned long long now = GetTickMS(); TakeAllTimeout( ctx-&gt;pTimeout, now, timeout ); stTimeoutItem_t *lp = timeout-&gt;head; while( lp ) &#123; //printf(&quot;raise timeout %p\\n&quot;,lp); lp-&gt;bTimeout = true; lp = lp-&gt;pNext; &#125; // 将超时事件队列添加到触发事件队列之后 Join&lt;stTimeoutItem_t,stTimeoutItemLink_t&gt;( active,timeout ); // 处理所有事件 lp = active-&gt;head; while( lp ) &#123; // 从队列移除事件 PopHead&lt;stTimeoutItem_t,stTimeoutItemLink_t&gt;( active ); if (lp-&gt;bTimeout &amp;&amp; now &lt; lp-&gt;ullExpireTime) &#123; int ret = AddTimeout(ctx-&gt;pTimeout, lp, now); if (!ret) &#123; lp-&gt;bTimeout = false; lp = active-&gt;head; continue; &#125; &#125; // 执行事件处理函数 if( lp-&gt;pfnProcess ) &#123; lp-&gt;pfnProcess( lp ); &#125; lp = active-&gt;head; &#125; // 事件循环退出检查函数 if( pfn ) &#123; if( -1 == pfn( arg ) ) &#123; break; &#125; &#125; &#125;&#125; 3. 系统调用 hookco_enable_hook_sys 函数用于在阻塞的系统调用时进行协程切换。当开启时，在 read、send 等系统调用点会调用 co_poll 触发协程切换。 1234567/******************************************************************************* * 开启、关闭系统函数 hook * 当开启系统函数 hook 时会调用 poll 函数触发协程切换。当事件触发时，协程切换回来，继续执行。 ******************************************************************************/void co_enable_hook_sys();void co_disable_hook_sys();bool co_is_enable_sys_hook(); 在 co_hook_sys_call.cpp 中实现了系统 hook 功能，libco 中定义了 read、send 等函数。以 read 为例说明： 12345678910111213141516171819ssize_t read( int fd, void *buf, size_t nbyte )&#123; HOOK_SYS_FUNC( read ); if( !co_is_enable_sys_hook() ) &#123; return g_sys_read_func( fd,buf,nbyte ); &#125; ... // 忽略无关代码 int pollret = poll( &amp;pf,1,timeout ); ssize_t readret = g_sys_read_func( fd,(char*)buf ,nbyte ); if( readret &lt; 0 ) &#123; co_log_err(&quot;CO_ERR: read fd %d ret %ld errno %d poll ret %d timeout %d&quot;, fd,readret,errno,pollret,timeout); &#125; return readret;&#125; HOOK_SYS_FUNC 是宏定义，用生成 g_sys_xxx_func 变量，其值指向系统调用的地址。 1#define HOOK_SYS_FUNC(name) if( !g_sys_##name##_func ) &#123; g_sys_##name##_func = (name##_pfn_t)dlsym(RTLD_NEXT,#name); &#125; 4. libco 协程使用读 co_poll、co_eventloop 代码会思考该怎样使用 libco 进行事件处理。如果没有协程，异步事件处理应该是：一进程或线程添加事件监听，二进行 epoll_wait 等待事件触发，三处理事件。以 CS 模式为例，在 libco 中应该对 listenfd 创建一个协程、每个 accept 的连接创建一个协程，并将其添加到主协程事件循环中。 三 协程同步libco 提供了条件变量原语，因为在 libco 中是主动调度，非抢占式调度，因此不必担心竞争状态，实现起来也比较简单。 123456789101112131415161718192021222324252627282930313233343536373839404142434445typedef void (*OnPreparePfn_t)( stTimeoutItem_t *,struct epoll_event &amp;ev, stTimeoutItemLink_t *active );typedef void (*OnProcessPfn_t)( stTimeoutItem_t *);struct stTimeoutItem_t&#123; enum &#123; eMaxTimeout = 40 * 1000 //40s &#125;; stTimeoutItem_t *pPrev; stTimeoutItem_t *pNext; stTimeoutItemLink_t *pLink; unsigned long long ullExpireTime; OnPreparePfn_t pfnPrepare; OnProcessPfn_t pfnProcess; void *pArg; // routine bool bTimeout;&#125;;struct stCoCondItem_t &#123; stCoCondItem_t *pPrev; stCoCondItem_t *pNext; stCoCond_t *pLink; stTimeoutItem_t timeout;&#125;;struct stCoCond_t&#123; stCoCondItem_t *head; stCoCondItem_t *tail;&#125;;stCoCond_t *co_cond_alloc();int co_cond_free( stCoCond_t * cc );/******************************************************************************* * 协程条件变量，用于协程之间的同步 ******************************************************************************/int co_cond_signal( stCoCond_t * );int co_cond_broadcast( stCoCond_t * );int co_cond_timedwait( stCoCond_t *,int timeout_ms ); 参考资料 libco libaco libco 分享 指令参考 函数调用约定 x86 传参规则","categories":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"asm","slug":"asm","permalink":"https://juzipeek.github.io/tags/asm/"},{"name":"coroutine","slug":"coroutine","permalink":"https://juzipeek.github.io/tags/coroutine/"}]},{"title":"","slug":"nginx-2022-03-13-openresty-api-balancer","date":"2022-09-03T12:55:44.524Z","updated":"2022-09-03T12:55:44.525Z","comments":true,"path":"2022/09/03/nginx-2022-03-13-openresty-api-balancer/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/nginx-2022-03-13-openresty-api-balancer/","excerpt":"","text":"uuid: 4ca50c14-d539-a1db-cfc1-a5b944a803cduuid: d168aca9-e44f-5b33-4420-016043af65acuuid: 7e7ee869-999a-fb45-32e1-2f26c6fb0a85uuid: bff2f21b-a963-870a-e96a-22d1ce49e886uuid: 101f74be-7ed4-def5-5858-b32b4cdbbae1uuid: 20a34af8-78e5-c0bf-0410-60722d08d9fduuid: 37726b68-660f-253f-51aa-66ba62900130uuid: 7408be4c-01a9-80d2-eadc-acc1a54195b5uuid: 2a380086-becc-e876-64bc-e31daa3d874euuid: 19a0e13f-9129-a997-3fd7-7b0594f33aa9uuid: f611fb34-49c9-6373-b4ab-e6704a8e99feuuid: b7f353fd-d4ea-a725-09af-d18fd5642177uuid: 784d9eb3-1414-5d76-fa87-39c10465f04cuuid: b246af5d-f6bd-580e-260d-bc13de326747uuid: f80d5912-4e2f-8908-984a-b986f6939966uuid: 9326a75d-7faa-a71a-ccd8-2f99c21134eduuid: 94ba64c6-7714-3a73-8857-356753a080b6uuid: 39c3ef1a-e17a-ac43-a0cd-88d6a5d15d39uuid: dca8ed1d-c368-7203-e4e8-9386621edac3uuid: b6e5c7b2-6fa7-5b37-ea6f-cf10c16b912cuuid: 772f4bc5-63d6-7a11-2a13-4587a1712efauuid: 174b4293-51e5-8265-63ad-dc90d0368714uuid: 0de0f182-3a64-1ee9-bd92-dae1f38ce9ceuuid: a092809f-904d-2cd4-db14-23397c51eb62uuid: d5350404-faf6-1827-54d5-e0761fa31e7duuid: 8d5af835-c314-ad81-586e-c68a40f1dd6duuid: eec46ddf-f3f0-eb80-f2f4-d1a6d734ea7buuid: ea59e22a-9954-d36c-3ef6-d4fe0fd303dfuuid: eab53dfa-5391-b0d7-662b-9d3dfc106ffauuid: 8fd2b7ff-1d01-f240-56ef-9065fd38bc88uuid: 7470cb7a-bd45-4646-58c7-0a7926d1b8abuuid: fb35e5cb-9e6e-c2b4-e98a-9a3e775a80b0uuid: d3f49aef-9cba-8bdb-46bd-8ccb281a5503uuid: 2af2a3e0-6df7-9495-449f-5a8ca2bab1d8uuid: 251862b6-f446-3728-0a9c-ab38832bf8ccuuid: b95c9d57-c92a-895b-a6ce-0dee0ffe649auuid: fdad792a-b4c1-7528-6838-d7809ecf1c9cuuid: ee665078-7436-2699-e244-c74a82603499uuid: 67687ad6-9ccf-ca61-a7c6-54384e9ab332uuid: acdbe79e-53bd-df37-9c85-3a62a4a5ef51uuid: 493d82d5-2791-4698-26f2-002ea97f9b71uuid: 9a5b0d35-33c0-ca0a-695a-ea6fbc0455deuuid: 80d32a75-29bd-7b33-067d-1c343d73037duuid: 6b0b2679-55b2-bab5-676e-1d8e604b4c4auuid: 6e28db61-9531-137c-ce7a-408557e10f14uuid: 20141cd1-c320-a72f-6d2a-4ea8c0eb2b20uuid: 57efcf0a-4343-5c2d-b33b-41bdcc555081uuid: 434d951d-7ac6-627b-98eb-59d6dcf37278uuid: f3df5a5b-6987-1508-d347-41e75772dde4uuid: a5709539-0bfe-24bc-26da-e2a8e15b65bauuid: 241a2de8-2f4a-6480-93f4-8b558a1e7208uuid: 0c4ae970-1f19-c911-84e6-0ca77600ac03uuid: bfd25be0-5318-d8da-4a50-92d56f72008duuid: 81f75063-8dc1-e57a-1f26-8991a794eb08uuid: 1e5f3cd5-1009-38dd-a243-f592127e42f2uuid: 2bc72d96-8127-4eda-7147-27a2624b62a8uuid: bb04188c-d5f1-c890-d468-c266989ee24euuid: 9eb876c2-b6ca-834c-ec17-3ccc6073f427uuid: e394cfb5-820f-6df5-22e8-f967a8e72d91uuid: 695294e3-10bc-a3a1-9416-0df6b2caffb9uuid: 19b364ca-7668-eb50-d2db-dd48b9cef1e1uuid: f08ebca7-44b3-7313-beac-92e1c28cee4euuid: 20243493-b48f-f59f-a832-dd5ad1ec9ac2uuid: 51a6ecf3-865f-90aa-084e-9285d19916c3uuid: 3f5b2c62-6562-8c5b-c097-550368812d0duuid: dd30ab99-019a-1ff3-ddb1-cccab2d50642uuid: e0d594c3-ec11-e0b0-f651-5df7e5f742b8uuid: 8c96ee58-98be-91cd-2a43-3f051ff6e3d2uuid: b6ae70a0-44d7-d8e8-c634-b3da7a969a84uuid: f0dac76e-f898-9222-fbf2-b4f50fb31ff5uuid: 2d159d19-f79b-a811-a21d-782146a95cd5uuid: 2e7e6180-7320-e0c6-e9ba-3a3c0ed5b6a9uuid: 6a07eed3-a62e-eb51-32b8-ce07ad2c6df4uuid: c04a311d-2de5-6aa8-0db5-eab18b1edbbeuuid: 0a5830f4-351a-9180-9b3b-a7e821b0b973uuid: dc6b9065-61aa-cae6-74f8-d0cc18a3856euuid: 25b86566-c9df-796c-0159-c1244f881e6euuid: 9122f377-187c-85ac-e5c2-78a2d51e3d53uuid: 5be1d62e-da28-dd5c-2b43-b08fce87ff85uuid: afd1775a-f422-38ad-f5ea-9c2bb3d6f02auuid: f3b6fe0c-2291-5543-c2a9-69848d7d20e0uuid: 5cf43b52-55df-4e6e-8d41-eb90a2f5806duuid: e53a80bb-4865-2853-9e23-5d046613dae3uuid: 6a7730f2-92c2-51a8-ca89-a1c7c2c39b87uuid: f85d4f5b-3cbf-1705-ecbc-6ace7a101545uuid: 46e153e8-ef42-dd2b-b41a-ef38f70ffa41uuid: dbfc55e8-1ad0-e0cb-995d-8f86c16bc8cauuid: 0faa34d4-84a5-69da-d0f7-4092a98a3f87uuid: c70a4616-18f5-170d-3b7e-25801a02ef75uuid: ae3a21f6-6af5-616c-6d55-6dd4f957261auuid: b5b585c5-cc45-2d64-9f2f-4747cea0b7cauuid: 607f8cb8-054e-9d17-3ea9-ff702d09c4e2uuid: c92b15b8-fa58-5e13-3ce2-37ec67cb593buuid: 74d62ed2-bf78-4134-98d7-2240dac4cb52uuid: 4260bf4f-944a-9395-691a-69c3f49e6807uuid: adb171d7-9126-3735-8320-5aea4e1ba4f2uuid: 1ecf2fe9-207d-19d4-d889-9acb638beb72uuid: 013b91c5-0cb2-8494-a16d-98ce1f4bab70uuid: 68adfb84-6490-672e-fc18-cbb5f1328ccauuid: b8eb060e-670c-bd34-44ee-aabb63477cfduuid: 249f3313-f4d6-3b24-6e9f-12c38f05f7bfuuid: 561c8451-895b-1c82-7b98-4c89b6280105uuid: 1679a27f-ba71-3bbe-aba4-45bcc430527duuid: 476ce994-6f8e-84ee-af49-0204874ab084uuid: ac02232e-ea0d-f0d8-b3c9-b421edcace37uuid: 3fc44381-9400-90d9-d8f7-4d26112dedcduuid: 0845bfcd-0926-479b-0dea-0b9623c3dad2uuid: 1d7d4991-4d65-ac7c-22cb-3cc78695f7e4uuid: e262df04-1da8-5edd-cce5-a548bc474580uuid: 8c46a672-e5a5-7297-54a9-774f985e50cduuid: 2471b32a-5a0b-240b-8928-b6665025a803uuid: 9a5defa9-5c7a-0a35-ccf9-0e444ee6f64fuuid: df0f393b-094b-3ec0-d61f-7dc50819cf5duuid: 86ade9de-eb7f-e025-06cd-4eec03269484uuid: 6d8ac6de-d4e3-b7ec-b53a-74d5fda39c6fuuid: 56fa07bc-239f-e354-b7f9-a3fabfea17cauuid: 7126dcb9-6f76-34f7-f9fe-0cdcb34ae757uuid: 12dde800-c9c4-faa6-a6c7-d7dc5ec372b2uuid: 548d1a1e-b2ee-3384-7e64-09c76dc80979uuid: c0da93f9-fc29-2d47-6e2d-f573ed02816duuid: d8a5a317-6045-f577-2875-5da86cefb488uuid: a2544549-c420-8226-c4a1-521a1ea44f33uuid: bbff2349-8041-ec5a-f3ec-2773de6a43efuuid: 87850f02-d5db-10e9-8760-652ef1af95a1uuid: 06accfca-b540-b2b4-9fca-fa5d22a956aauuid: c15869b7-23ba-1127-961d-d906195228a8uuid: fc0023b0-568e-8341-bf10-10ba2ade7405uuid: dbe7b429-73b4-8043-c98f-76e1b5a485f6uuid: f33bd0fe-daa9-f1d7-0906-7b80f61b19eeuuid: 592ca1e9-683a-2e68-c174-91f00b29efa0uuid: 9060a9a8-7702-f688-e67a-52a5b9bb485fuuid: 2d585edc-e2e6-95df-fda6-87c9cb2ac2c3uuid: 9122ae5e-396e-2c59-41f3-610c0c838379uuid: f94b3f86-0984-c0df-d120-d7177d7667d7uuid: d6b6b4a7-239a-2b22-32c4-8e1a7899060buuid: fc98f050-9fb2-e118-1a7d-c3cccb83100duuid: 78ea3c54-c44e-3b09-3d12-2e39fec4ddcduuid: d3fb922f-2d37-6e93-0cf1-eb2e2d609c6cuuid: 4b29bcd9-3d69-c0f9-72bd-4a44f38456f4uuid: dcc72d16-096a-6d2f-30cc-e2af3b9ff36duuid: 96a80e93-3dab-6a73-0216-8b71bab9fb0buuid: 0d44c31b-0f61-25c5-85cc-52b39e9fc1dbuuid: 1f0c2e13-ed17-acc7-d52b-752fa0aea5e3uuid: 88db25b1-c3fc-26b1-b12d-b46f26efbbbeuuid: 5b43ea06-c81e-14d4-3e8d-f8c51cd1aaf6uuid: b49bb43b-e213-e3a7-edd4-b51c99dbb152uuid: 457a3a28-8718-eff1-7276-b694d1a85dfduuid: 01285d29-1430-53c7-b093-36310efb8e61uuid: 5efd3c19-0fbf-f6ec-b7a5-1513e1c055dfuuid: 6ff3dd9c-48e3-150b-721c-d013ad18314auuid: d9d9c0a7-49ea-ebe7-be2a-5d553e422d1buuid: c7c931b9-d21c-1c12-cd6a-d7f12745f7d1uuid: 25b00b9c-4b81-8b50-2855-ead08416ee17uuid: b5e17710-b784-aa47-9d70-128554c65f10uuid: 1119f19a-75c7-7f07-b121-cd431c865c90uuid: a0a6d22e-813d-3219-f560-50bc178b52f4uuid: 674bb12f-3690-3f94-e0e5-dd5bdc6590c7uuid: 3784f94c-343f-b4a3-b7a8-0b762e1f7327uuid: 38daecb8-e46b-43e4-90f6-2c7fea2c15f2uuid: a5899c63-51ca-a8c9-649b-1c82bc4fa8a3uuid: 21542822-f61f-c76a-e3b3-4041c44e4780uuid: a0da5d39-c0ff-1ca9-c89e-c11bd4229c58uuid: 32271f12-d76d-c689-7dad-c86633f41799uuid: 2ba9825d-9c46-abf3-f591-e4bb0e03b60fuuid: a9ac1fb1-108b-01bd-b537-1faff794adbeuuid: bd817409-a212-9cc7-5776-04201fe99362uuid: 79fc45ff-eb3f-4561-9a08-e7408507e850uuid: 482f35ba-7125-3835-9617-943ff80ecf31uuid: f2692524-6896-333b-9e9f-a49a1f33c609uuid: adb2bcb6-fdef-2010-33d1-93fd93d9f029uuid: 559efaaa-082d-52ea-b442-a3d482e0d3d3uuid: 939cc2ca-859e-8d3e-2f5d-24277bbd26f5uuid: 4a7d49ac-ec2b-4521-6d77-cea53c15d5efuuid: 1b424f19-be46-1a54-6248-fba8471485d9uuid: 5c3115f5-8ecd-4db3-c6a0-f9e7c37deb8euuid: 77a2e009-7a05-f02b-f03d-6c8b1c53400euuid: c2101c11-6010-ff9c-c0cb-3d25166f371cuuid: d8b7f54a-bb52-f733-57d1-1006195e2975uuid: 99fd4331-61b5-eb1a-e3af-e749066711f9uuid: 12e27182-5a8e-ba37-2160-64681abfbfc4uuid: 254ff8e7-a3ce-4d57-24b5-376ff5009a82uuid: 7d401fd4-7923-241d-587b-74a75932b208uuid: e12de11a-da86-642d-4a4a-7d1bc154c362uuid: 02bbc95f-f620-a1b1-4bbd-6320bc4f2d0cuuid: 5ceaec70-a92b-e817-36e3-abee346a61f6uuid: 3b19c184-75d3-15f7-74f7-a378ea6e53e5uuid: 08e7bd66-7cf5-371d-43ff-72a8fb9b7e69uuid: d4efa096-a309-53b0-71cc-18b7e9d1f56euuid: 4cfd9566-a397-fe90-b342-98f6be11b097uuid: 5db03a52-5a9c-34b1-6c7d-339624edfdaduuid: 0580cfc8-0ad6-d4ab-e1e7-a4ca4668f44duuid: 7c1e65b9-e241-6588-2fd6-b2d7ab42a94auuid: 0902d5b2-bec0-e382-442c-0fd2a214781fuuid: 968f528b-124b-7879-87b8-9e7077d31565uuid: 14f4f56b-9e3f-eaeb-d61e-17fffdd41136uuid: 1fcfc4d5-3a3c-ac14-7a2f-c2fe74cd4f38uuid: d455addd-43bd-590f-6fd9-eef4a9593546uuid: 66541db7-9be7-6bfd-4f22-89b67a704aa3uuid: 881b40e4-5330-874a-9f5e-f7c5d2c217beuuid: c300de62-9fcb-d487-9bb9-50c608c7a65duuid: e5153394-83ac-2692-62f2-197f1a344047uuid: 029c99df-64b8-dfb2-0fe5-d1fa43068f61uuid: a95e5cf7-e7ea-e30f-99f3-01d885b733bduuid: b290ca1a-cf20-aa44-49f0-3bc65e5d3726uuid: 018bf2fd-eef7-0634-6471-3ac7f29aefd7uuid: b6b45a67-56e1-5f87-289f-0911ddae84c8uuid: a6b28c32-8886-f9c1-fdb2-d2ee74e8a25cuuid: 4643b324-bfbf-af96-77b4-ffafabb3bd97uuid: b1f0d085-6782-b231-9384-36e3cfce6b27uuid: 7fafe6a0-5359-d8b5-76ad-4b2829db1ef6uuid: 38786125-faf3-f05b-cfd3-d14622e2ec28uuid: 27fcd429-49df-d2b4-1d44-f8545792c748uuid: bc3295dd-ed3d-87bc-6a36-6b5a3a61050fuuid: 49e54bbc-672a-9215-44e6-e1f4d314619cuuid: c6844b13-b3d7-dfe7-fe51-aacfaf4f3687uuid: 5558d953-70c6-3299-0ded-6efa642e7e1fuuid: fe6e0b50-c777-b37f-74e9-27664cdfeaa0uuid: 42026ac3-9f46-b561-2ac7-92b1b32a0034uuid: b334f036-398f-7c8f-f078-7415bbef7b2euuid: f6114128-8706-7462-112f-ec8d21e79325uuid: 4022cbae-f13e-ed21-a7d3-035f14243ee2uuid: beb69aeb-fc85-39d1-418c-a4a8557baf1euuid: 81372278-b567-fae5-db9f-24adb2fad404uuid: fb2e9dc3-62c9-1fe9-5da8-e5df071a17ceuuid: c853f3ec-90c6-eecc-35a1-ccb7f1e2ddd7uuid: ba1abd55-b408-73ae-ccec-f6cbc54c77b7uuid: b8f04543-dd79-55e6-c14d-40af63aa1c56uuid: 8e1d00c8-e334-4dc7-7f07-8164d093d1a7uuid: 661d63e0-fed6-2faa-009c-b18d0661e6ecuuid: 13e4d2bc-c87c-9422-227b-d78735d302ceuuid: 92d70423-8702-adc7-46df-e086aa29ca27uuid: dc4d461d-9418-e35b-db2d-af0fbe4c605duuid: 19625741-8d11-1f0d-ab1b-256ff969a6e8uuid: 7c522231-994c-164b-c8cc-d09e5b69e6d2uuid: 4895b21e-f63c-c1ec-8c73-d6b392774dbauuid: a3afaab7-a0bf-7b2e-b00f-8263aa3a54b4uuid: 0ebab681-214a-dcb3-4203-3ae366bdc125uuid: 82bb5b63-ad62-75fd-6b49-b8193593a7d2uuid: 798add48-6b7d-dd8e-9636-1d9ffa0bef34uuid: 612870f9-7ccd-5117-ddd5-83cecae62890uuid: 37c35a36-32ee-6785-64df-df985dbd8236uuid: cd6853e0-1eb7-4e67-c924-33dba6c37fc8uuid: 02bb7532-7267-0481-ee9e-e54a959e915euuid: 3f7a5242-1339-51a1-33b4-990264dc52e3uuid: 723ec666-046f-ae69-dd5f-a746df4f23e7uuid: 73d4c6a6-9227-8b0b-b17d-89fc8f058983uuid: 7db56972-0fd4-0d98-6d8e-107b3d1ff723uuid: 25ff3978-e1a2-429a-a9ef-83f28df5e9cbuuid: 0d2a21c1-be45-1b73-4440-780bffb1522euuid: f9d624a8-c3b1-dcd1-b330-ebbed2ead75duuid: 4dd6ab50-bb3e-3c8c-ceaf-a8846bd6ae2auuid: ed529165-c363-fe6c-ca49-b3832bce7959uuid: c352b191-acf6-15f0-2600-b3635874b9bduuid: 18830a2f-1525-dbad-a7c1-6bdc854d6149uuid: 14d4c02b-3c89-ad5d-dcd1-823c3ad19568uuid: e071a84b-d74e-4b63-1e03-9991c83c12bduuid: d4600f6e-f695-01fa-bbe4-2f57b7b52785uuid: edab36e1-ce84-885e-0806-cef06d298a11uuid: b770a7e4-2410-d92b-15aa-74a6ff01a87duuid: cbc93487-9c72-d3de-4b13-3f9cd55547d2uuid: 74fbd3b6-2b8c-c814-acce-c620951c65b4uuid: ca2b2fd9-de43-b8bf-8be4-c6cee19630a8uuid: c90e4f0e-2159-aaa6-093c-1aeaee4651aauuid: 267274d0-f711-4b33-253b-b1689204b5a7uuid: bf38ba7e-e02b-f141-1c03-7b72eb83e2f8uuid: d71ba59a-ddf3-3952-aabb-b367c8c9115cuuid: 0aa2e3ae-3f2d-e13a-c884-d6d530e23c60uuid: 49190f10-2976-2d9c-c2ce-8f76b5a78b32uuid: 4b8aeb3c-9a54-a626-ed7a-b3a3f4543218uuid: e9390e23-1317-0fdc-56ed-9b5eb0efe1a5uuid: a2a1d694-efd5-27e4-33ed-ae5924505f1auuid: d72e85fc-6e24-1c2c-e8c0-5793bec6d495uuid: 82f0b9d6-4913-a80c-c138-46a31e3aa16fuuid: fb0bf6e3-dc45-2de0-aef3-dabf0b06c892uuid: 6216ef8d-f0c0-8317-94bb-d76a32851ffeuuid: 932a6704-a0ec-1a17-0e35-cde1c95ad48euuid: 63ab5153-0635-4acb-48f4-d5e5d1b9e477uuid: ac3d5a34-1d28-944b-2128-322ac984235auuid: b5febf3f-6674-709a-b73f-a40860739262uuid: 7a4e2c48-192e-2f4f-4efc-9b221b022045uuid: 4e313bc7-4f9f-49f1-d10d-9402302afbb6uuid: 43645e0b-1901-68ad-fb0d-bc1ba5e2c8a0uuid: 9d011734-3884-eb00-1908-71cfab63e9a1uuid: 28859b92-8558-7262-deaf-106bd299652cuuid: eca6aebb-70c0-c6a9-89e9-7162ab1a21f8uuid: e2d45bef-babc-e5e5-703c-c60627264497uuid: 3379c0f2-9c5d-12d7-6987-74fe6ae7b8ebuuid: c0318e13-4da7-7187-407d-d5dab11f7d61uuid: e7b5b8de-3e6c-a7a1-9cfd-5da7a7ac536auuid: 37f5c107-d695-173c-5261-b2e6bde89552uuid: a8ff44f2-cbd0-1703-fbfd-a0126935a15fuuid: 9d7e43f2-690d-631b-d9ce-0ad6cad8a1a4uuid: ca441211-4c6e-e71b-39fb-bcf0799abd8buuid: 68bf7ce8-d6d3-ca17-e817-137e8d34e1f4uuid: 48120e70-f8e1-c837-6472-1def83996378uuid: 20754a26-18f1-6c43-0d10-c929bbba1d07uuid: ff80b84d-2aee-0553-32bc-c24da8db0a56uuid: da47d9db-77a8-0bee-e3aa-89f53a4d8fd6uuid: ebf08cfd-5f4a-7d41-aac6-d8db5126b778uuid: 65ae39a5-66ad-bdee-8bbc-285602448ad0uuid: af899cd6-79c0-6c77-9d51-ec1a4934b9eauuid: 0fe05dcc-9d33-1cfb-75d4-a8e971414b38uuid: 76b04e4b-4a11-49e7-41fc-d7e9a10cd8ecuuid: e68ee7ca-3782-7c0e-9222-1e2ff323fa90uuid: 5943e357-2fbc-3f8e-3eb7-f04c25e30c71uuid: e1e97a2f-51f8-f60c-cdca-62236aff9c2fuuid: 7526e569-a0f5-a95e-b209-107be1059427uuid: a6d78682-6828-fcf8-c066-8bfbf5a55a59uuid: 67f36b77-cf5d-2a22-0e11-223ff198227duuid: af9fb3a0-2989-1248-a7fc-588b4c8a4743uuid: bef37b37-70c3-5f0b-fae2-6e18ef00625buuid: 2348a689-4e62-32c3-331e-699efa117fb5uuid: 46353376-1835-5125-1def-ac4c59c73442uuid: 193a114e-21b9-eece-086a-e871db222830uuid: 2d11d1e3-5046-1034-4525-6b10ad279c65uuid: 359768dd-beb6-c5a7-5da3-de2c6f8344d9uuid: a2dca75b-fd06-e9ee-f375-ef526ac9a065uuid: 0dd27948-9f52-b3f9-e2b6-15c438d58babuuid: 9456c3a4-4230-7ea0-9d18-bd9f4b6b0415uuid: 4545b80a-04b2-e896-f10e-d585cfed96abuuid: e61f0c49-f780-1d9f-a9a3-0bd9eec1cdebuuid: b99a5cc6-6e05-911b-f367-56239d83da59uuid: f23e9c25-496d-561c-4795-350af52aae68uuid: b4422a6c-3ae0-27e4-2116-a0af0a9729b3uuid: d4bb746e-29c7-8b3a-4d8d-2eff367a26dauuid: f463b369-7e91-aa8f-50f7-3a981a2f66ebuuid: 5032e907-cbfa-2d6a-b88c-6277f6a8ac15uuid: 6c5575ea-5df9-ae07-4633-2d631b77ae04uuid: 8780d5d9-5db9-d545-5855-255986018a9auuid: ed2e4d4f-28fe-bbe8-80b7-967fb22bc316uuid: 99d038a0-898d-fc82-9897-8d684dd0afc4uuid: fce8354f-ee2a-dfba-c77a-2116fe2e3606uuid: bbbb9813-3c85-ec9d-5ea0-dbcd1bf46fa6uuid: c008a6ef-c7b9-b963-c69d-84a8e15e6ecfuuid: 700f584a-d738-7f3c-7793-c16620887e94uuid: 868f6742-aafa-87e3-2980-ab49f7cabc59uuid: c6f07aed-b7ba-ba81-336c-e18372873215uuid: ce7bfa09-6223-3f3e-1461-1bb23bbc8bd1uuid: 018350e6-9b1d-86fa-d0e5-e78fad9f9a60uuid: acaec6e3-65a4-2587-e41a-cd8b33609cd3uuid: a116e5a0-f807-6661-aeb4-f7b00ba3fd58uuid: 19d7f911-6383-3a18-c2d9-9be912c28da4uuid: 62ad9a9f-4b08-76c4-cd59-b940a421c494uuid: 74032c8c-39fa-0f48-fa91-ac6b17dd0416uuid: 55c6973e-b77d-7f6e-8531-716a372d54c6uuid: 5f8c4cf3-14d2-894a-8b70-f062e10b2d22uuid: c71d64ef-7ef6-b018-7e68-7afdcede6546uuid: 8b69db6e-4e27-3b51-f4db-2678a2ad6572uuid: 169fb9f3-7a3e-a036-621e-0358d76b3232uuid: b815d7b8-a8a6-06fc-7445-aa4824f59145uuid: ce4e0f95-73af-0c97-5a24-17a8222cd4fcuuid: 3e39f667-c671-b37a-ff98-9cb18c4a75dbuuid: b6aeb089-d725-41cb-2d23-868958a80e4duuid: 41ee5d84-72e2-c79b-db92-ac585ea1e401uuid: bdd75b44-8841-04e2-2426-47bf891882c3uuid: 4ed2d8c5-e64a-0fa6-19d3-755ef9c49d95uuid: c33d1733-3595-85ea-1fda-cb6e68fa9263uuid: f87f34c5-d50d-b66c-deb6-f2af8c45950buuid: 965bd6ce-4041-93e3-c02b-1dfb2f4c7508uuid: ef2b5545-7a94-2705-f794-850391f86024uuid: 1db12dfb-6137-ab79-bc11-9278e8e5a002uuid: 3c06c1bf-b403-1bb2-78ff-0d30b188d6cbuuid: c99963a4-4cd9-4df9-fdc4-11d76ff9a3d6uuid: 214fe67c-12bf-fa44-220a-1233c71e54d0uuid: 3575e4bf-65ea-276f-e6df-2d3645af5ab9uuid: 8e971707-91a6-3d0e-0e03-af42e810089buuid: c8f434f3-b1ee-4d9b-a758-84dab82c5514uuid: 4074755e-c1e7-1f07-0cb0-c717b7627f00uuid: 39223919-1a40-c98e-067f-668082309a61uuid: 3d607a8c-3f09-c30f-a035-fa8431858601uuid: 1d988e63-f7e1-d581-fa80-ded79bf4707fuuid: c5150655-ba6d-7091-5109-20dc6e9d433duuid: 9a96812d-ca96-1f61-1078-3732c51d4941uuid: a476ca7d-85fa-1205-5908-e4df61f8c5e2uuid: 67045397-91af-3bb3-8710-84a40dde0e3buuid: 0a08e55c-6175-2b3b-cc18-73b26b307613uuid: 05614fe7-d6e7-f651-0caa-c1babecd21b7uuid: 18e9ffbf-33fa-0b2b-fa07-594263ee0dc2uuid: 7255e863-b88d-aab5-fb67-1f43f37617dduuid: e35aac99-9ce8-b24c-7980-bd2d30f538c6uuid: b6677df2-1cd0-bed1-44fd-3b9ccc8ff280uuid: 810c4ef6-8136-eefa-26b4-6ee6d0c03b77uuid: 27dd04bb-b868-e98b-442f-2e6c03cb1b3auuid: 0393980e-e433-4d44-e664-c90b62c05edbuuid: e5f0cf1e-ea04-6e57-1e1b-0bf591b479eduuid: cd6949db-e979-1311-10d8-4dfeb07aa535uuid: af3df25a-143b-8f3c-e3bf-c3ecb9cd2860uuid: 35e4f9fe-ae3c-1d53-1f05-e5b8a1753d43uuid: 92957440-2b41-7121-46cf-e151755c1720uuid: ca117179-e5dd-9d2f-68b6-876d82cf6809uuid: e21ca8ce-b737-e96b-4910-cee65d495e10uuid: ee649c15-0edf-c453-20f5-c456c4420933uuid: 795a1a1c-758a-9d4e-0a32-007edd1fa6bcuuid: f1c4af28-4fc5-0d02-e0c8-c536f7b7b9e3uuid: 8b93cc76-3e29-4816-7749-74626a7275c4uuid: efa8bba4-e9ee-764b-fe6c-8423f26a1371uuid: 464a7f68-8430-386c-ec49-1abfad75bab5uuid: 92e8e014-3c86-3fb7-1c11-1fc10c3dc8cauuid: defd8de2-aaf7-57b0-8746-12820d742935uuid: 08895b84-42aa-201d-2fef-409746909f07uuid: c872b5bf-0793-d997-434b-05465db3de50uuid: 61014acf-08ad-1b3c-820a-1e2a7178f9ebuuid: 29014529-c10b-fd67-f4b2-8277be162738uuid: 1f151495-8fe9-13fd-bc10-9b51673cab67uuid: 373a5d94-de64-f54d-480b-9ed287830021uuid: c6f6c2e9-9393-a961-7bac-2f35c0b87326uuid: 43962868-5eea-2caf-68c8-d3f590374fe0uuid: 1a7e3e48-0945-d64f-911e-155189c23d63uuid: 0ebcf91b-9a6d-d85a-3d5c-9dcbc3bd8505uuid: a46a952b-ddc9-3e78-e97d-efd796e49f0euuid: 16ff8aa5-c00e-f6ae-3e1c-c81a63b240e9uuid: fd4e6eba-42b9-0663-7148-1cda4b933d1euuid: c2d0091d-81f8-4679-6409-168b20ed80d7uuid: cbe8b2c4-c622-f6b9-61ab-e13a1eec3bfduuid: 20d13542-23b4-8e87-affe-6db148484074uuid: bb79f25f-7ac3-6d11-f957-a62cb9ed6c01uuid: edd0ade9-6f74-cb05-6372-496f59b9d98duuid: b020a3c3-7c90-27e9-1b5d-e2e581a10765uuid: d0697429-1789-3efc-5a23-4481b94bc832uuid: 56935de1-61da-cd0d-137d-005545d61576uuid: 9d0b4328-6d6b-7094-0b35-a167c615768buuid: a143671e-0395-9a93-14d6-c781b37953a3uuid: 49de65f1-8147-e2a8-cbd0-2b6cfcc74f78uuid: 23155e7d-d1a0-d266-41d1-b88910b136bfuuid: bc541908-5b0f-4b70-9a67-30868b31912auuid: 4ce16699-8a03-e8a7-e0d9-ccdde505c464uuid: 47e6b397-2821-f653-aa52-1f70a98f4eb8uuid: 12173de5-2ad3-5b75-f189-7a3a406f1c3euuid: c0fae73b-7c37-4435-6b7d-890abcdb1707uuid: 075e6278-f43d-54e2-c1d5-7c23e172819fuuid: 467ac4af-12b2-f744-7ec2-43ed9e107b90uuid: 4e6abd7d-5ec3-da98-8906-4a99ceb35b1euuid: 2e9ed74a-a359-0da6-2731-2cb39f971ef5uuid: fbc070e7-674f-fc45-c57b-e47428ef4201uuid: f4c8a810-6f34-685d-5dcb-a1d55fbf5da1uuid: ac76c7fd-83b0-cd96-681e-cc2824ea6d8duuid: 83375a2d-5e92-d0da-c197-82a2835ba589uuid: 3f69fe55-18bd-62e7-32f2-81282ea82696uuid: 62a55dbc-cf86-353e-c3d0-4c584580740fuuid: 2d019992-9a15-4ed1-a662-d094369677f3uuid: 3e7a657b-23ce-ee69-a7ca-73370c51092cuuid: aa37b455-0622-19de-cd25-db8586df4e25uuid: d8df24fa-e577-d118-8ea4-f3f22c5c8c0euuid: 373c3da4-0cb1-6cf4-4189-61785edc129fuuid: db410d3a-34e9-2d47-d772-c2c423ed8e92uuid: 58912c93-0a53-8896-0ca0-dfebc41afcf9uuid: f25bdf13-915e-5bf5-3e19-b33d53d486dfuuid: ac6e9fe9-b252-c719-8139-d4854b3d5491uuid: c75913d0-5dea-beca-67bb-68e4bd3b80d1uuid: ca0b76e7-02b4-fdc0-950b-466209f5706fuuid: a3669a50-6d82-9963-c7c2-8b30d3d782bduuid: cb6e2d7a-3845-e691-0100-e7947fe56f33uuid: 239f992f-4aa2-1240-aa4d-d57f7417815fuuid: 6f29455d-44e5-6efc-7d40-b1ebe9f99a52uuid: 5af7b62e-ea5f-a63e-b698-fe5b90a84b1euuid: 542d5f9a-9672-1edd-9a11-6e828d46420euuid: 8367d6fc-dc59-da6b-7502-16ddd88d0f4cuuid: f84d1df5-1cb7-fcfb-1b74-74c0027c450buuid: 2a352b45-132d-26fb-25da-6d51d811a768uuid: 39f94598-e62e-660f-f617-b7653d8b055euuid: 911c78ce-f83d-e12a-eccd-b9a535ba0dfduuid: 458aad5d-b956-2297-5c32-dade6687861fuuid: 634873f2-b8c0-abeb-3b5d-d9a6918061c6uuid: 150ac70e-f0af-dd53-1e8d-101ea3b84522uuid: d46dc72b-c007-ad2d-4a72-b51138bd15a2uuid: 8a1c1043-995e-077e-03f3-bb28071d400euuid: 1b687ac9-79f3-1a66-5162-4bfcc5adaba2uuid: efafccad-fb6f-8fe9-a324-525668685b23uuid: 09c72425-ed49-056e-ed3e-9dbcb6f2ed9buuid: a80dd0fa-b0c2-3b76-fae9-c811626098bbuuid: 5863fa18-4903-1431-5622-21afc3e4ce2cuuid: c7121e57-3827-cfcc-8b47-d3a2367fa912uuid: 3204fc3c-bca2-33ee-614f-c845306ee434uuid: 6692f47d-632b-ea4d-83d7-3f36a898503duuid: c9675293-0acb-459a-dfab-f38e490a444buuid: b3754958-8476-24be-6f8a-2e799fb74967uuid: b2b6f3cd-c9ea-ce3c-c1eb-72bd600aee75uuid: 42e2f6e2-f875-965b-f9c2-7f337a81540cuuid: cb544a16-db7e-9c9b-873c-79f62181e687uuid: 70977583-ec20-2c00-60db-56c0eb736761uuid: 32cba0b3-87b4-4bdc-225d-e4904a929e1buuid: eaa787fe-803e-7b7c-4311-797f4daef42euuid: b44ed38a-2f58-0da9-9102-c551998155e0uuid: f67e65e5-cd65-2c59-57be-05cda3005bcduuid: 638fe7a9-b960-20b9-1f6e-27005f6c490auuid: 6bd71b0e-024e-be1a-45f4-4ba14bf54b71uuid: 735165ed-bcff-79f4-66e4-16d752dc8003uuid: 855ecdf9-e80d-7d18-b04b-3afe2f6b4be1uuid: 071f3c8e-86da-fb09-5b09-3918c28e32e0uuid: 3d2c5d17-2fe4-c5b4-d693-ec31cdbe1e00uuid: 0cfe1fd0-3e42-dcbf-d483-3f530b9d67f8uuid: 8ebeaf3f-1317-b77c-6048-e134d1ad3769uuid: bb3828b3-7791-d613-1fef-f217e773f1e9uuid: 617a63a8-10e1-0139-5641-059f83df779fuuid: 8dc438ed-48df-878a-f9e2-ee0c2a40957buuid: 06dda9f1-00ad-7a0b-a4bf-c72dd153d764uuid: 5d189668-7733-4120-9611-569d841e47b3uuid: 303f7ef6-411e-a32e-21b5-964298004b29uuid: c92a2acb-c78c-75f3-2d9e-acd4bf175257uuid: 468538eb-4c41-702c-1c89-cf61369a17f3uuid: 4d49f01d-2eab-d6fb-842a-1e2823644d4auuid: c98ac7c8-2357-e22e-6e4e-1df63f9c21c7uuid: 92b07db9-a281-f430-bc0a-0e6660be6e30uuid: b871eeb8-e1fc-8af2-490d-f47ba2a849bfuuid: 449c0deb-1437-122a-e794-10bc46a33301uuid: 9cf13c27-18cc-376c-f269-22eb4cf5750cuuid: 753a4e3e-96b6-6e2d-e284-9aa2d8d136dcuuid: 4dfb27a0-0884-8ba6-bd8f-6e35d0ec3e2fuuid: 38a16fd9-7923-29d3-8dc0-6d9bec766579uuid: b5a35a7c-169b-9052-a7e6-701759ad5dd2uuid: c429d296-3def-2bcb-049c-8c025ce1e678uuid: b0376411-2489-de15-3470-d2336b4c887fuuid: e55fa9db-3fb2-73c3-3d59-b1c03fa46f3buuid: 47c1608b-1031-cd41-d1c5-db705054f0f3uuid: 50a72554-47df-6e28-79b4-bf5d2f5c9f3buuid: 6a31bd63-7d67-39ae-bf80-1dfdace13cc6uuid: b8a14bef-a796-aaa7-096e-087f8c73c949uuid: 54d11c23-cf2b-dd87-8f12-fc8067224053uuid: 59bc2e48-3299-dd63-a067-9c2e01df47d2uuid: c25f344d-4874-a740-2871-9903a440bd07uuid: d8253dac-c552-f067-431e-7a23c4ae28d8uuid: 511676aa-62d9-2a02-38dc-7f4b153aa7dfuuid: dc3731ef-4740-b03e-7132-27cf5a0419a3uuid: cb56ca14-bed1-9cb4-ebcf-d297d87dadc1uuid: f1f02adb-26cf-27c3-844c-816f0ee443b3uuid: 92b225ab-c3aa-6f98-79c1-d496fdfc66e3uuid: 7e95d88b-c71d-4418-c780-b7d6efc2acd8uuid: 33fab7c6-8a3e-52c7-8be3-89433c083eb3uuid: 6ed425d5-5243-aee6-d1f1-7ae5a5a548ceuuid: 0a54ca6e-e1b2-89af-5246-d3837c570283uuid: e4fd24b3-6ccd-4501-109c-ca9968040d40uuid: d32135fe-3f4d-2f54-7c8f-1aee5fe9edb1uuid: 53ec2ebb-259c-45f9-5e61-123dfb93594auuid: ed95bd72-8b78-ee2d-e3eb-038b6c144690uuid: 504bdc8c-f304-2dc9-cf31-b3cd4e0b3894uuid: c6a586d3-4f78-ddf2-2669-bde405ae6393uuid: a96126d5-f547-0f92-791c-f0a1e5b03589uuid: abe74bc3-763a-2eef-445a-b1670b1e5849uuid: 28104b0f-07eb-18b6-d6ca-2d34195b592buuid: 31895b68-ce58-24c8-b6e8-77f5b0f6cfacuuid: c062225c-22f5-6c51-d78c-261345f2ee34uuid: f5dc3c8d-5c51-1e40-ab9e-820e42bad43duuid: 9311e3a9-4a6c-6a5b-844b-8ce576f2bb63uuid: 63580035-5935-47d3-9ccb-4b7a94d215a9uuid: 163adf29-1838-e0b3-b159-94eccd552396uuid: 9e3aa867-6c02-1eb1-60c7-abe33f09c0f5uuid: 90ecd0cc-c5fa-1ceb-1aec-1a6dca31bb46uuid: d009d3dc-729b-15a8-5723-7c5a33685c39uuid: 60c64fb0-3fc0-6e3a-568e-30bd4001683auuid: cf8ce824-8758-09a2-6ab3-00abcf746d22uuid: 121c9785-7e14-c186-1b20-7666472ecd12uuid: 1cf5eaec-cbc7-7c6d-921c-d0e578541633uuid: 57d93bcb-2e47-0253-8215-3d3dff3bb3efuuid: 23b56974-ea03-fcee-a9e7-78bafda230bauuid: cb2ec129-e621-b692-47f5-bc6fa388830fuuid: dbb222e2-a7a8-742e-cd51-87c42541b6bauuid: a51d9af3-5cdd-2442-907c-acecd19a68e4uuid: 36461e3c-300e-934a-f6bc-e613bac0e7e1uuid: 6b698552-94e4-b701-2b0f-b69ce81d0bbcuuid: 6eae78f3-2c93-f449-fc03-2b096652f6c1uuid: 3e035cab-79c3-2912-46c1-7db262c092beuuid: 17980304-cf5e-41b7-43ae-192d75eb77abuuid: 73490d54-8673-8121-e56b-f11475a58ccduuid: 40e89387-a669-a09d-e0d9-731ca979e0aduuid: 51081292-1fad-9353-13cf-dbd2ace8b289uuid: b7cca52e-5050-f032-c05f-02f1136953f2uuid: 127b3739-ad78-bfc4-1f62-faf9884e3506uuid: a3b421ef-15ba-9b9e-26dd-fb8a296286d8uuid: 1032c5f5-e7f2-5268-78a1-1c1ec67062eduuid: cd572668-0a2e-afaf-266d-3d7d32598f12uuid: 52a5c427-4e4d-90aa-33e6-9ee2cb9ce69fuuid: 60589ea8-328e-3cf5-4031-6d20b4432e0fuuid: 0a5e0fe7-f5e7-0356-7527-5e6d6bc7505cuuid: abfe963c-4c7f-f14f-7252-49bf10f46e7euuid: cf4eceba-1021-7103-7edb-849a8de7796auuid: d208c7aa-0e1e-4139-3a13-500b78f19edcuuid: fa6e8bd2-822e-841e-f69d-667120144479uuid: 4ae4b7f9-90ef-4cb9-aae1-7a0552cdeb37uuid: ff5e726e-c8c4-0954-c297-977dc2be148auuid: 67e117d1-2d97-3eb2-6410-e54736ba6e1duuid: ac69602b-4c7b-e000-3cc7-b16082c24bd6uuid: 2f907892-dfe7-2efe-4638-58bd3a8c93bauuid: 8a30fe50-9963-593f-c0e7-be538e4ff8bbuuid: a6f83981-2a66-d3b5-3717-8439a0156a27uuid: 90aed4e9-c239-60f3-2d82-2101b2022b57uuid: 37f8e82d-2b92-eee6-11bf-f86e1ae16b78uuid: 9c87cd8c-d638-04c6-a387-3c658db266fcuuid: cf24def6-d92c-451e-f2de-60d856423766uuid: ddc29872-7984-3d83-05d5-8662f4301fd2uuid: 1e5134b9-98a3-9465-2d61-69757f8749a8uuid: 6c4b26e2-4130-58ae-7ba1-f1cdc2d3ac52uuid: c573e576-e77a-d1b9-d276-1ebc485eceeauuid: d72bb1e8-daca-940d-4d2e-3c431a2d27abuuid: 29e345e0-a810-0ca0-4227-b20eb145e513uuid: 53a03ee9-6990-9ba5-b3ef-9fb5b44f755auuid: 9752ca23-d15f-e76c-1b20-0afd523f65a3uuid: 358b6aca-df89-48af-232e-728a5d848415uuid: 85318c08-d375-6ddd-15e6-bab1babe7daauuid: 00d7aaa5-3ce5-b206-8850-ae615199205fuuid: bfc3930f-912f-357a-0abd-6b4129001b73uuid: eb2116e5-bddc-d02e-9a22-4a20d86820f1uuid: be169821-4bc1-2853-353d-38f82a5e7de6uuid: 3a774831-108f-9416-cb5b-d81b7a115721uuid: 2b7b1551-7f47-02e4-c204-4f71bcc939a0uuid: 9ad1d3a1-a842-9248-3e54-d0ff711ca42cuuid: fbbd148f-bbce-734c-d121-dcc96abde332uuid: e4a6e9df-6648-ade9-96aa-a979364173aauuid: 3fe5cecd-8ec1-4f0b-0cec-929670e5ff5duuid: fa5c12d8-a5a8-52aa-6846-891b0079dc50uuid: 80b7a3e3-752a-048e-79c2-8795c8d61324uuid: 6abe61ee-4bbd-baed-9c19-9615994be304uuid: 37db8d90-21cb-323a-8ac3-4723d3b1472duuid: 0c3d64d2-bf8c-99f0-57fe-9eaf07bdbf9buuid: 42557250-9035-3314-92e7-1c40af24805buuid: 08dd8789-ce42-220e-c43e-556147f9d819uuid: fe828e2e-c437-e5fe-6e23-3e03a2e5d176uuid: 8b77fbae-0474-19c8-269b-d7a8d1106378uuid: a0cb8bbc-5aca-b087-ea6f-817d1b49f6abuuid: 0783425a-d872-3c78-045e-14724e7c0e3cuuid: fabafbe4-4db4-3809-67a4-d98dd2266886uuid: c3199a44-ffb9-a882-3c38-554bbb5ee905uuid: 00f597b3-1372-e4ae-4677-545da3e55ef3uuid: bc0f99d1-49e7-70b3-5027-a92578ac0c0duuid: 456d3399-20b8-d18a-0167-d70a95812aeauuid: e6a16334-2504-01f4-eac8-26cd479e8078uuid: 77fd36f6-fa27-abed-259b-ff281d803cb7uuid: 8417887d-109b-83c4-a32b-9c2d9e411411uuid: f166d93a-9117-f58f-42c3-1ccb276e02f6uuid: ac77366f-d7fe-84f7-c053-0b97eb9aad9auuid: 7c17f3de-797c-2338-2c1e-ec6396c21341uuid: 23fc97ea-136f-f4e6-2bce-e20f0268eae6uuid: dd4091d3-2e8a-966a-dcad-5d92113e2591uuid: f6da23de-ca68-dc22-c037-8de304d36c4buuid: b2a32d89-4785-b8ed-77fa-a88b17ece667uuid: 9b38f88d-88e8-c521-dc45-9d4c4c5a2deeuuid: bec24d25-c57f-783f-3538-03bbc0571f5buuid: a36b4e73-077a-655b-9f0a-d1cc568eb694uuid: d94f36ad-57b9-bde5-fee9-4b6fec8ce534uuid: 1f05794c-3175-b006-44a7-56d3d15aefb3uuid: e3d5bbae-67b3-8eb7-4a97-42b431546680uuid: b236f4de-9db7-4d41-5271-b9917494d839uuid: 17027174-7689-b18a-517a-212a5c6337e0uuid: 4895a283-2689-35d9-7e4a-e064b8d35516uuid: c0ba85de-3d73-5ae2-90ee-31a75b06f90cuuid: f6a2284d-dbd5-e593-06e4-25d233be721fuuid: 09a20c2d-b132-1f1d-d72f-76520635aea0uuid: 1f2e2650-15f3-77f3-5e52-f8afa6a4e630uuid: 51ccee36-e4c0-f524-46db-ee1c1bec8815uuid: fe3993a3-56f4-0f61-0114-23b1e2bb520buuid: 0195d2e7-4b31-5f89-ebcc-adf446ab5a89uuid: 765d9583-3722-2d05-7e9b-566e73aba72auuid: b0194900-23f7-a38d-d78f-acb24331553duuid: 13614e81-a4a3-3a87-ce03-618eb9aa3a56uuid: 55c39c16-8a1c-af6f-398f-a505ad87085euuid: 7c3f635c-f368-c8c0-4065-eb412365817duuid: 62daa7ad-22b4-682b-0a38-c2d1567cb309uuid: 650616e9-4e66-57cb-75d9-106737f367eauuid: 9db8e6ad-ae13-da13-d7ce-20197d0501ecuuid: 24841317-5009-ef22-40fe-e07cf0a94f00uuid: 660f2235-ab87-2500-4877-f4028d537079uuid: 3bec968f-e56c-6678-74b2-ed1f908020eeuuid: dbbfb54d-2b57-9a24-ce90-16d855f4ecd1uuid: 4f73358b-7c9f-7d0f-25ea-c8b13aca71a4uuid: f02fe587-8fa8-df3d-996b-5215e4b4c2ecuuid: 610f7a78-93bf-b460-e3a1-309f56067fd4uuid: 8e7cb036-1665-21aa-3bb6-34bbd3b86da6uuid: a3dd05ed-d2c8-3682-a00c-a20778934fc6uuid: 88962734-c3e3-d8fd-7ef2-b7503b7270e9uuid: b1b233eb-7498-f96a-4681-9b7420e8416fuuid: e2e194fd-0c3c-d8e5-8ca8-33c9fed33732uuid: e46180ac-3062-becc-06b7-13759e104cb1uuid: 5245c0dd-b18f-7ff5-334f-26cf0724c6dfuuid: 50ae0268-0873-9536-157b-6b7f16066144uuid: 8edf69d0-a0db-3778-53fb-f4cf20a37013uuid: eb88912a-e25b-b497-34bc-691a008e8362uuid: 29d72ed8-0c72-d2f8-f640-0be3d1fd4671uuid: 79296739-d934-7a9e-ad6e-c58518ed89ffuuid: 31a9d825-6ed9-9c3b-486d-4df4edcb00bfuuid: 4af2023e-c031-21c8-4376-0fbaf4ba546euuid: 16add9c7-c2b7-7752-29da-18022cd3ba4buuid: 1e26efe6-ec69-81db-20d9-b27e213ca196uuid: 341ad9b4-7b55-5dc9-1087-099a68c96160uuid: b8340c17-3d00-f0f3-0a0f-36370c1b5a97uuid: 09c4df21-4cde-73da-c6cc-0d6068d3cfb8uuid: 387f954c-e987-5835-6532-0d41c8bd7bceuuid: aede741d-281e-d526-f394-5939037c254fuuid: 06e84e3e-2ad5-b476-dece-6b8a08acfc0cuuid: ed25329b-59e1-29b0-2a9b-509ff7c70be0uuid: df58d8d0-0ed5-8bb5-e8b6-fab00f068a40uuid: 6b6c26d1-28b5-4eee-accd-63a73700f048uuid: e65135f0-2428-9030-2865-97065ffc9d45uuid: 33241b34-b034-63aa-d783-b741e57ac8e4uuid: 3719eece-0192-455c-a99f-f9183b00c5c6uuid: 1bf95697-ece7-fc27-f47f-482d9e0c37c6uuid: a56f46ac-81cc-d760-1cf5-f522986e8da1uuid: 9547f545-b1a9-8a3b-fc1f-82b026ff5130uuid: 87bafc02-f7a1-50ac-3186-e93e4122f345uuid: a17de206-d8d1-1fc8-05dd-4fb7e793e02fuuid: 33fbb633-2f2d-f3b9-315c-490697c40ea2uuid: 0ee08045-393c-57cf-f28e-69c49c0cb3f1uuid: d2c97e9b-2fc6-6fb3-749f-3c626c38ae36uuid: b737ec33-2859-025b-9640-e8dcb1c59ff6uuid: 1468ec7f-92bc-b5f1-3fb9-3938acda2e49uuid: 6b25a27f-ad9f-baf5-81eb-2f7ac2b514e1uuid: 11fbbe73-2e28-6d51-6ab1-752843e68e8euuid: 1afe5ed2-7f7c-fbc9-1bf1-2212d2e01402uuid: 6b646a7e-8a95-b872-e4e4-f8ddf2d7223fuuid: 22bad73c-50e7-6a92-4b73-c7e2dfc133f2uuid: 013d11ee-9f0c-c211-c1ac-88a7a3395fa8uuid: e931e0c8-23ab-161a-e101-3fab16fd2a9cuuid: 0fb1081c-086e-0af8-dd5d-e72bfba8ce7buuid: cd07970a-fa6a-7606-0c6f-5389e792817fuuid: 00ff4f43-769f-eda2-27b3-729d43a89f7auuid: 4ee7f7dc-a2f8-81e3-3375-1a4d90e08031uuid: b046627e-9bfe-3c1d-bcb7-9a9dc8849313uuid: 8573cd08-f103-e5e8-b65e-98beb7e464e1uuid: 96783ec9-666e-8d80-00a3-a604218d8c5duuid: 5a442f67-c7be-9ca7-3d60-a218b41c2136uuid: 762e2aed-8087-06c8-7e53-006c0aaf55f9uuid: b6b5872e-2ef8-5dd5-5039-e31ab3f02128uuid: f7b5bcdb-07b8-bc78-0250-235777f42777uuid: b43c6f44-7cc5-fffe-1bea-cec560ad89bauuid: 411d54a3-9a1a-2155-0fde-e93185d7e471uuid: e6c355f7-d13c-4c0f-1339-4def9205be82uuid: 3f39f422-c9bf-5ab9-9fea-818b43adf19buuid: 1b2fd1fd-96be-9d36-55ce-71a8ea724ccauuid: 809c27ab-e7de-d241-0e05-655f77d1e64cuuid: 74cd5293-a0ac-4c27-0527-22f043ed912duuid: 14848175-8743-45d2-8497-1a6d3cb530e0uuid: 1c579bfe-a9d0-8ed3-a316-894eeb319871uuid: f7ed58b8-86c8-b611-7108-9d94c3cc53e5uuid: 095a27ff-7fa5-cbae-0498-4b72167f20ffuuid: 8095ab0d-c885-6129-fb84-16a718e4d9d6uuid: 4fe80986-67cb-8796-81ee-59b45cf7c1dauuid: 64a15256-139c-4ed3-6552-705f3a001b8auuid: 6aa786b5-b085-8470-b351-bde5ee1317bauuid: c3b35e4f-1a54-154a-f962-633011e91221uuid: a23da775-827b-bf25-2e1d-14e63dfbec0duuid: ef8a2805-05a1-431c-b085-a8af68f2e67fuuid: 5005e70d-0ea0-1413-effa-3e1fbf692cf9uuid: db5efe3e-77b4-50ef-7f76-e7aee597e956uuid: 9e1cf97b-4bdd-cbb3-f7f7-fbdc5a9d930fuuid: b88cccb4-cd78-541a-bc21-1a94beef4954uuid: f5081cb8-6bdb-f87e-4ac9-23f18c674eb9uuid: dda06199-b128-1bc5-a6ad-cfbe657857afuuid: eaa6e2c5-62ea-f127-1afb-847ead927cd7uuid: 459d3354-b6b8-998e-eb34-a52336e50d2fuuid: 26b31dce-bca8-fd4b-ff8f-54daa6ce8f12uuid: 9a4eeac3-6794-9c3b-78b7-a1b784d4e0fduuid: 618a652f-f09d-cc4a-9f33-7ee6193f456cuuid: 9b0986aa-b909-12f8-73b3-a914b5c61855uuid: df92cbde-0a14-5e49-2728-a41ef2181f67uuid: 4a1d78b9-1db3-9df7-b43d-dd5a49c2368cuuid: e9f09891-45db-8dd6-d8c1-81ca2a76d296uuid: e853071e-02cc-34bb-31e7-f0bc518021e6uuid: f9cddd94-21e5-c401-179c-baab17c30b71uuid: 02c4615a-8822-f2ed-682e-1b569834fa83uuid: eae16048-6b2b-ab82-67df-43f9fe7fefc8uuid: 9d8650ad-9f54-a3b0-97f1-83e4a2bee8ebuuid: b156f7d3-8f92-5df5-478e-ddf226fafc53uuid: cedeb7ea-555c-f47c-28ac-92e5f8fa28a8uuid: a80a8ab3-ebc2-48ad-d516-0f3fcfa52527uuid: f352185c-1dee-165b-218d-e9568d126b05uuid: 8d400869-d805-bcfe-b6f3-5382a1e0cf91uuid: 07cf311e-0e5d-1394-11a3-ac23ae771ecauuid: 608f6432-512d-8ce4-2c4f-c576377de05auuid: 15bead2e-3028-0fb5-5a67-b10e90296c5fuuid: 6e631a9c-161d-5e53-53c7-9358c2d497deuuid: 84606a22-a163-0cbe-89b5-4c4f42c64b9fuuid: 55008120-fc9b-48c2-15f7-d25203201135uuid: a12c9705-a731-5730-6bbb-0f3b35e038d1uuid: 337564aa-2439-df8f-1846-0c9286968dbfuuid: 62b87a13-8e4e-5800-d0ed-d88086821f67uuid: 59c82545-d371-7548-5511-b10645e15394uuid: f6c4a897-1bd9-69b1-f25e-e7d2a11579eeuuid: e4b3c85b-4e06-d869-6898-f2d80d3c13c5uuid: d053ea99-bb9d-0f87-5fff-de8ce395e774uuid: 3c78c8e1-acd8-7214-1259-04b6942b7fbfuuid: 616377e2-8197-0dc2-98fa-ae73505801f3uuid: 18233bb0-8728-e25f-d5b5-bf338e7fd1cfuuid: 9eb5689e-137d-cdaf-dd27-71f2931fd183uuid: d76c7cb3-b798-b55e-157b-fe5d329ac5f0uuid: 97f30792-f907-5744-34c3-75aa4929df31uuid: 848b8246-ecd4-c978-68b8-1885d419d854uuid: 90ccc7e2-9e18-190a-a28b-156771263623uuid: 12215caf-351b-2094-7e68-2904492a13c2uuid: 2c679825-0ab3-ff51-da03-9eeafa1461abuuid: ca314e15-c0e2-3e7b-f7f9-14c23b505cc7uuid: 7fddb279-98da-397f-3f17-7c9e51fd3ca1uuid: 901dcda4-b8a1-07d4-11cc-98a7b9093652uuid: 67c3c189-fddb-d181-c79f-e62eb2b905bcuuid: f4a6e9f3-1719-24fa-46da-87ed17484c64uuid: 61ff3112-e58b-f051-e4dd-318040f69996uuid: d1985049-d303-8e92-a490-7ae55fd05d9buuid: ebc8c201-a237-fb8c-dd40-f9eec590dc20uuid: 3d93109c-91a1-8b97-4983-49654969e7e1uuid: 037184ad-c88d-069f-6986-df6aa41e8a29uuid: 6f48fb25-0753-6824-bbee-bf02b0efa5acuuid: 4289ab04-82dd-5888-12ca-5446aa5758aauuid: f67db824-e01f-7974-bba4-c2462e0913a0uuid: 24a3ba8f-8a56-f49b-b82c-6961b2d054aduuid: c174c6b7-ce95-49ed-f5eb-37d3cd766d33uuid: 5580ed22-9ce3-f1eb-e2c3-6ef99af28150uuid: 858fdcba-8f6f-d421-6a9f-82f06c5e5e9auuid: eddf37f5-4251-a03a-fe2d-4c7b7e72bb84uuid: 3bd30cbb-0a48-3087-6604-592788e49893uuid: 9ffdf1a6-e5e7-1aab-ef35-ea69219cc12cuuid: 7e354382-4c70-b8a0-da41-b0c0fca9a05fuuid: 8b0c44c9-92ce-f4e7-cea1-9fbff3457e45uuid: 16937eae-f6b8-0beb-0996-d14e7cd6bb76uuid: a76ca12d-72be-8721-8acb-27dd504589bbuuid: c5b0c013-ce63-0247-5cfe-9e88eac842f4uuid: 108ae008-3133-54cf-a38d-cf5db24bbd7euuid: 65a6f2a3-f88b-607d-c92d-62efae57170buuid: a5c853be-cff7-0c2d-8d75-1f66421790d9uuid: f2711ef9-339a-d50b-a579-35ebe25efe61uuid: 96a0d0cd-7dd1-b1ce-3fcf-f24684165e2cuuid: 4489096b-4ce5-5d95-0814-1343cfbeefdauuid: 133662a6-28e5-8ce6-ac25-c708179028deuuid: 5856a441-c04e-7199-ec68-99d831f92ce8uuid: e223f334-bbe0-94e4-ce58-a0eb147db45fuuid: ffe3ed8b-d8ba-8785-d570-7f576bb4c9ccuuid: 0979dbc6-d294-3ea8-d555-f4e2a3099ac7uuid: cefb2b5c-d31a-3b9a-6c56-3a7b25f30716uuid: 78c1c8db-05ac-c78b-8a22-bfa58aa26306uuid: b6b8a2d3-3226-8b90-2085-07db45c04d92uuid: 811015e5-b98f-872f-04cd-a9fee2acf394uuid: c9cb997e-ede7-8f8b-eeec-cb195920baacuuid: 39bf609b-dbc9-f793-bdb2-7ffa4d22afb2uuid: 3673785a-50ac-3feb-247d-20fc4573984duuid: c15c3593-0a13-ce0c-ea5f-feca0c45aba4uuid: 3423cc83-6dbd-7af0-6a1c-a9e86b457b5cuuid: 2975d917-64f7-6fcc-9caf-f874320224feuuid: 0d0208a9-ae64-0e84-9d6e-539d37e99f8euuid: 996535c7-26ae-6957-540a-2dfc072920b9uuid: 054ae994-846b-7b0c-7f6b-d43de766560duuid: 2c72a11a-c02f-ec3d-658e-601aacc2e858uuid: 535ef610-644b-ea27-f68d-84a8bb2371deuuid: 5dcfa669-f24c-787d-b833-0c87ae8f7d3duuid: ccbc5423-0861-7a4f-1041-df3e075e7d33uuid: 4b9e7bbb-09e5-35e9-9749-75de4de447dbuuid: 5014e9c9-7d23-f38f-b59b-f19e8945f798uuid: 3c4bc735-f19c-4649-68d8-05f2b88c241euuid: 656cf021-74cf-d8f4-3585-28dad350d3fduuid: 90e1229a-49d1-eeac-fec8-318ffc6cbb9buuid: e01f9a24-1d98-97e1-5dd5-1c6535b5edabuuid: a8b57fd3-c8fd-239a-b55d-e8b6a79c1c0buuid: bda4ae6a-04b2-a163-8e23-92a1ef072277uuid: f9c947dc-b2b9-879f-b08e-d8d068597fd4uuid: bd09f758-d1cd-2fe3-9b44-19523b2ad458uuid: da36d42d-6371-3202-428a-07add2b4e209uuid: 31640a7b-fcda-5fb2-b638-ff7aa166876fuuid: 239df024-0ad9-791b-84f4-8fb987be5bf8uuid: 57d59d39-fbed-b8ea-b5c1-6d59763fd536uuid: 6a9d17e0-0469-9181-24a8-cfc56d4e82e1uuid: 6f1afbcf-bba4-fce4-5ea3-ccb5b6c3d140uuid: f5b61cc9-25d8-556b-d9e0-dc535dc8e783uuid: 42ab8683-b658-19c7-36d6-9d14eb3163f2uuid: c133b492-4d87-4fa3-903f-c5706823baefuuid: aeee9d85-c96f-e237-6d89-f65667b3b246uuid: 0ace092c-c3b0-723a-2359-3bbd7d55b9e6uuid: e179cdaa-33da-6465-a635-9021149e5e50uuid: f4ba1468-6eb1-97ce-9014-611b6eef707duuid: 9fbf6e36-3c36-1ead-bb09-4bbd7bb561eduuid: a3409460-632f-9288-ef65-1b3921cac636uuid: a892cdb9-5038-6675-ae2a-4abe19e93477uuid: 786f10fe-9aa8-414f-e6bf-939635f81879uuid: 7c66127c-49cc-ba57-a79e-979b64508e24uuid: 1384dbb1-62ee-06b4-6c84-e4264d53a822uuid: a7f621fb-5979-1f3f-e55e-ae3990ee7f81uuid: cdb8bfdf-1905-d1f8-c8ae-af756f86456euuid: 87fa1011-433e-9da2-780b-ae884360ddf5uuid: 3994279c-3b08-296d-416f-e0fff6068141uuid: 47109979-b461-d719-cca0-4ebc50b7c7b1uuid: a00a539a-2764-fd86-0de5-1d5f55d1aedcuuid: 72e8ade2-f3aa-119a-2326-a4a66ee429acuuid: 9ac7f1f2-2145-22cf-ef2e-2b1503be3cb4uuid: df2bf480-5115-6f4c-8c81-f84df27a5bd9uuid: 29e7314a-b3c5-831b-9232-c97038be0074uuid: d085ac05-0404-ca85-3068-236c3361e149uuid: cd2c181a-5050-fc14-1b12-29ba08f0d498uuid: 72a28c0f-92b6-488a-59fd-cc7863acf446uuid: 3d49add7-449a-fdf1-b8e0-f4eafd0864c9uuid: 2d3cd2de-2a08-189c-47eb-ecf8d1f02078uuid: 6d9a7daf-603e-7da6-abb7-45278fc588f8uuid: d8eec899-d4cf-295f-09d6-0449039f0f5fuuid: af7cf242-10d2-fd1e-6402-ddb01916f571uuid: e177dbca-81de-bfb6-af76-70d4e8f48b84uuid: 9c6ad332-4ef8-4007-3fc7-6c8ab732c9f6uuid: d420d58c-2b4c-5fca-53d9-e84e44093568uuid: f18b5fff-fff0-2c19-2dbd-b3ef2f12a3c0uuid: 80f36ec1-b9ab-58a6-fdc5-7502d6eb1402uuid: 8f02f997-6213-253b-559d-58e410a1823fuuid: 297fe4c7-f682-34f5-bc97-f3da4a11c95euuid: dbec000c-ae36-0cbd-6161-440e4e7474f3uuid: 12b51fa8-a08b-853c-bfde-d3216574f391uuid: d76ef46f-7eca-a8a2-4520-f8ec98434e11uuid: bdde3656-980b-b360-e4d2-22a422947cecuuid: bb8fc369-d7b7-fc71-b4b4-2954c0c467fcuuid: 743a5376-4ec9-3c4a-4ed7-4b69228b6e1euuid: c5c2223c-7a0f-e668-f083-076ac744d9c9uuid: 9b289690-0028-0fff-0441-90a60af75290uuid: f8ad03f9-d933-ca9a-2b88-83c1503d23a6uuid: 5c1f1f7d-976d-6e5e-0d2a-a9961bc4f546uuid: 7298cc8f-5b9b-67de-f6f5-24659040026duuid: 550beed5-1f1b-d1b6-a6db-b4ca0677fa65uuid: 32fd3e77-e690-b467-4d66-95e1b6d5d6a0uuid: 2cee270b-e372-6d38-308d-a8edcbc63aa1uuid: e25cedf8-bd6c-4a8c-7e89-d9e53ba58376uuid: 5747f4c0-e49a-7feb-a22d-095912e99d67uuid: 59fd27b9-c5d9-33c7-6443-a1afec29e07fuuid: 94db3274-e263-b14f-006d-22d2180db04euuid: cce39666-6a66-72f1-3809-ba645a6d1216uuid: db3cb2e9-9c3c-f1db-646f-f162f92be84auuid: 74e02650-2797-3ddf-def3-807d89119635uuid: ead0681d-a34b-049f-1ee7-98ab7566b999uuid: 7c5478ca-96ed-8b2d-5468-1131c8fb3854uuid: 0f482a99-9445-b692-3fdb-83ed6994d580uuid: 22017688-b99c-f0d5-b0c5-c1612efdecbfuuid: ed08280a-5790-f740-f311-86fc432f2305uuid: 40fa5f6e-d0be-8e0a-1d0a-422ff80b2de0uuid: e59397a5-acb5-d6b7-b051-000cd16960b4uuid: 39124f11-299b-16fa-5e3a-02ae72cab3cbuuid: f92c1ec0-16d2-fefb-4fe4-7f5618b8fd85uuid: b7814f00-8d5f-d714-fc40-1df4faa0369duuid: 442399f3-bdab-71eb-9506-a9c755807c62uuid: 1ff29e9a-0d7a-04ad-9e9c-0eb3447e1043uuid: a8f6f567-8d36-49c2-9a64-d9a737292183uuid: 9c366e5c-b9bd-de68-bfac-079c759e7e2euuid: 857f0390-51c8-01d2-eeb8-e2b74ee36403uuid: 65a0e431-5624-d7dd-2e07-17ca82d667c2uuid: 697d286b-2b4e-d43c-5223-abf1acd7b2feuuid: 3fb3a207-00e8-86d1-b693-831e35317b15uuid: 4e0a4f8e-9409-9614-a712-2b042717f74auuid: 725d4226-64de-aec9-4326-859496d46c92uuid: f919d937-a31d-a481-ba93-9d55ff27d710uuid: 39cd5838-cb7a-c4eb-5e50-e464cabfe9c4uuid: 2476d317-c7bf-2b05-91a7-f31b9f9dc9a7uuid: 0d3fc01b-6ed1-9da7-37d9-e5951527e526uuid: 141d93c0-2468-1b47-227d-8be18c9ea2b4uuid: cb9e86bb-638c-6b33-bffa-81cae6a2879auuid: 74889639-a2c4-8081-9c9f-adc564127b2auuid: 34ce1604-9410-49be-5755-afe9fdc9c7ccuuid: 06bd1a5e-053e-889c-378a-82b093d61e54uuid: 51b4fd4c-9c1e-88b0-12f5-e6aa6340c7c2uuid: 1ae10c37-fbd8-5c25-c147-50375116dae2uuid: babd8dbf-5336-d874-6444-6c03b8ac7ed3uuid: a6acfbca-a266-af4d-3071-288b18c86c07uuid: de55fd65-0feb-b82c-741b-2e2ef3df994duuid: b5f6efab-879f-9735-ae8b-aca69e4b747auuid: 28016a79-099f-a8b8-1260-1d7107c342bauuid: 87a10ccc-3894-cd88-0379-33d2f86bb165uuid: 23986042-3aeb-ab0e-db36-15898ebe6e5fuuid: 7004b621-2917-02bb-5a37-a8123ae06a41uuid: 295471c6-885a-7f87-bc6b-b6512ab996fcuuid: 8f3190e0-f758-d530-121c-aa34bc0c05d4uuid: 2a20e52f-6026-4bed-b941-7cd0a5263cd2uuid: 213881d3-e66a-cc15-788e-aa5837a58859uuid: e43f81ef-5917-fad4-b072-2ff4e414ed7euuid: 5e1ca548-e05f-d1cc-41d9-e24365822de4uuid: f3a18610-559e-82ab-fc52-7b8548ffaf1buuid: 61706b96-3c01-f6b3-2e07-0cf000f25168uuid: be7faa0b-5a79-c9c4-d039-fafcaec965a9uuid: b49c6ae0-5c90-aa51-59f4-aa97b67ab4cduuid: 2f83149f-97ce-e587-34a7-bbe7f22a69efuuid: fbd552b2-840f-dfba-c577-963ec046df86uuid: cd69c2ca-327a-6c7f-ec5e-86b6fc73122buuid: ebf1e699-fa57-0e5b-b9c9-bd8e9106ac1cuuid: 6c2218b1-3ee2-84ad-47af-ba7b5b9cd14buuid: e7e0133d-84b1-e6d6-86d0-29f0bf86d766uuid: 4e50440a-d46b-c0ce-c127-adf701fbdb4euuid: 730339f7-7f8a-a374-a3fb-f1ed972b2a2cuuid: d6bc486a-eb63-ef0a-825a-f5ff59897f75uuid: 5eafd6d0-8632-109c-b241-0b309fd99ed7uuid: 39b3f923-142f-d533-f506-6a013f2a24efuuid: b6be2d1a-d310-a47f-ae74-d1021649414buuid: 5c69ef3a-9dbf-7502-d3b3-9988a80371bauuid: 5a279803-fb9c-9b97-22f7-f4dafdd54794uuid: aea75c1b-1a00-b4cd-d148-bd1f600e88a0uuid: 22fc7ad3-3f76-8a8d-0e66-4f7ccb11ef03uuid: 00b20da6-c633-835f-cf90-3ef204c73a1euuid: 5e159c9d-b6ea-0251-5e37-2b9caa11b491uuid: b37bd692-c530-adf2-c1d4-857a8d53a4feuuid: 88c0f800-0e84-1df0-aff0-df6b22c49ba9uuid: 6ed58923-45c5-4c1a-3e38-add26999abd0uuid: 000075e4-f851-87e3-6d68-c5552aee6794uuid: 61e205c4-996f-bc16-8b21-2feda43228c2uuid: a2182645-044e-5c4e-21af-acb3f8b13722uuid: 200f2ccb-60da-9d5f-1a91-cf930eb0f253uuid: b6f8a9b2-ebd5-7282-dd1e-f5b2ba6d2676uuid: 48bee75b-bd29-a254-263b-d3f216aed3b5uuid: da417ee6-c94b-2eb7-f829-dcec079ec4ceuuid: 2037e7c6-dece-bc08-0114-05bfaca7719buuid: 2ae3c427-1b40-b215-531d-7cdba3015451uuid: 03ff0387-c5e0-0056-3895-46c0a226aacduuid: bed05b32-be06-aad6-544a-e3269aa3e0a0uuid: 4855d0ff-1e59-2d7a-9974-b14e03dd1e20uuid: 49f8fd11-31b8-4de8-fa35-090e2e1b146duuid: 05d27273-7d24-2e13-7872-a8e107594cdcuuid: fc2d0223-c3eb-a02b-f3dd-55d41e537f0buuid: 5b21ce43-c084-5d15-a840-9ff5137dad88uuid: 1caab0f9-07bc-ef2f-67d9-4bc75f4db68auuid: bd3f9ad2-8f83-74ce-c613-c0adf55d2b6auuid: 0d7a4064-52be-cdfd-ed78-cc9ae0b0d177uuid: 35451f8d-dbea-9c70-c414-734cfbcaa676uuid: 049d05db-a0e6-5251-8e46-8ffd396bf781uuid: 4b429e80-0e43-f4c4-ddfa-f695f9bce17euuid: 3641c8b4-1b55-8c1e-1fa8-97ade1decd19uuid: b3fffe5e-42fb-c093-e827-b805b7af75c6uuid: c86662cd-cec5-9d69-bccf-498997c6ea39uuid: af9ee2a4-42a4-7126-24a4-19e533d4deacuuid: e62ea55a-cf68-36a1-23f1-268f2cd4f902uuid: 7c9277ff-960a-120e-7d36-204b8f42542duuid: 2e62a14d-dcba-855f-3bbe-c8c71ccd7026uuid: 50fc2742-61f9-00fb-89c9-e2a92cc70c23uuid: af1cc800-b016-9d18-04a8-8085b121ba63uuid: 9c9303c8-aa08-069f-c689-2a7963ffd625uuid: dd58191e-7cf9-87c7-06a9-e4158206eda2uuid: a385e432-3e40-9686-3de1-05231889758fuuid: c0fd6c39-134f-329d-8639-9e52ce69bd3duuid: eeca3359-04dc-43be-45ab-8f5a7b9a121auuid: 0a3751c4-7a92-61cc-2c99-4d49739c32a3uuid: b886bca9-914a-ab29-25c1-3be2f055e7f0uuid: d3aead66-7937-3d56-6130-168c61485331uuid: d159fa4e-d56e-e1f7-d337-90c55e51b2b6uuid: 40ef3bb9-3043-cff7-503b-61ca46ff352auuid: 757e4278-ff4c-a781-779a-2abf341ac2c4uuid: 2ec54ce7-6725-bf7e-c318-fefbe1c2711cuuid: debbc323-d96d-8438-fe15-56ad7a074a3auuid: fd75cb1a-814c-d603-453e-88b28c3c20dcuuid: 2e8b00ee-3fa9-183d-5ac1-b80293d02219uuid: 783a6986-9920-1d1b-fc55-bcef82dd8c5buuid: 4e527cfd-6239-eef6-7bb5-c3dc9e22a4e9uuid: 20971675-4432-c70f-9ae2-2c0e571dfc52uuid: 02d03520-a11f-1af5-148e-c22abdd8d76buuid: 079bb776-8dbc-f048-d77c-66d96c156028uuid: 2cbc3026-0faf-bd5e-761d-0a1f594cc792uuid: c42ef1b4-2810-1b5c-0cd4-ae04d9b3d1b3uuid: 1a6a9a4f-9b00-111a-54c8-c95c7190c1c8uuid: 603a6f5c-9f9f-2278-6bb4-83084ea950a6uuid: 8c16da50-1fd5-7f50-d7aa-b9ffe2f965dcuuid: 9974e048-6c65-0626-6cf2-3272be088310uuid: 6a05a33f-3971-4f82-a2bf-26928b2ee7cfuuid: 2dd24ad3-244a-e4e5-b354-a0ebd9587614uuid: c4f260a2-cc25-558e-1a11-8515b98012c9uuid: cb61f214-7e66-dee0-db8b-c2bac1401662uuid: 5beaca54-8c47-6a21-5f92-396ac3ea4e22uuid: 36ef79d5-1627-24f2-317a-01589d595b5buuid: ef47386c-c0b9-5d8a-0199-72dfed855479uuid: 44d857a2-1895-3fdb-d8f5-d6c2f23b08bcuuid: 5a6bc829-a78a-49bb-8ed4-88fed5e092e0uuid: 3c7cde38-61fd-c68d-8311-7f5be3d63183uuid: f13ed174-e120-2bb9-c279-300f5cb6f5efuuid: d28425f4-31f6-4dc7-992f-971a6579d597uuid: eb5d2b80-0696-a61b-5e09-4967cf096f75uuid: b70d8013-9f2c-b858-d88a-800e7eeb4259uuid: c6cb8b75-f2c5-d8de-e8f2-8136f3ec5af7uuid: f9c8be65-6643-b9da-300d-230cd24d3d11uuid: b7fdc7b6-02f9-e91e-e954-e528f285b44buuid: d2cfadb1-17e6-5e17-685e-342342fefa3auuid: d1897ad0-00ce-820d-5edd-ac54de5c2debuuid: 40d1bc73-5705-ee96-4d4d-847f91df1d18uuid: 3a9e291a-5048-e807-94fb-16c97b2d27beuuid: e31ad553-0a9e-bcd7-e307-c91ced37a545uuid: 4f8f6b97-573c-e79b-cc63-116e09845274uuid: dd4c0a1d-28c5-b39f-5f9c-b5d3ca39470auuid: 77beb340-a5d2-37b2-fb34-84972ff17673uuid: d0133161-fa01-b144-4a8c-130c3e213ff9uuid: d8715b5a-8724-c8c0-1438-b0905f08e2dfuuid: 61d04f28-b645-19c3-1f87-d9f69978b60cuuid: db28ccef-6965-3bbd-edfc-e5ee0b3123a3uuid: 40e8e240-afda-60d4-f07c-e11e04728b90uuid: 72929c8a-1eb4-ad64-9d22-7f8628ae5061uuid: c1175850-8ffb-b697-f7bc-f4776dedcfb3uuid: 7c1c2ce6-82d2-16f7-f0a2-150742f50eb2uuid: 2e591e21-6525-89d6-f3fc-d7bb079cc1aeuuid: 47bd5d79-8a44-b508-9dcc-6223e52c92bbuuid: 370612da-d3d4-9180-358b-1e9aaa91780fuuid: 9024efd9-6884-ba91-41fc-a8348077f48auuid: cb3ebbff-0883-8630-ed2f-a907d1ca2fdbuuid: 393225a3-d412-36c3-6298-219606df9f75uuid: 790a20a5-fe5c-03ab-fa6b-3b53d460404buuid: f7b402df-2f1e-f4db-f0a7-6fec01f8d8dduuid: c2d4a33e-1471-b307-3d26-170077f88761uuid: 9e48e59b-a482-4f0b-a457-af40d8a12ac4uuid: 81a49652-81eb-ff5b-7871-7bb2146cf60fuuid: c0e9d511-c9e7-4789-e7a6-429865a7e4d7uuid: 95934f9c-72a9-a662-b96c-d7b7e7504f31uuid: b98ab6ea-69ca-37eb-cf04-3c5537bcc226uuid: 3b58db9d-6b8d-e680-ea37-0a604b3423e2uuid: 36def0ab-b283-2b1a-8453-0e88c955fb39uuid: 60b575e8-afa6-a2a2-9286-97ff02f1fd5auuid: 26b75986-581d-4fcf-2a76-55f6608935a2uuid: 90b6dc53-0715-fc4a-939c-6f380703a213uuid: e3e46db5-3318-25e4-f9dc-0f1c9862d23euuid: 2e926af7-af39-e205-248c-1d7ab754a8b2uuid: 503f24fe-bf73-846f-66b5-c70cbb57eddeuuid: 0481b6d2-1c72-7311-c53a-7d6af9a47e5euuid: 2fa67edc-a784-1cf8-ec58-929792f791d8uuid: 4cacfc88-521b-05b2-e922-3a2cdf911245uuid: 2d857ddd-34fc-00ac-7742-70d2c3402c36uuid: 3a27e209-fdf2-de15-e3fa-2d704adeee49uuid: 3193ed8c-e1d5-58e8-fc2e-f09c396c22e0uuid: 78e7f8b9-c0c8-0db8-4b27-7aa08c4a3231uuid: 622a8035-a747-8914-2ba0-5e6b13e70f5cuuid: cc911b43-a06d-335c-bfc4-2b669c1fa1d0uuid: d9eec78e-2894-7f30-ae2e-439cf5f5cc7auuid: 4384d506-b798-c7e8-d486-26a40595cf06uuid: 533565f1-21e8-8eea-b372-ddc19083c0b2uuid: dec77cfb-3774-0f51-6306-207cefc728e9uuid: 3dfb5594-e457-ef22-9dc0-da9d956828f2uuid: 9caa80df-4d70-218a-f5d0-82a518d6f332uuid: e5f7903e-f8e9-7beb-eb4c-7b3959d4039duuid: eb6113a1-22b9-76e1-1ae6-ccb5bbc98777uuid: 06afd6c1-4292-5bdd-a5e1-3e345f645471uuid: 71b53a3b-d175-5a47-1c39-c92532d5f504uuid: 85e66abf-1507-6c9e-619a-aa1a7f9cbaaauuid: e6cfefbb-c471-af74-b968-53a6e3e9dcb9uuid: 0d3a115c-8c8e-2cbc-6774-f085dab2814buuid: e1e3032d-e0a1-1f13-2676-63ff59f84f5cuuid: b0534f30-53ef-2237-ece0-908a82fe86f1uuid: afbd4efc-bdc8-1666-c7c4-7103df00e9ecuuid: b4717ae4-efda-fd6d-5e96-78f1d4059ab1uuid: 27ea4768-2b58-09f1-8957-4adf1d7fb316uuid: ddab1622-9b7c-26f0-f84d-c59633b92e49uuid: 825dc66c-b55f-0767-e4f0-cc3d9aeeec50uuid: 43118141-dbd7-3302-6637-f09e32fbc0a8uuid: 77bb1cda-682d-24a0-2ab9-99c7dc592eceuuid: 1bd2ed23-6ea3-4f5e-896e-2f4646956596uuid: bce6b44a-b18d-ce03-16e6-1ca43bccdd28uuid: 7ec3d51c-5567-fbb2-6511-89cf7cd867b2uuid: c735f8a3-8d32-f24f-5840-5c7c993ab785uuid: ee71eaee-c9b2-2182-e70e-2a4768ac1c6buuid: 959220c6-466c-d1e3-e3d1-3075164012f4uuid: cec9b4eb-1bb3-1a9e-1196-e7bcbef61dbeuuid: cc61e3c9-1f01-ea39-adf5-2f78762f2b49uuid: 8879ee87-236f-7151-708d-4508e0061a19uuid: ce6edd8d-5b1e-33c7-9a7d-7796f8f15b44uuid: 531c8241-b279-99dc-2040-deb55b982b06uuid: 5754ce53-ccb3-e5f3-7e74-9b08bfe4539auuid: 61964152-e76d-3636-4cfa-7aa945f4da27uuid: eaf7be93-f9cc-e438-c133-9c3f63119ce6uuid: 795c0757-c9b7-f1ce-e00c-a02ea9fffb2euuid: 0d2ca7c8-8710-fb4c-ae53-b964376b14dauuid: 84ac9860-381d-af5b-784b-73d953f17596uuid: 5653d869-7090-c9de-9608-ef79cfe67920uuid: 7211e863-7322-7cb4-be54-76d02848e18cuuid: 959f49df-2900-ed57-0842-66a1b6aaf436uuid: 6a780ef3-3245-584b-5875-3b5b58164275uuid: 0e2cb694-50df-94bb-82ed-67c5f83d3f73uuid: 0967f8f3-05e0-5e6a-2daa-9d012e9529a3uuid: 4e5cd644-f4a0-5b28-a5bc-03e9c0487136uuid: fce47da6-85a9-317d-0a55-29d626f7d18duuid: 05cf4676-79ec-78e7-c9e3-5cf14799e9f5uuid: 06b420d6-678b-13ee-5036-ac3fc00e0d05uuid: 40f99246-534c-2a36-94e3-e668794f9cd9uuid: 87f4399b-e752-05eb-3671-23f12da81ca7uuid: d40e680c-f646-3828-3df6-33dd5b9723b3uuid: 4d4b3f90-e753-8eaf-5687-291aeef50d76uuid: c81541d6-5cb6-f08d-e64d-57e31e70e1cauuid: d2aa2c6c-1976-d76f-21fe-da7152c915e1uuid: 66e36349-6942-7d33-d70e-4bd73523e1ebuuid: b59c882f-e5f0-8385-00e8-ca48e151107auuid: 13fb6be3-0ca4-f0b4-1c7b-8c01ac04ae33uuid: d8f7f4b4-ddff-a1db-46ad-e281d567ddccuuid: 77b3b0c4-309f-0b4e-9d7e-96a28d46d45euuid: 989f3517-51b2-7816-064e-59ee6f958401uuid: c867a20d-6983-1b9b-815d-f18f8d096c62uuid: cb2a0a0b-ca4a-720b-8c0c-a140de4f151duuid: 1609a73d-6dc8-2607-458c-927301c47ff7uuid: dbbe16b7-17d0-4bd0-f335-76521f48fa77uuid: 1cb048f6-bf29-60a2-14e3-fa2954e6c04fuuid: f230519b-ada2-6e4a-db4c-d446762713e9uuid: b41212e4-6703-c4e8-9f5f-726059c944f7uuid: b31e854d-0a66-73e9-2d11-144226865655uuid: a33cacb0-c5b5-592a-2012-bd2815492388uuid: b15d5fbd-f443-da3e-2c1d-353af0605391uuid: f3973d29-c351-d6ca-a3ef-3cdb89a6aa52uuid: 0b3ca006-4af8-5610-4083-f5050668c09fuuid: 05c41bfd-9e08-04de-c395-2221800dcf31uuid: aebc7d5e-26aa-5cdd-a065-9e2f4caffde8uuid: e6805763-0f1b-22a4-476e-43b02abf1996uuid: 6aeed3b5-07e7-c0b1-93b0-11f60c299db1uuid: 48d5426f-6bbb-1806-c92c-5e78c7da6a15uuid: 2d1e5a60-3af7-6ba2-5edd-feaddc345ddduuid: 1a8ccaad-64ba-f90e-62b0-c4e956fa525buuid: e51278c4-7223-71c3-a91b-aafb7bf164b4uuid: edb276c3-dcce-0f47-a8e3-dcee9225f928uuid: a237990e-3687-3412-be17-5039353f811euuid: e54ab390-69d7-0ec4-58da-364674be5b23uuid: 9dca8245-68d9-805d-d19f-507181560b96uuid: 0307890b-9e57-8be8-8a60-dca249fb9288uuid: 4c3e8f21-128f-4c2f-1d4c-b677bd27f01auuid: e302afb4-4b2e-56e5-2f66-53e471f9279auuid: c1c22a38-aa9d-9239-889a-4c970ce89d08uuid: d34cb803-e4d8-f7c9-a345-8ed8dfdc75a6uuid: eb7883a3-33a3-18ec-f04e-37cd6b96866fuuid: 8f019aa8-4b71-1efa-7c8c-3c05a41e3d3fuuid: 379faadb-3c23-c42a-7462-064b912080b9uuid: e95bea0e-efb0-331c-d774-363290c8fa69uuid: 4d61bc9e-9a00-446e-d093-405e81947932uuid: 3df50c7b-ff55-b499-5698-ba8bb85399cbuuid: e2e79459-36d4-4f8c-f44a-e96945c00a37uuid: 3aa9b3ca-94f4-e721-476a-0d0976ebc920uuid: 94774006-fbe9-f58c-f7f4-bc24b98788c1uuid: 0d22a4b2-10c7-4e0e-e9ef-b1fea1ccf5e8uuid: 485bb3c5-7dd1-112f-bccc-f0c656bcf209uuid: 5cf35cd8-d778-c2c8-8936-0989bda44ffduuid: 0170cf72-aee4-4a68-230b-ba292bb66b4buuid: 8ae39e78-df59-306d-3288-f2ee03579a92uuid: afcf54d0-3589-e5f6-d178-69f70ff8509euuid: e1b41d2c-8c8f-230d-c95e-981d5600031euuid: 340a6b23-6ea1-c5fd-ab36-7d1229f8407fuuid: 13927eaf-79ef-52a7-c0fb-839187ae0358uuid: 37c0b889-429b-cd15-0c54-60fd13e2425auuid: fc9a4c5c-963c-f216-9e9f-5f54b5200372uuid: dd9a5cf3-6b3e-1d5f-283d-f0e63c880003uuid: f3e45c58-3a28-d55b-f182-be5858f8cff1uuid: 4cdf84c4-8083-648b-8ca4-1db4b14eb2f6uuid: 71d40a52-f923-b21a-afed-d26dc1d86ff4uuid: 0186dc83-5278-a92d-f2cf-0777429e1244uuid: 584991d5-e549-65ca-f5e2-70e124f4544auuid: 2f5e6c2c-4330-652e-53db-f3852df335aauuid: 33d49780-6386-1c3f-31f5-b7213caa83feuuid: bd8de1a5-592b-d770-5af7-c2979bd65df0uuid: 3786c6cb-2fd4-85a5-c7a0-248238787b95uuid: c000b4ac-6804-8123-627b-7a46e93cf2a8uuid: 2878295f-2e82-0dcc-78ea-4a11a52e445auuid: 07af9f9b-96a1-6212-0bc5-4e0ded3c555cuuid: 3c8a3f3d-b34c-0513-0a14-499ca8351939uuid: dce6db65-96ea-ab8f-8ed2-a28304f52792uuid: 81fba2e3-4d55-849c-d349-a1da3d8bc0eduuid: 36606a92-5548-cc98-f62c-d8895d6b9fa9uuid: bf166228-5077-a7ee-b81d-6d3e26c89c8duuid: 06a96a7c-2f31-cd67-8ff3-c1b077c0c42buuid: 259a6987-7eb9-9989-2666-997b93c55ba2uuid: f6858941-95a6-5220-a6b7-8ab15b3ae88cuuid: 2e4db6da-aa1c-70b4-92f8-6deec4c64e67uuid: 6766453b-7a17-e5b6-0f5b-1977b6d8e04euuid: 9bff631e-739d-1b50-dd43-e35cf0dc8404uuid: 94d218f0-5f9c-91fb-4869-bc396a2c2d9cuuid: 76e50bfe-014a-909c-d736-6b6d4698daaauuid: 3a6f476d-6f4e-10e5-a2e5-73883c781e2duuid: acae5aea-dc1c-b90c-775e-f592988f353cuuid: bc460721-3281-9f94-63aa-dea5787deea1uuid: 831ad4f4-9a87-cf5f-4a8c-58ef7d6cae88uuid: d7da65fe-8dc4-84fb-7b88-d48e40e5e635uuid: c0976083-44da-c3c5-b338-2b657dadd39euuid: 395af5b3-cb1e-13b4-e948-50de4c1e92a4uuid: d73255d6-9964-0d1a-f34f-b70a7c484adeuuid: 03d7de6d-b0c9-4d09-014f-2eb94bceaa37uuid: 4436de97-e2d5-5b89-58f7-10c0a17d7a45uuid: 394eea1e-a7a7-5138-30fc-2b356adf8707uuid: 813a9cd4-f780-c9bc-4e6e-9c6b7900ab1auuid: 9fe0ed38-c2d4-8436-3895-c6dbe3e0937cuuid: cc00a5df-c38c-390c-8c30-d48a496fb278uuid: 8bac3425-80fc-7fe3-9884-dc9d691a174cuuid: a88f1dec-bf12-848d-3b0c-e0b1c41fd5bduuid: 642afda5-a145-fd41-a73a-5e797e16c0aauuid: b0c26493-dad5-cda9-1e68-02091001958fuuid: fb052aa7-b6e5-e696-cd14-7f472517d81buuid: bf323aeb-3098-f1bb-dcbf-6c0b5c2cddb4uuid: 14e06137-8088-02dd-8ea6-5d37be7c7210uuid: 2bdf97a2-b19b-cb99-b6b9-95a984c48f04uuid: 862d64eb-b78c-a754-5baa-31fa17f46bfduuid: 7ca10cdc-7248-ff4b-8271-363b4ea9835buuid: bc130702-32d2-3840-da37-b0bd70cc271fuuid: 6b9a4794-f112-ed57-bc5e-e17a6c94a3c5uuid: 7abf4a11-b5fb-6013-bd31-0282d8d23a85uuid: 610191cb-08b2-d298-757e-ea9786ef1ab5uuid: 9910c7d5-88a5-68c7-333c-f593db0fdb7auuid: aebfb1e5-4900-645e-ee67-27e1882193b6uuid: 981cafeb-73dd-d99a-99ce-8a2e53d04d2euuid: 970e46c9-533d-c0f5-a728-605304d97e7fuuid: 96ea6c4a-bf6d-45e5-c81b-be5663da2700uuid: af52a238-d332-9258-33c3-53835256799duuid: 8e08eeda-5515-10c4-88e5-b1bde133dfd2uuid: f3f1143f-9a7c-7be2-96bd-4c6d737d3594uuid: 8c94acdf-c477-743e-b4de-c309fa27be11uuid: 2a925da2-e26f-de77-8002-3589665a3479uuid: 5cc989d2-1ffa-11a2-be47-c41edeb64603uuid: fe6046e6-8ef6-f5ef-2fd3-b7fc7dc0dcfeuuid: 0b10a27a-ec62-f88e-e121-c2ec9295f982uuid: d938d22f-937a-ad18-9c7d-70c46da81290uuid: a13ec3ec-b2ea-fe8c-0a77-33e93c409a16uuid: 535689cd-e03e-51bb-7ba7-3d1229c14310uuid: 4d5ae8a2-23af-a806-d38c-09f3931a86a8uuid: 263d2298-9bec-cd42-0129-d0180231e6f8uuid: 8098ea78-9c79-64d6-7f64-b34315555074uuid: 3d5eb50d-5ff8-6632-2505-69a74d31054euuid: ff40fd1c-feb5-1a63-53ec-373e1ec47129uuid: 08dd4ac2-36d3-1650-9951-1833a4dda5b5uuid: 0a818f0f-708b-05e6-f002-09b2aad34d14uuid: 280b5d65-08e8-6ead-df0d-f13f8a8e6957uuid: 794040b3-8718-c900-8e8a-87bd70addf77uuid: a17faa0c-4f1c-f9af-8816-96344e8725b4uuid: 6721175e-a081-7cfc-6ff3-8748a8156cd0uuid: ea16e042-3a5d-af72-8691-166c7418c9f0uuid: 3efa0ca1-a6ed-1cfc-80f5-348e25ba4558uuid: ba886ba7-d6c7-c2c7-8c75-ebc6326ad4c7uuid: a448f32f-de38-af1b-7086-8d543ef5aa74uuid: 2a46d21b-4ab3-69ff-f48d-4afab2a95363uuid: 1d19c816-6181-7e57-e765-c7633837d7b4uuid: 8965347b-685e-eb53-414d-222a8e24466auuid: 81916c2d-2fc0-6bc5-d9b9-a5e43182e13cuuid: 59ac9750-3928-c738-d5c3-e48169dff732uuid: f795c5bc-29b6-53b5-aabe-92f55e73c0e6uuid: 11e0efcd-daca-7935-4102-fc309474e747uuid: 5e018923-9ebf-b1ed-60d3-129322a9021auuid: be83d92d-c29f-83c8-69e4-6bd1699d7129uuid: bab479e7-9725-fa17-c02b-876d2a31bdd1uuid: 4344c62a-04a3-6b5c-3f0f-3a88dac02989uuid: b815ba50-b7f6-1d1d-162d-cdb91220a90cuuid: c9b2e91e-a8ac-67dd-23e5-2e520f494ed5uuid: 6789cd07-0edd-672c-cd6b-5519f62e1e35uuid: c3524f2b-099f-dded-d048-71dc89198f1cuuid: 70ca7c84-4ae4-c15c-9c18-0e52dd387c83uuid: 9e6e99d1-5cb3-ae80-9a4c-e29b25e4a7dfuuid: 5fec945c-186e-daff-9978-aed86a7ee9e9uuid: 5eb3988d-002a-85b2-8fc6-5234ba0de092uuid: 45755918-d9ac-fd29-ab69-8ad22706fbafuuid: 7a5ba9b6-e516-f8a2-e71e-f75b9c8c494auuid: 77835e2e-fc2a-7ec7-270d-e4a02c0f1f68uuid: efb262bb-8282-8cff-983c-a433f1de75a0uuid: a0243ed7-d2de-7319-25dc-44e0663b4366uuid: a708519a-6589-c245-0eaf-4c3aeee06b9buuid: 977f3364-be32-7b7a-62ef-8f629f07359euuid: b24ed226-8707-3187-b0cb-b589d856895cuuid: 47c01121-29c7-22d7-5748-c34e274258c0uuid: e32fadf3-aec4-8224-d167-2961c03bb6ebuuid: 5f01becf-75f2-e907-ad27-653f88f76928uuid: 79d893f5-cabe-4bcc-8cd2-b78e280d6abcuuid: 25b34131-c676-07ec-ccf3-96c94e5e8ce8uuid: d9a17cc9-6e6c-d262-195c-347ffecde7f0uuid: 115ed0e8-113c-d2d9-f397-ddf4db10b7e2uuid: 4bea5b5a-b7ad-d73e-72b3-ee7de6e1d532uuid: 8a0d09f6-a070-1640-e698-b23275d5cf0cuuid: 20e03f24-44e4-8b68-85e1-1de76c28cb72uuid: 154e2a51-1372-1a18-a04e-643644f7a7ceuuid: 34f157e4-366c-c4f9-02bc-94bd8d2b4e21uuid: 7a3ecb3a-e6e7-8c2a-f829-859ff804fa9duuid: d8ae3b26-2cc5-125c-2bb1-8a8af887b96auuid: 191224d7-745d-d230-53d2-4cf51cd534d1uuid: 6ec259db-67f1-73ab-29b9-3b7ba0e3ef6duuid: 3a474a1d-9b8b-4561-b7bb-4ad3013c32abuuid: 44af7f62-a8e2-ff3b-2e0c-847d33224baduuid: 624da6b0-5b92-b261-0b4a-36b98b4b06c7uuid: 81549344-53e9-1124-f514-2a865b69e4b3uuid: ea71100e-8f9c-44f4-df39-0110c8a2acfeuuid: 6444d2a4-f492-66fa-9092-23297b6f341duuid: 970d32d4-fc8b-01b1-5afe-a32258a681bduuid: a89dcf8e-dd80-7003-4dd5-4e11d8641fd3uuid: 00300c56-7d5a-0df2-3e2e-7a4bd4cbba6fuuid: dab53b84-f900-89d9-d847-8b9b33d64600uuid: de034c00-f9f7-1a6b-5c55-4fbc8dd9f7aauuid: 19a73331-dddf-b5bd-f5c8-034c8c36fa2buuid: 4029a3ae-2c50-bb16-17f9-8555b3dc042auuid: e09847c7-827a-2873-0127-db3dedfe1399uuid: 7ef6e673-6ecb-92ab-187c-a9ee8275fa40uuid: 2ea05a34-a45f-fa84-6ee3-4667e7a81717uuid: 909a6371-2472-cbcf-0328-23c08e41e752uuid: 135e26f1-8852-b867-2a2c-d7ff33b052f1uuid: 242fe67a-4221-1fbb-f1e8-13bb4649e8d8uuid: 4cd5bee9-72e7-3a71-c242-fd3b8a23df92uuid: b1c01395-ea12-1858-de3b-c54175fe8829uuid: d6d4d45d-605b-c5f6-210b-bd159e4e66e5uuid: f64f3a3c-535a-7081-5c52-cb3757c5778euuid: c017fde1-5987-2ae7-e56d-b6928ba3c3c9uuid: c47bd34d-c60b-f446-b397-7277e099e6a2uuid: 3390d97b-b2bf-c761-e2e2-c566e7698554uuid: 56d0af1b-1f38-2d7e-8727-7141ee3b62d5uuid: f521fd31-f5e0-9361-9b72-f304f0bfd213uuid: bcb296aa-0417-9f66-5152-70c5d534424euuid: 22c46907-a34a-209d-0846-ba0887161eb0uuid: 24c09083-c09d-70ac-0bd4-b45ef94423bbuuid: f73dc306-6d45-964e-9402-2c859772ecd5uuid: 0c371367-bf3d-5471-f6cc-f320abe2abd1uuid: ebf78303-ebd0-27bf-5d29-11d8a904523buuid: 52e32181-450e-910c-c1bf-f4cddb758f7cuuid: 24d3f827-51ad-fdb4-8539-1d780d075934uuid: 5ec513f4-36c3-a5c0-7bcf-44b981d1f851uuid: 0d568f35-30b5-a830-9943-a081ce27b789uuid: 35560e34-c78c-5891-4022-e195ddd5b230uuid: 9c81e8c8-c3ab-e167-d6f9-4cec439b4295uuid: 00aa4294-05e0-5005-dbe9-30fb46fab48euuid: 8042399a-f51e-47a6-fe45-fe9eaab1960duuid: 947f0954-10cb-3f3a-cf6e-3d092439ffceuuid: a5422438-cd9f-d4f5-fd6b-5297f6388d87uuid: f0524c2d-b46b-09b1-69db-47e9084482e8uuid: b885ef56-9450-0927-ea43-a34d0b77299buuid: 219b01b8-d648-7e1a-0464-ee26e3259d63uuid: 8c752b51-f890-da7b-c1c9-a521f58295eeuuid: 860e09a7-cf8e-ec48-05e3-be6948465ba5uuid: ed2ffa51-e165-d87c-1c04-c62b8398ed43uuid: d937ba42-6e3b-ed60-756b-86c5b8a5d900uuid: 351e0894-3e69-ace9-5919-f0cb6df0f4f0uuid: 0e4ba81a-c608-3f6f-a78a-f7fcb5498691uuid: e88fcf63-68fa-e949-2ad3-2e2ce9231816uuid: 9015bbb1-934b-57f1-30e5-98ad07e6120buuid: 5b2b818d-31b0-4b35-34a5-2835aa16e618uuid: c0548ff1-a0ca-12ce-3704-3211e9e93401uuid: 9988e382-32bd-fc9c-f549-cc69270319b4uuid: 388092d7-6a43-6379-841e-65f19d6309f2uuid: 66cfd066-9ef3-7504-3279-e89348802698uuid: fee93a63-066f-ca5d-7d5d-6fa0acc804b6uuid: 467404d1-468e-47ed-b550-97e93ce346f2uuid: f2ca2712-b262-2465-a1dd-4ab9a0b7d55fuuid: dbc491c8-11d5-d5d3-2600-8d3b95d70d4cuuid: 110080b5-cc6f-d66f-a5bc-eb8dc2a6a1bcuuid: dda4195d-3e0f-a469-dcb5-e05de5fa450euuid: 87c770cd-cc64-a2f0-646f-ecbd7aff3d9duuid: 2ce66332-b826-f6d6-4c49-8d433bad9be7uuid: d1f66bd2-b1ef-8ba5-6a10-a256c999ec24uuid: 575d6de0-eb63-9245-61d7-ade6d41d2ccduuid: 34e3f5b3-3909-1902-d4cd-f7bfd036b3d0uuid: 517c97b9-ff03-10bd-00fd-11fbdc2f3a67uuid: c713b70e-8b89-b1d4-e03e-1729f93cf4a4uuid: 0be277b1-29f8-0f1c-7075-70c56168d130uuid: e7788914-cc52-d8d4-bb5b-91074afc13b0uuid: 0742b306-80b1-1be2-1133-71f08e212d5duuid: d17987c5-fa5c-4009-9192-6f9e2f447aefuuid: 2ff1c404-9488-0153-c0a2-4032020e6ccauuid: 67e7ef41-eb2f-1cbb-830b-0c59581a8f2euuid: eca56fe8-fec9-bd0b-054b-a15c81e67d61uuid: b3d49c52-d248-65e0-aa4b-c366a654fbdfuuid: cae0b644-b598-3f12-0f45-279bb5a02d2buuid: f87952d5-84e9-bdd6-21b0-23ca0dc65b9fuuid: f9ce3640-8f6a-2751-98ef-a75487f6bdd6uuid: a1a722ef-f0ab-f76c-01a9-a1eeaa44045buuid: 4b480cc5-58da-c45f-5215-f236fa5642eduuid: 52c9b2f1-d3d3-ee97-0549-ea0cada0a475uuid: 69ad1c4f-4778-a705-7231-a17c0aaaee85uuid: 2c7bbe28-89a7-2b6c-584d-c617ec3b0c49uuid: fe13ee3f-991b-5efd-03f2-b89d844cad27uuid: f245cdc4-c1c6-955a-1da4-2ca57962526auuid: 39e59a19-adf9-47d7-553b-cfd602c121ccuuid: 94070844-1daa-8320-4ab0-0f13b86ba622uuid: e5f1e247-ff77-c3c2-dfed-45e944a6d077uuid: 286a52e2-2d88-8520-d629-7ec93bf18e0duuid: 83b21230-5836-5a2f-9b48-1fb683c2446euuid: e08b27c8-17ee-81fb-a243-e30a489ef11cuuid: 2015f0a7-8741-f61c-c9e3-7af250b8221fuuid: daada616-8006-dec0-d21c-0fd185208222uuid: c87f88e8-7375-c25d-d55a-c5d2e718b6eauuid: 410c20ca-44bc-dbb3-d8b1-4f64b5bb7224uuid: 76dc6f2e-031a-418f-5a56-64c4df263f48uuid: 9f27ddcd-0285-cbe6-1711-e28826a9ae3duuid: cf10bd2e-de27-3bdd-88aa-fb0fcaa1ab51uuid: 702dc8e2-e22a-537b-f496-66af21b33a4cuuid: bd612f20-6a11-4efa-e2fc-850e146e3325uuid: 9603b8ec-51a9-caef-5b70-b9eb01620989uuid: 934690d0-4cc9-484a-9b33-af5597ffe5b6uuid: 18bcb01e-682e-0c86-2951-10fd5e12a932uuid: 0c288eee-c9f7-2cfb-9149-daaf6c9d32efuuid: b745bc77-e566-1d22-14ef-6f9a3fd8ad0duuid: deab0807-29e8-4519-8baa-e49945167f76uuid: d7222b64-9540-f479-38d9-ccf901fe9a59uuid: b3b019e9-e33b-d21d-6d96-73e3c1f99091uuid: 3239ec73-dee4-e2fe-c2e2-f23d60253c0duuid: 9266dfde-eec7-743b-871f-1a9d5bb40035uuid: 967ac3d7-678f-2014-2c21-f08e5ec9b1d2uuid: ad2ed486-2f7c-1f6d-36f3-00b1ae4bd4eauuid: 534163df-1efb-f7a3-e2d0-31c4d77f07fduuid: a787ab53-ad52-45ac-328a-7f6c16407971uuid: 057de371-69cc-93b3-df56-b2990bb61662uuid: e33a493c-6bf3-7b48-7828-22faa8112363uuid: 0342ccf8-37e0-e7bb-11f6-4e901c0cd761uuid: e8a2402b-ea3e-14a4-0d02-09e7044ebd46uuid: 9b795d7b-21a5-60f6-13e4-6f20dc73262euuid: 6d6959ef-bee2-1419-ba59-d828a6471166uuid: f502d0a3-8817-b71e-4b02-863e4762408duuid: 7bfb45a1-5ced-1666-d41b-570ec04de836uuid: f7ad1625-8dd8-4703-8757-add6f9799a60uuid: a7f5253f-f784-1669-dacc-3e70d9576ce3uuid: de83de97-4955-cfb6-98fe-115e755e5c0auuid: 8ce8161c-29c4-9fe4-bcbe-09d5bdd3771buuid: 8c7a7095-b9e6-b167-b95d-ebad92bd11bcuuid: 13a2f712-ea86-1c8d-8bd9-7dc1616a095euuid: 07c6add2-406e-b597-c132-d00c6636b814uuid: 2fe01c40-9331-c186-a059-a240c0cb8984uuid: ba51dbb6-6206-6117-39c5-51c4c8dac897uuid: 3c550c24-5d73-95ad-c243-8dc9e935d589uuid: 33013fd0-1e8d-fe57-54f0-e7366512d9b8uuid: 500ec3ff-867d-97bd-3ea5-9dc8ae2aeba6uuid: 364fa326-cad3-4ae1-8b50-c8e27feee3d2uuid: b8823581-7ebe-b32e-60bc-718e255b7d78uuid: 6c71099a-6ffb-abbf-5e15-f54eab973643uuid: 1e7c513f-7280-2abf-a51b-ab7d1588dcc4uuid: 83f416b1-29d1-e361-6e1d-5e6fd51b2396uuid: 55db075c-505a-9547-7400-44a8a52aa1ceuuid: d76db68c-91c4-d772-f2e4-c64d35bbe773uuid: 3e36b74f-6afd-418d-be4d-1bdd4f34c387uuid: 573ab518-dd5a-5631-fc1e-426463a089f1uuid: ceeed65d-b73a-c6ec-ae66-0ae1d6b10244uuid: aeb79e89-6aeb-0b21-5cc7-1e4ec4b40007uuid: 008fb938-e5e5-8884-f84f-c6c315310166uuid: d44fb650-d279-c910-0844-4f94d5d9cefduuid: 2838e034-5e6e-f27b-2b82-cadaedfbccc2uuid: 67b265e2-41e5-967c-3773-787d296f1454uuid: 7d27bf50-c246-33e7-0070-abc643046e54uuid: bd980ed1-1756-1712-ec8e-159d247c619euuid: f163b660-d29d-f9a0-ae32-a016917c7e13uuid: 9e157d20-a5f4-4c42-09e2-dc8323f2b95fuuid: 33fd7423-47cb-4787-7f3a-3e6b3be1a119uuid: ed92d8d8-265e-d3e7-e71e-c5f8c59edd15uuid: ed121d7a-f6c5-c323-787d-23796673e4bcuuid: f5b4f107-1e31-4c83-020e-05097dec0e3cuuid: dbb0a7a5-0e21-9a6b-1682-839cd82ce293uuid: af098eae-f79c-9ec7-e1d8-6fcdde56af1auuid: 9ac28eca-452f-5142-d451-e1609f97e2bbuuid: 7125bc0c-87d2-440f-76a8-2b825ac7bc2cuuid: aae7e051-8764-e305-72ba-ffdf5686ea51uuid: 9845a3de-aa6f-bcfa-5dd9-dd9b33de0f3buuid: 57737b21-b81c-a8a8-bd0b-dd6573162b48uuid: e5c4a098-80ad-1143-8b74-ee9fd250de0cuuid: 1a2ee7a3-3151-116e-7270-1a351c508985uuid: e9065a70-d7a3-41cf-7011-d9e24974333duuid: 617dac07-958b-0fb2-cbd8-79e2556229ecuuid: 939f9e02-4db3-b609-84f0-475558cef759uuid: 09a0a49e-4945-935e-15ec-02835acac3dfuuid: 1f9154ba-4a93-e6a6-4ca3-38ab945ad699uuid: 64b0fe02-d867-c027-47d7-7e4e6e14ddb2uuid: 854f1e6b-4b79-10de-cb00-ee4f61f1fb6auuid: 44e0fcc9-857f-65bd-7005-691680e3db43uuid: 1ced354b-8be2-7839-fbee-c2defb649e5fuuid: bae4e61d-bb15-a67c-7681-cdaa2b5f4f96uuid: f724b55f-b630-e0d9-be05-5eb9a292f6bduuid: 47f83421-9371-b825-2f1d-a6de04edba9cuuid: ca51bd23-6432-344a-0c77-f1b6295da9abuuid: 334c929f-6d58-fcfa-178b-8b1985316609uuid: 34b4d184-12b3-0eba-7de9-cf7b72326b2fuuid: 6ee41162-daa9-e375-c5ca-0a424db8c518uuid: 0f4c266a-a421-554a-95cc-5f67eff2c61cuuid: 59fa057d-1d12-5207-a054-ca93676e769cuuid: 992aae87-b22c-a522-5d7f-a46845b33870uuid: ed56ea1d-b8c7-1c5a-68f1-da0d5698030buuid: 9093be69-2ccf-e156-9fda-f3b73716f1dcuuid: 8fc2de7d-8dcb-d926-6a90-20a95d9369fduuid: c64b6c0f-40cb-c028-1bd0-fc5743d2ba6buuid: 4814148d-dc1c-d444-6a43-7a5678ca1188uuid: 944fa829-dfeb-ffd7-465a-f1040232ccceuuid: 96ba9da4-39e2-4cb4-1208-be74819cbb97uuid: a94248c0-8165-eddf-48bb-38d75d6d904auuid: 12242758-53f3-cc85-3155-66bcd410fd0euuid: eb8cf5e6-f7ec-beef-5500-a1b688567da4uuid: dd10bc68-efdf-c34a-c51d-3e1d8c3f3b66uuid: 4b427258-519f-ef01-deee-d74fc73457bfuuid: 3542a05a-1848-8dc7-61d8-8f0a057e3852uuid: 2937ba44-5817-79a3-6cfe-27ba820c771auuid: 7bb77c3e-a06b-b8d1-eb4c-a5049820ce14uuid: e4bdeabe-8594-4c68-f0ae-0b78b2021192uuid: faa0edd9-2eba-613f-722d-0297a8c5b95cuuid: d053c64b-9044-ede0-c1c2-abab19105ce7uuid: 66977ca5-36f7-5634-1b4c-3b24ea46c42auuid: 9cf67e7a-2a63-0c19-4600-c4f59d33a306uuid: e181245d-97f2-93ce-685e-dcdc83b1b6dfuuid: 8f395d98-0a1d-aeea-b6fd-4dc4217e6ee8uuid: ded72934-0ef9-fc60-7132-eebd4ca5d863uuid: cd9b9b31-ec55-71bc-8be6-9bb9bbae48c7uuid: e977f5b9-692a-fb6a-a780-c1cd1bccaaccuuid: deeaeb31-710d-bd88-2a05-c0a789337271uuid: a2ac1739-ce5d-a68d-c687-f90f89308958uuid: e29a48ff-dc54-03b8-e3d0-5250224049f0uuid: 398c916e-0425-5fcf-fee4-87e2c5c99467uuid: cb60810d-18da-1e83-c0f1-f88ae1ba231buuid: 828896b6-2f4a-886c-8e9d-af09afcf8d75uuid: 8165d4a4-c0cd-14ab-4dfd-2bd7d585810cuuid: 6700226d-f3fd-265a-cbde-cff32178cbf8uuid: 68b2d025-7285-f175-ff33-601fc36fa48fuuid: fc4fbd98-0b35-206b-5894-bdf1a3e1bb12uuid: ad42dffb-5810-ed2d-981b-1c95c056eaaeuuid: 864182f7-2b5f-b8c2-d2ca-ec69c47b54abuuid: e3a1732e-c7f1-873c-6958-d153b47b8b7duuid: d0d0a8f6-5e06-21f6-1f99-c1fea2812124uuid: 2141022c-b366-d00b-9cb0-977b6d1cbc3duuid: 2aaa177f-4e4f-7c59-dab3-e8caf1374830uuid: 1f41c67b-c25a-c482-ce9b-70d4b8790f99uuid: ec22e2cf-79e1-2e5d-08a5-10f885e76fbbuuid: 72394b16-a5c8-02f4-bf3a-2b3d1c0d03bauuid: 33c46244-c647-e33b-5c98-4db8773cd7c3uuid: aad3f496-d7e4-0fe7-c06e-8cf9b327b609uuid: 2157067d-4647-b0cd-153e-7075bd1e9fdauuid: c8313a06-cc82-57d5-706c-b5b0376ffcb2uuid: 61bedaa0-c627-58a9-f211-377729541e1euuid: 8e642af2-406c-71af-0832-daff6ea55d70uuid: bd900016-8f1a-efe2-0f12-175b2017e7d5uuid: f8a19a7f-3ffe-21c4-b245-077c81383e8cuuid: 3aba3bcc-66a5-779e-7fce-3e9059f094c4uuid: 41adffc1-ca36-49eb-df08-b1a9fe53ed59uuid: 90f82091-9cab-2d6e-f8e2-320184d5e1d3uuid: db826463-df55-91fd-eb0c-61168869cc88uuid: de135eeb-c1de-22ab-9630-3add16ad2ba6uuid: 20f2cfd6-e97a-cdb3-eef3-ba4c38fa9129uuid: 68450b0f-17e6-1322-0bd9-9737d8258990uuid: 2f8ca7d9-f143-505a-09e5-6850a54b4224uuid: 831acadb-8751-68aa-3dde-6d7ca7c088c4uuid: 4068710b-71af-eb8b-350e-45a23ea2f303uuid: 315e621d-9153-0827-def9-11f3ea1b182auuid: 9ce67450-5861-5682-8096-a7e0e5319b56uuid: b067974c-e007-50b2-0e6a-00f14fa9c931uuid: 47a69101-c776-b7d8-9101-66ad74ca0582uuid: bf348811-e956-f239-bd7d-9030600b2ea2uuid: 380f46fa-f56c-2969-25fb-0e847dbb7bb7uuid: cf4770dd-7fa1-6714-29a4-9a1a1bb68d0fuuid: 27198d3c-bda6-94f3-704f-74f53eb14e2euuid: a2ad3911-3bd4-81f4-3479-3e1443c84f69uuid: 4ab3d14e-074a-4571-ba99-30dd2839c122uuid: f44c181d-0ced-6074-4905-b2354bee52fduuid: fae8e235-dd95-2369-bdc9-88f1346d3538uuid: 53a1a579-71b1-3432-77fb-1be4532fbfe5uuid: b1cbd2fc-1f85-7d1a-10f8-e4381df2a2d8uuid: c8ee957d-ec9d-62eb-1400-6946137bbd77uuid: 2b5a16ee-c9f4-6a5b-f101-32fdd901a19buuid: 1afbbac7-0071-b75f-7dad-d1b30e22885cuuid: be1675d1-87b8-81da-0217-7cfb5b9ddaaduuid: 8217de69-ae65-38c3-6689-06fb37268f9buuid: 268a4f73-b3ac-3a2f-a5cb-724d908c3ac5uuid: 0b666f46-967c-d07f-e5f3-956cfd9ea1e9uuid: c77bca23-f640-2c67-3a21-da8b08f7c342uuid: b953ceb9-d7a1-4729-d436-92c1477aeed3uuid: c497bd80-fa3d-84ab-3b54-c51d589d34fauuid: 3c315a6c-e746-fb5b-b645-adb5b18c644buuid: f5ae1478-e699-12cd-d8d0-9c1806003757uuid: 4935df3d-a897-6689-d910-a230ca25aea9uuid: 7c633f39-f1ec-0aee-9c89-dfcc950e8d0euuid: 138371cc-4966-0995-3b17-743c81d7f430uuid: fdfb94b9-9f08-ba1c-0ded-c2f07322c74cuuid: 5f3b0607-dc78-1c51-0a51-fff3ae1217f8uuid: 963369bd-bab4-18b0-41b4-676d07c34b9cuuid: a2f89c62-0537-2f1c-af92-227bf359739euuid: 8e4b57c7-5e0a-a31e-5a00-d6a724aff3e3uuid: d1e92aa7-0800-8b70-f2d4-ecb8b36bed11uuid: 62ad8b43-07a3-a994-db10-dd7e75ff5098uuid: e4dc6630-7005-1081-4cfa-829970ae3232uuid: 3feed968-5aa8-cf81-e687-62fb3f712ac3uuid: 84aef7d0-9981-1936-896b-9a83ae0d7848uuid: 5beb493d-e9a9-865f-f6a3-131809b8d246uuid: 379db770-f885-90a1-60f3-4a623d1d0671uuid: 32dc0957-7624-17dc-0c13-6d8fe4e28d31uuid: a7f59129-aa00-ce14-5ae8-03df1fd8f8a4uuid: 60f36556-2ab4-f2ee-60d9-3134143f284buuid: ac093743-5764-09e3-9f0b-08944e5c8302uuid: 59f78ee7-7003-7596-92e4-fded24a419beuuid: 4b7a76c3-06d6-274a-c157-3ceb44d139d8uuid: c1486674-ce36-d67f-ff3e-676d6e3c41f4uuid: da878bca-f054-c141-c8fc-1a712bc3c6aauuid: d6599fc4-f5d5-4a9e-02a8-5d3e924a6bdeuuid: 4c70cc72-55c9-59e5-6c5d-0f20d2df2ce6uuid: 784ba66a-65b5-8611-36e0-59f40ab339f1uuid: 5bcf0858-e38f-7def-cc5b-73b6b6c1ff6euuid: 9812a617-86b7-89d6-a1bd-9ed3d285c250uuid: aa5e785e-b8b0-303d-192c-ee3b4bd49761uuid: 917694ca-9122-425b-c6da-df581c1cd7fduuid: dc7ead0d-2d68-5caa-7a53-389ddc53c2d7uuid: 62ff983e-f1e9-cc4d-c14c-a8ea90fcf24cuuid: d99a9518-b15d-72be-6891-137b3a3f4ad7uuid: 4bd7ff40-dae7-0019-884b-0e85efdae90auuid: 4c4d27d5-73bd-78a0-e024-14ecca017fdeuuid: 645918b3-1f09-1270-58fa-59a985bc6073uuid: 1935fa7e-bf4c-0bc7-4244-1139a75b9d64uuid: 492fa1ad-c719-c4ce-8a30-5cc5c7457a37uuid: bd12234d-0177-ad00-40e5-d3bac4671d35uuid: e3418603-6b5b-39c9-601e-fe452c56f4e8uuid: 61cea180-c1ac-2423-6133-34db9030e5aduuid: ad39dcc4-a395-7c00-790d-2a80027879ecuuid: ea57f785-524c-6eef-10b8-56e96b216537uuid: 00edbdaf-048b-dc60-e0d6-115f86156628uuid: 3dd0e216-c77b-b0d4-d74d-3be74e4872b0uuid: cf366db2-4034-66cf-6fa4-ebb54657b7dfuuid: 66f3471c-1abb-59bb-5238-d74503fe2161uuid: 84a1f552-8562-0782-dc0b-517adedf72acuuid: bd5e6468-e0c7-ef78-b71d-0d844e91f68duuid: 357de1b9-b6b6-e205-50de-bc1b599ec9fbuuid: 841cf2cf-3c2b-557b-e00a-20d6a3b4dfefuuid: b42ab16e-a029-c3cd-a797-ceabf2136540uuid: 2f8cc3dc-2437-7996-53a8-48c34b2f8b8cuuid: a51823e0-3c09-58f9-8a31-de0772aae9f1uuid: 46b074f8-a481-29fc-cb34-f8046b07d774uuid: f2c2df8a-26f7-fecd-ae75-f9f9835f413buuid: e118f646-f828-ddae-978c-eb138b549ab5uuid: bbcf98a4-a213-9237-c973-057023a7367cuuid: d3b98868-45d8-dce5-5b95-0b3025663f7cuuid: f8c0482b-4521-6dd3-c19b-d2711fe9de39uuid: 3fa9f9ba-8d36-c92e-a512-3310e21ca7d3uuid: 0209c72e-219e-6c87-ea1e-0ea2decca02duuid: 29ad98a4-5a9a-a5dd-184d-b3d5579a201euuid: abedc6e8-8d79-8d29-495c-2fcd42079d0cuuid: 18288873-80dc-ac19-ff57-a20affdc1a0cuuid: 250cb3e9-616b-1235-7697-beb8946a552euuid: 1b2d6740-ff7b-7ce0-cb88-c73857763525uuid: 05054a9c-03d1-2d13-dc88-238362b3fe5auuid: c0faf309-8192-43da-317a-51b314906159uuid: 26b29113-bda4-7e30-97a4-66baf41401b4uuid: 2d1caa02-24c2-7f2b-a7eb-69e950d57e7cuuid: 6eea78ff-35a0-f48c-5938-1d17ed3f7e5euuid: 97dc1867-a411-c3d0-b5b2-11a385b6ba79uuid: 8d815fd6-3665-3bb1-5d36-2d8bdf191b42uuid: 6c261e90-3e0f-701a-4d00-fd469c1459b6uuid: c2025add-2ea0-98b6-c4f6-b962128e8d4cuuid: c50c87fa-935d-bca1-4ff7-ea18ff7afa98uuid: 96a9435e-3dae-56be-5c61-d2ca796d635fuuid: bfbbcd25-c140-a635-9075-1045c3c8fff0uuid: 537defaa-50dc-d379-b71b-4a8a2547f91buuid: 2936aab7-f8bd-c04c-470f-9713ca37eb2duuid: f0fddad1-1849-d40a-f3b0-25ea571580bduuid: 16b40b0a-2376-819e-ebe1-fb2809b02e35uuid: 79a0c728-34d4-3360-e902-a8ef772ec745uuid: 9485a676-0d35-79b3-b5b7-f476287be7c3uuid: 70c6dc28-94a8-8eb7-7e8e-4fb6f628fbb4uuid: f8c573a9-a05c-a53b-61c2-f36f5b2f3eeduuid: 5c33e11e-8b66-b3fd-2b52-b42cf773705duuid: a1e10494-b327-08bb-f639-0d9ed191e712uuid: d51dbd2d-9498-d50d-0bcd-f9efa72bf7feuuid: 0190dee2-c9d0-cba1-7dc0-ba5e5435ed11uuid: ff8b2b6e-e44b-8cf0-ceea-677b9e3c51a9uuid: 21cf8c78-2109-eca4-9c17-36a4fed12823uuid: 4e9620d2-67de-ad03-cb72-6efcb4e27ac6uuid: 17205c65-585a-3792-2bfa-26c572b9cd33uuid: f0b6f883-06da-bcef-cf4e-a0d3641399f8uuid: ca47c3f4-7464-9f34-16c3-ac0a21a1b2f0uuid: bb073978-9e8b-a8ba-8665-32387cdf8db5uuid: 4ee7233b-d66a-6d54-3366-11ea17793e9cuuid: 6093ed89-a3df-e0bc-5a39-3e032481094euuid: 940246c0-4e4b-4906-d603-fa628a820baauuid: 1b6f498c-a3b0-fa0c-8310-0dc9d4fd7749uuid: 7fc9bdcb-afb3-752d-8427-d14be1b08a7euuid: a6c19ab1-c80a-f1ac-8285-d40e6bd8e4dbuuid: 3d9f9513-c02c-e429-4246-38367f40143auuid: e8c54385-8e63-1b5f-b448-83e023e603cbuuid: 95c21a06-1df4-2aae-9255-4d72d5a73252uuid: 713360b6-c3a5-857a-4db9-68fce9780005uuid: c35a3294-6191-618d-78c9-87dcb8416140uuid: fd74bf6d-0c8d-90bd-f3f1-0cb11079dd73uuid: 1715fb2a-ad20-ad79-6f36-2d66cb59f3eauuid: 577278d2-4196-1e22-29ed-248f9795f1e8uuid: e438973a-e182-7fa7-2ccb-9cefd3a8a9d9uuid: a804db4e-a902-1369-bf2b-654c7ddaf940uuid: d2e82f16-8f71-14ab-0ab7-8ba312f32e07uuid: c70c8fb2-922d-ce81-a468-e4e0a91d0f8buuid: e4a20d5b-1fa4-c49a-24dd-c4fe198a0650uuid: 2ae781c3-234f-dac1-93c3-5c99ef5d4e54uuid: 884cfb50-755d-07d2-557c-28536deb744fuuid: 2f8d27e7-87eb-6160-3b40-ed7845134fb6uuid: e951624e-e5bf-52a8-af8d-130a8ae78965uuid: bb866bf2-f1e9-1077-781f-aacee218d4eduuid: d673e90a-f6c3-c86d-ac02-b1e7b6af3d0fuuid: 0b54812e-8868-8e43-56a3-c4b07583f61fuuid: 89f1130a-e29e-33c2-bc70-b761390604f0uuid: 410b00be-c992-9b77-1806-e8f9c10c2b24uuid: b3df82c6-87ca-ead0-fafa-7c45b4187d3buuid: 789dd2b3-cc37-bcc1-08df-c8d2ea7444b0uuid: dfbe1687-6c06-35ab-840e-3eebba04b672uuid: 7d2787bb-3b77-7b23-b720-5527c0a2b113uuid: 321d808e-4d6b-367d-33c0-3ac51f40e9cduuid: 8e94d667-5212-938d-ff0f-99ce62e1134fuuid: b23cb424-f041-0902-fb09-56bcde2f8f36uuid: db2937a7-8e01-7a46-c0cb-8b0470fae6c3uuid: 6a78700b-93b9-02a4-1f23-7b34aab44121uuid: 7a34332c-7fd6-a02c-1774-927fbbd3bd2auuid: baa30af0-99d3-c919-4226-0db17d281f05uuid: ecdc9657-93fc-a726-52eb-7899ee94315auuid: bd15c69e-ff56-d6cd-8193-51ac04849946uuid: 5acc141e-5178-ab7b-ac26-e0d2c2727a7euuid: 2f725fc1-a4f7-a503-3869-2c06eef29d3cuuid: 9ef61a05-825b-58a9-b3c0-562217855e9cuuid: d29a80ec-a395-cd68-3d9a-b6f587ae337euuid: 9b99ea01-8d1d-d927-39af-6ef3989a705fuuid: a16b3dcb-f9ad-3ad4-0642-c604633ecc77uuid: 9532b7b9-458a-2709-201c-6e6d66f96b96uuid: c3da5315-57c9-2369-08ad-f65d5fcda625uuid: c10e6995-0b76-b399-8c9a-c5b3c5b3e21duuid: 062c6a91-a88e-5ef2-1077-d13dc187bd42uuid: e46dae58-3e07-3e69-fc72-ac8d6285b6e7uuid: c62c4990-0b72-04c8-a37e-a1d2c6105063uuid: 2daa7bdc-2ab8-4db0-c207-335aaed995b4uuid: e99942af-22e5-fbf0-e24d-1559c3345b48uuid: e4e08960-4559-8cbb-4f13-4392c65f2759uuid: b19f1991-1de8-c6b6-de6d-0148bbb23d5auuid: 7a2afe8d-8c01-c797-0091-b1dc6e775a63uuid: ed7e8865-5ff7-a5e7-5d6a-a2f87298ef82uuid: c6e517ab-f63a-60c7-5c12-af5c671df4c9uuid: 005712c9-b20c-1e5e-57a1-90d8675b380fuuid: 1709de08-8df6-c1d9-9d61-7cba31b679e6uuid: fecee110-37cb-771c-b222-8a054d9d03efuuid: 60c24203-6c86-5897-cc90-dd8629bead4duuid: 7253a1cc-abea-8189-4e2e-0c8fa26eccd2uuid: ac603653-eedb-c089-6daf-8bcd2cbb99f3uuid: af938abd-0b8a-594b-fded-60cd1b90abd0uuid: 13b11fab-1f9b-0b10-5566-d1b7eeee15c9uuid: f560a452-3e9a-466f-66f4-7f27250223fcuuid: 69c08a5f-0b01-4118-85db-241094b859b6uuid: 277786ee-3fb7-2049-0089-94a48330276auuid: 2a2e0829-86c6-476b-2361-f99609a8a274uuid: cd044905-9f91-7474-5144-68c3667ccf1buuid: dc365410-7f69-273a-0253-600e35d92a5fuuid: c256901d-da46-07d2-1dd7-fde45c00c2dcuuid: dd8d13ac-1d6f-c6ae-df97-ee89f23e2618uuid: b9e0650d-e574-4fb0-3695-4a8b1656f837uuid: 08891a92-252c-e0ae-8d98-7e75aa21ec5fuuid: 18fc08e4-5933-906e-2508-cbf3eae0159fuuid: 7c89d869-80bd-ca2a-9a15-c0e9253f20eeuuid: 40b5eacd-2a1c-a04d-4052-b76c67cd40a5uuid: ec355962-7a8c-8a82-2814-7ac4fd2bae8euuid: a3e09fc2-0247-9683-7831-aa5a0bd50d66uuid: 958b279e-80ea-036d-1487-20edd9ec1ff6uuid: c7ac5408-a067-db1c-747c-109efb8e0702uuid: 5dbe0a55-4fec-aaac-610c-95e7347cc1a5uuid: 5c3ed4f7-7d8a-1704-00f4-e9243eaee9d7uuid: df16984a-ac7b-65b6-69fb-55df5634ee65uuid: 7acb5575-b45e-897e-f270-b90c969e1acbuuid: d1615507-4530-f9e4-37d4-25883273120buuid: eaf7fe59-3b31-d3a0-7a24-9c9141ed17afuuid: 29b30080-787d-1286-12d4-c5fc5b3ccd3auuid: 5c61db20-69d4-173e-884e-9628b9bb1d82uuid: 34d174cb-e135-d1f9-4688-7b9e9df049e5uuid: 854aa1a5-e82f-38de-fbce-e8b104b28f79uuid: b45e14a1-8145-4649-d49c-ef0c1b88cd60uuid: d3a872c9-f1f9-429f-ce52-1fc0e1d31696uuid: 67f403a3-1c06-c376-410c-1d5c7370f194uuid: d13128da-e6c4-a1c1-4646-92289e74af4cuuid: a99ca1bc-231f-c89c-86ee-128dfde80a45uuid: b4088f7c-52a2-b988-8c45-be4c593a6788uuid: 7d08e949-5c12-66da-d9e9-f2fb301401a1uuid: 76af265a-5357-c083-7ae6-c785b8d1960fuuid: 574fbd43-119f-2b95-4032-46b585bc1521uuid: e67ba0e1-80d8-61f5-ed70-fe7bfb7c706duuid: 57ec3923-366f-8d00-05ed-a77fd73d0e31uuid: ed779f36-7eb5-badb-480a-e1083c92da0buuid: d43f62a6-291f-5c70-e1e4-bf2e4abd2c59uuid: 7a2408e5-8030-2b19-58a7-12b482624687uuid: 70ee53b6-f8cf-babb-ad69-89dc80751805uuid: e9602858-9762-a1ae-8141-3a887be3e33duuid: 238c57a7-6b3f-adbf-355f-940a59ae3576uuid: ee4520fe-85ec-742d-c9a5-92642d42ce05uuid: ee7477ec-dbae-3d25-a19d-28923fff3442uuid: 1d6f2fee-e02f-e092-76a3-d778cc7e3395uuid: d19e365b-0a5e-8398-d2ea-1ccd2cf3a736uuid: 7b4b64ff-439b-22a8-f6f5-edbff477016auuid: fa1a8fec-9c6a-9774-7185-1b8af9d547bcuuid: b6d9ef6d-ff9c-f98a-068a-7db9006977c5uuid: 9bf17b97-4217-016e-252d-8bf712fae37cuuid: a9f78f91-5a06-5c66-241a-40af2e3f2bfduuid: ddce3c97-37e8-9908-3e6f-cffb0af8fd2fuuid: 66653d7e-f6eb-a76c-1f18-f40e255e1a03uuid: 1f755ca3-2a61-5ea0-cc91-5082d0dd3367uuid: 94eda71e-f8ed-a9af-4c1a-cd8c7368349fuuid: 24e105b7-d0a9-d1d7-47e9-0ad6f419336cuuid: e2425ce7-23f4-52e5-acfa-58c03db44e35uuid: 747f5304-c9a0-564a-7c34-d936628fc64euuid: 74e43c22-22da-8997-7d7b-94e719a93249uuid: 8a8d1d51-f29b-8c81-0b59-225f4389dd4euuid: 63631d13-77ba-113f-d7ca-1b2af38fa1d4uuid: 08bef6dd-a03d-5b4b-52b6-4af615b4fe7duuid: 5de22111-aa28-1009-c5db-8e7d99db5c09uuid: e7124659-da2f-934e-dfa9-bbe7511d389cuuid: 5029b4a7-74af-0286-c3f5-caf91107d200uuid: 506a515f-64a0-1b23-155e-71f937e9ccfauuid: 6e37fd7b-6160-2477-e68c-8ec156406423uuid: ad4cd3c9-4fe1-f444-0c7b-12e7c500cc32uuid: 1e9b7905-5eb4-dfdb-4536-1655517a8dcbuuid: 9e1658fe-e629-7798-6ee9-2a4e11dec8e0uuid: fa13c389-c7fe-37db-d130-9f293c34559euuid: 5f54cc46-b480-debf-bc3d-83426f61ebb9uuid: 0906b900-827e-9bb2-8b59-e2d5d1c03f34uuid: c66f2102-4f9d-c39e-0f00-177bfa9d85fcuuid: de48e05f-d7f5-55a1-9dc0-2e01e42dcad6uuid: 81dd2b75-34a2-02d6-c294-4b8d6ba98eccuuid: e26dc7cd-5656-49c9-7bfa-726110c22a67uuid: 8930f8dc-4b54-d623-c33b-7708be9236aauuid: 825c67e7-26d4-c986-d05c-887ea0a9a644uuid: 34a0f7c3-0eae-b295-98f6-2af60f147257uuid: 2d530884-c684-8663-6da7-6738a7ca5dc2uuid: 2685d41c-9307-a357-67d1-df0845deaa1duuid: f48cd8c6-507e-8864-8d74-604b754d77d8uuid: 30f97cb1-af9e-4256-1160-74fe344d626cuuid: c63b38e4-c993-5e50-5f0a-7af1e08c7225uuid: 9acea525-c606-adeb-7e77-7ffb3e5912d2uuid: 61a3ca7c-da4a-efde-ed1c-97324776ea86uuid: 300db998-3fc4-3c3a-e371-51b6972048d1uuid: 02a033e6-838b-09c0-d729-77351c959f0fuuid: 44101aec-b5d8-2df6-32c7-1d80f7c5a66euuid: f12c06f4-fffe-5c0d-49e8-26f6f33a796fuuid: 5e10e4db-9365-3252-e181-93ec75cf1febuuid: cf472d24-53eb-f254-ddf2-3628bf78eb73uuid: 3b2d8198-dbd6-5ac2-0ae9-b3349e5121c8uuid: bf0e7bc7-bd02-6f16-84e9-3c0311035e10uuid: 623b0d71-d0df-1042-9ecc-78cec84aaff7uuid: 337e1ba0-96c2-fde2-c594-93a8ff48ab90uuid: 4f45c0ca-5999-5c2d-7bea-3e1c561371dauuid: c49d3ff2-a88c-2ae1-7895-80819efcbe74uuid: 7e8f8968-0ebb-e04e-f15c-3dd5d50cb118uuid: 166f07e9-85ec-38c7-2e79-2b801f69331buuid: 5dc5848d-565d-9659-9f38-9ab9773099d5uuid: 76d2a6cf-b85a-d3fb-e25e-5d209452e996uuid: f46f73b9-4c06-44a2-cd8a-89a660b698c0uuid: 9015cd10-9812-0e25-bf60-08fda88ad77cuuid: de0c3e6a-0c84-00f5-7e99-ca0a0e807e6duuid: 44865274-3ceb-fe34-c086-d4c129f4fa06uuid: 2381d900-9114-6af6-8659-798127c0c3fduuid: 4fa649e3-1cd0-ab96-a8b8-3e266827c055uuid: bedcc8f4-c348-dca9-2900-d35c8e947be0uuid: d0dad182-3384-5734-7828-410cfe829f07uuid: 755d9a13-a230-d212-01c1-98b01c753bd0uuid: b16eb89c-4de3-b10e-717c-225e4faad543uuid: dccfb076-7302-c1de-e2f4-ba5c2ae98148uuid: 84b66053-f921-d060-b00d-ef2c5b7ace90uuid: 4b181d34-54f2-bafb-f3e0-45922237dd0cuuid: 07d9717b-6582-e84a-7de4-ffe1dfc74982uuid: cf17dbb6-6121-c51f-9f49-5a6aacb6c15fuuid: 23c2e5ca-9e0d-c654-a6fd-670b3d263c0auuid: 50fd442f-6f8e-0ba1-2e89-0dcd9284feb0uuid: 79f025e8-b1e4-3c71-9e07-15c46ab30318uuid: a738d1a9-6c85-6cbc-d3b0-5b1f831f359auuid: f743280f-143d-c75a-fdaa-0d3328627adfuuid: ca288966-1f0c-c5be-809e-8fb7e3967839uuid: 9b2e2b79-0a33-4c67-d8ae-1bc37a83d1bduuid: ff3e9afc-93be-3909-1f46-4aae0b4e4af8uuid: becb25d7-8eb5-8269-b3af-bd3cfe5a1cbfuuid: 046dec9e-dd06-1895-40a6-080da377c1aeuuid: 6375061e-85cd-1a7e-43f4-c405ab5e2268uuid: 77e0597c-c34a-41f5-5d73-2da78080b9c7uuid: cefbe111-767a-544c-83c1-76ad3b924bc5uuid: 74decfa7-6e55-5f63-8937-7a5e14318b2auuid: a82f8856-7b91-628b-598e-7b48241e2bbcuuid: 7a24206d-1d99-884b-3159-ef967697d583uuid: 044e13e6-4c6a-1369-19e5-6ae209479984uuid: 7b983cdf-9b15-232b-2040-173e22ea99f9uuid: cdf7e97d-f927-6e92-e17e-96dc4f5c890buuid: 0a798f27-343d-4f0b-2507-947eefd44fc9uuid: 1b50821f-e80a-deb6-6a00-e84716656ccauuid: 43ff6a9d-e131-2aad-3e7c-dbd88e022777uuid: a47b6cb0-d3cd-e810-9c21-29000c0c8d63uuid: 0c8736f3-63bd-a35c-95de-f2e5a347d009uuid: e788344f-b262-4a00-1d61-fe362d4be8f5uuid: 588b9da8-a521-382b-fbc8-af7b1ec78f41uuid: daf81bb2-89d3-7e55-4357-a1bf993189b3uuid: 0c1028bc-1dd0-9241-2189-839a5cf2edfduuid: 2804d1db-e8d1-0662-82dd-05bce65534d2uuid: f59ae381-465a-cadb-f161-50d677d906e1uuid: 83af6459-2122-27a1-c067-7942e8355ee5uuid: d81186cb-c95d-b628-c5e7-e759b4164702uuid: 1f1290a5-09cc-8311-c66f-d13378cfecd3uuid: 3feb3cb2-72b2-08ff-504e-82c940d55054uuid: 8e18d59e-cf5c-296e-3b14-44563b28c7a8uuid: 511b4925-dfef-9ba4-ee56-b75483428c4fuuid: cc86ab5c-879e-627e-8bd8-7ce85b944377uuid: bcba8a99-f6a9-00d2-badb-ca5ed05568beuuid: 7c64dc04-1a50-9bbc-66af-89d67190d70fuuid: ce24bc6b-7ac5-fabd-322f-878c0c9efdfcuuid: 4b357c42-ee9e-0946-65e3-ac91dd509535uuid: 966c9063-97ba-6622-6312-b411ae7732cduuid: 1546b6f0-1a6b-0392-bca7-0eb8493947d2uuid: 62b7632b-885d-c3a5-30c8-41f8875884e5uuid: a6d78244-2843-823c-d3a3-23c8a27a0a77uuid: 72e0be2f-7c5b-4da0-6f4f-f9ece77056aeuuid: 3af247df-1178-9b4b-2ada-d1cddb815feduuid: 5978a14f-aaa9-24ac-b254-c95f4a203751uuid: 760f96ed-3e83-d525-3be3-5d867cc1f178uuid: 5c8b43dd-e7de-ac6e-4a70-c80de958b048uuid: 41a4f1a0-d5a0-d782-2c9d-d92862df8ca7uuid: 9a96be43-8956-e997-7b1f-2cd72a0d3dc4uuid: 879da19b-299b-dcc3-091f-08c24d1bb848uuid: 1686ea21-6731-f6d7-6200-0f8a91e30420uuid: 671c588a-100f-f9b5-5614-2269f4561eb9uuid: 27c29ed2-e17b-e0b5-58ff-3ac9d3c2b4b0uuid: ff3c9b7e-3aef-c377-5ea3-10a2439e26f9uuid: d4dfd6c4-f767-57b0-a6e9-40aa8bee300auuid: 1de03c14-5a33-79fe-db47-78f9ca55456buuid: 28cfd842-5002-ecf7-b69f-faa0ce0605aduuid: b4b6fa55-542b-86c3-76e0-02207b67a418uuid: f7517743-c3f6-b196-78c5-8bf18a7379f6uuid: ba3f85af-d31d-927f-b96b-e0b503db1eeeuuid: a10017ff-6d95-de4d-3cb9-3743c1bcf321uuid: 1c5fba31-8356-215d-6e5c-9652800fe6cbuuid: 2b43f36e-969c-693b-3a82-3f752675e0eeuuid: 3c0bd4bf-422a-148d-34f9-8d0c0a305ad3uuid: c5e60c94-7460-acd7-dd60-a371ee98cde2uuid: 54a9cd07-c8d1-10fb-c644-6f1cb267568euuid: bac881af-0906-e2f2-d613-059e46ddd42duuid: 2eecf698-de41-3315-f9ae-0c78c5610d92uuid: a2c5b75d-f090-632d-c95c-6d570a799e78uuid: 602d622f-fb9f-a6ae-e743-b77e96a56e16uuid: e4b5c74b-b957-1c12-a93e-64b3c36fcf62uuid: 1fea9cab-d97a-f816-023d-9e6ff979bc0duuid: d67e2d91-9615-7bb7-58a5-fa401fd3f570uuid: 212876c1-327b-0a64-1a60-7204fa8d29b2uuid: 591ddc6a-ce92-f40b-4747-27abea1d8c78uuid: b6ca0dfb-ddee-44a3-a95a-cb1b50bfcac0uuid: 59273454-06a0-097d-c80c-0031fe0a2175uuid: c0e41b2a-303a-b1d0-8a79-688fa82968d6uuid: 605c2e78-107b-08bd-3fc6-1b4d3c9d9fcfuuid: 25bf64fe-3d84-783c-3fb0-49d7c74714c6uuid: c099ba45-0c42-3783-af95-d6f87eba38a1uuid: 4e8f96ab-b13d-6df3-ee99-4008c4a02e2cuuid: c2c2119c-01f0-ab78-3f7e-a4103dcbedcfuuid: da12747e-80ab-702a-6f13-73e8510c41dauuid: ffe99e31-8897-b0f7-d2c2-47b64588ca81uuid: 312ee3a4-ddfc-ce2c-3a49-59dc305b8d68uuid: 47856b20-9928-2a48-ad87-a1fbe7ad202duuid: 4799a273-f78e-2e8b-b423-e9305975c57euuid: c6344a9d-2bb8-27a3-85e4-85e7d0648fdduuid: 4dc60771-2d75-e1bf-0f21-5abaf22df794uuid: d4027ac8-b076-4a96-6a97-45254b1026ecuuid: 4a896c9f-14f1-30c2-1f02-e98a02bdc07euuid: 825595f5-46f4-dfcd-1a2b-3e4b863790dcuuid: cef5dd35-9b4e-9448-783e-56422fb3bcffuuid: 102d3da4-8749-92ec-b0e4-81c92ba9505duuid: 734bb951-a0ee-cb8a-3787-b4fb90dca68buuid: eb216f9a-e292-c365-e2a7-60050fe11a68uuid: 1e0f31a5-6a80-7071-b623-c9fd528ebbf1uuid: c4e0c7d9-9228-f5f6-7b53-d4bc509050d3uuid: 1faef5e9-593d-cfbe-b088-935d1fd531aeuuid: 0c488084-279f-ce82-991b-6fc6071bf431uuid: 47e18dbc-05ee-73a7-5fde-ffe61f270587uuid: d0e37500-5a8f-1144-cb8a-d7c1e1ddae79uuid: 426b6804-f18f-37d3-31de-a735fd2eeee8uuid: 351f724e-ea3c-3288-c390-167fce761563uuid: 2ea35a33-2e54-1e0b-1854-1e1ecc25f4c9uuid: ce9d9146-617d-8204-2405-de104f91b407uuid: 65cde570-6148-b8f0-0087-c76a79418b4fuuid: d924c1b7-cf2e-86f2-3744-a64b3b21fe5duuid: aa183c8e-557f-8592-c18e-cff519df5964uuid: d7bc2f9d-e399-afee-4699-747af661dc19uuid: 67de975f-cb46-d7e3-64cf-0a5e81298551uuid: 622ca7dc-6b39-9e3c-e0bc-728bc31e4ec3uuid: af893471-7aff-147e-d165-f2f321e718f7uuid: 8dfa2a63-774c-a431-503d-375b48316f22uuid: 494f0f33-6e45-09ce-46d7-8e6a50ac512fuuid: 91a9c317-1f59-ec61-9669-db1d7e10dfdcuuid: 1032eb43-be43-6381-008e-93670ea03cb8uuid: 5b2afc0f-e47c-a5e5-7541-a20b551a40c1uuid: b28b9965-c69b-a281-bc1e-38327c25edf9uuid: 9f8cd707-eaf1-a339-84e9-bafab0e2e35fuuid: d510633c-06c1-a67e-9917-c26fa14ce6b2uuid: a2c4e3ac-3a6c-f501-d4f8-f590404dfaf3uuid: 285ced86-3bec-f6be-8154-27539b3a8ba9uuid: 99819f1d-e10d-5092-19ee-3354b892774auuid: 862e0a56-5c71-d210-86d9-b4c499a19275uuid: d547e3da-30ea-758d-2df4-854b59a1edf3uuid: 1db320db-1618-e096-85fc-0f4dd3ff1365uuid: 361c5289-656c-af31-1410-ef77c53b03afuuid: 18fa104d-783b-eb1b-79d2-95b2db887bd1uuid: 9dbbdf3d-2ac0-dca4-875f-e906e430b05duuid: 84a7d7fe-a6f6-5b6d-af82-77c7b4625bc3uuid: b2dfb98b-cd24-240d-90ea-5d68fdd30b07uuid: 3e102006-0856-9ef0-4ff7-fba6bddfc4dauuid: ef76dabe-b4c1-06be-6494-4fb406a38ed0uuid: 1dab3ca6-24f8-e179-ec4b-cb4263e174dcuuid: f1538e8d-cc0f-2d61-1b3e-2c6e3c411037uuid: ecba2803-8a4e-8f7b-b3a8-29a3fb6e47bauuid: 4d2a3ec9-9ed6-b615-6053-6bb025e1f30fuuid: 44605ce6-4f31-227b-a69a-1567d17a3020uuid: 06dab224-1bf1-fa01-0d09-8f8f991d5052uuid: c10c1741-2727-b972-26d0-cfc58f1e3335uuid: 7a8563ba-95a0-b389-e74b-e97b00a99c52uuid: 5a20688f-50dd-236e-f731-34df8ec932b6uuid: cc9f51cf-cca0-6f96-114d-3594dbac40f2uuid: e8d20245-2467-36a1-f861-5025e1c35dbcuuid: c26bb5fb-930d-1564-8910-e103d749a2eeuuid: e717293e-9b4c-c380-49ac-d6ec6112bd41uuid: 5b8ceb46-8705-09cf-ccbb-62bd2bebb18cuuid: e3a112f5-dda6-1c4a-08ba-8614b6e71640uuid: 5577df3e-3c06-9790-0400-acd85ba7df5buuid: 95effa6c-89a9-dee5-e6d6-272d9b42c2dduuid: f2477cc5-ecdd-1f72-383a-7f6bade63a49uuid: cd75d8d6-068c-2253-4466-22122de8b44cuuid: b2d69bbd-010a-63f1-eaaa-7d978e941896uuid: 757e2bcb-3006-1c15-aef7-f54eff2bc063uuid: be464933-9917-5686-69ff-c470b4f6884duuid: 712dcbde-740d-0f95-899e-7540ae7fd2f8uuid: 6a5724e8-0822-0915-b148-ab6cd2e78544uuid: fdaca5ba-ed11-a843-fece-69890e8b8953uuid: 5acd7545-fbef-ef31-d72d-b2c8fa1dabfduuid: 48773e0b-ec78-74db-e6c3-5eb5e5ddf8fduuid: 5b42b666-0b2f-b270-3171-d6c5f9c6239buuid: 5ea8cf9a-953d-80cf-7b0e-d428b2eeec8fuuid: 05ad4850-c47c-df90-3cb1-c9ecee5152f9uuid: b15c5377-c9ba-426a-7f2e-eba8505fec0fuuid: fa52adaa-8f2d-3fb4-c422-6c080c6b36dfuuid: 4f69e698-83ed-5b51-7293-6773ecb974c8uuid: c88771e9-8990-4e31-40f7-eaae54cc6347uuid: ece2e50c-db3c-3558-f235-24bd77150d67uuid: 57daa4d5-a2c6-fef8-ac7b-39420d6c2ebduuid: 3e03ef60-57e8-26df-7ff0-335e190c3ca2uuid: a6c76eb6-ffda-4319-881f-c7e6808943d8uuid: 3b4851e5-b5a1-6b65-b7e5-32c678911d86uuid: 070052f7-ea8f-a2e2-cd24-2cfd2dcdd801uuid: 89204017-b08a-9b17-150a-06edfecfc811uuid: d7782af5-f603-53ef-16af-e3d79c1f5271uuid: 8f227742-902e-f492-85f9-d1a55d7e8d5cuuid: d93d5919-e1fa-ca9a-1f12-bf755cbbbbe4uuid: 672ff06c-978c-1993-28a7-f0d476360bcbuuid: 7aa8104b-3718-d252-cbc4-c5c47e1e2f67uuid: 04e0a842-bf54-a0a7-f674-1b3ae2ce74e6uuid: 15b754f5-07b4-35f0-ff72-16fe30885cc9uuid: 86a1f70f-0edc-86b9-4b2b-b5e817c16302uuid: 72766f74-e560-ef0a-3f50-927cdac14a01uuid: 8027a811-9a0f-39a8-6ae3-9d01e5b6a3cbuuid: 27ee08c1-50c8-d5b4-e605-5585c7f925dauuid: 78a7d889-9603-11d7-02b8-80607d3f61cfuuid: 444fda18-06eb-d9a4-0309-7c757956d2c5uuid: 35324499-bd04-5e80-531e-7025af831726uuid: 6a533d7f-1fa0-fdaf-bf5d-cf1a64bab6d3uuid: ca89af96-f75d-2ee7-a164-53c73739bcd2uuid: 690a9e30-d630-db0e-d790-73486efdd65auuid: ab8110b7-18fb-4757-e1a5-120b99177614uuid: 846166b0-8cdb-79c3-b86c-bffe6e50c285uuid: 1dadd414-921d-bcd5-de5f-3088145ccedauuid: 83e7ff53-1822-f4e3-b45c-991143101c23uuid: 5ed5d56f-552d-d6dc-ee2f-be180c0e0388uuid: 9066c37f-f6cc-90e4-b356-aec838925b11uuid: f94298f0-8f47-2c4a-8763-96bd64040ed1uuid: b6e90895-7c86-5507-ef2b-b9ac65530cafuuid: b0842b4c-1e26-620f-62d7-eb501fb4b979","categories":[],"tags":[]},{"title":"NGINX & HTTP2 初识","slug":"nginx-2021-08-11-nginx-http2","date":"2022-09-03T12:55:44.523Z","updated":"2022-09-03T12:55:44.524Z","comments":true,"path":"2022/09/03/nginx-2021-08-11-nginx-http2/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/nginx-2021-08-11-nginx-http2/","excerpt":"","text":"一 本文目的 学习 HTTP2 协议. 学习 NGINX 对 HTTP2 的处理以及如何从 HTTP2 进入 HTTP1.1 的处理流程. 未分析 HEADERS、DATA 之外帧处理. 二 协议概述HTTP2 可以同时运行在 HTTP/HTTPS 之上, 在 HTTPS 上是通过 TLS 应用层协商协议(Application-Layer Protocol Negotiation 简称 ALPN)支持. NGINX 服务器是支持在 HTTP 下开启 HTTP2, 但是无法在同一个端口上同时支持 HTTP2、HTTP. 浏览器厂商选择只实现基于 HTTPS 的 HTTP2, 使用 ALPN 可以判断使用 HTTP/HTTP2. HTTP2 协议特性: 二进制分帧协议 无队头堵塞: 可以并行发送多个 HTTP 请求, 不会触发队头阻塞. 多路复用 二进制流可以交错进行, 实现在单 TCP 连接上多路复用. 同时连接复用有效避免 TCP 慢启动、拥塞窗口协商过程, 提升传输效率. 可以将 Stream 想象为一系列 Frame 序列. 参见 Streams And Multiplexing. 服务端推送 头部压缩 头部压缩是有状态的, 在一个连接上只有一个压缩、解压上下文. NGINX 默认没有编译 HTTP2 模块, 需要通过 --with-http_v2_module 选项开启. 协议细节参考 RFC 文档. 在规范中未定义 Frame ID 类似字段, 是通过 TCP 协议来确保同一个 Stream 中的 Frame 是有序的. 1. 交互顺序1234567891011121314sequenceDiagramparticipant C as Clientparticipant S as ServerC --&gt; S : IdleC -&gt;&gt; S : HTTP2 前言, PRI * HTTP/2.0\\r\\n\\r\\nSM\\r\\n\\r\\nC -&gt;&gt; S : SETTINGSS -&gt;&gt; C : SETTINGS, HTTP2 连接建立成功C --&gt; S : HEADERSC --&gt; S : DATAC --&gt; S : ... 协议规定, 对端响应的 SETTINGS 帧是前言的一部分, 因此 Server 必须发送 SETTINGS 帧. 对基于 HTTPS 的 HTTP2 在 SSL 握手阶段需要进行应用层协议协商(ALPN), 当 Sever 允许使用 HTTP2 时会响应 101 状态码进行协议切换, 会产生一次额外的 RTT. Stream ID 约束: 客户端使用奇数流标识符; 服务端使用偶数流标识符. 特殊的 0 用于整个连接而非单独的流. 可以观察到 SETTINGS 帧的 Stream ID 都是 0. 流中可以有多个帧, 会出现多个帧具有相同的 Stream ID, 这些帧不会错乱是因为: 1. 发送方在同一个流中顺序发送; 2. TCP 协议确保帧会按发送顺序交付. 三 NGINX 中处理 对于 H2 处理有个比较重要的问题, 如何对一个 TCP 链接进行多路复用. NGINX 使用 fake_connection 与 H2 的 Stream 关联, 将其等价于 HTTP1.1 的 request 复用原有模块. 1. H2 入口NGINX 中 HTTP2 协议处理有两个入口: 基于 HTTP 和基于 HTTPS. 当配置 http2 指令, 未开启 HTTPS 时, 会在 ngx_http_init_connection 阶段修改当前连接的接收处理函数为 ngx_http_v2_init 陷入 HTTP2 协议处理流程. 当开启 HTTPS 时, 会在 SSL 握手阶段, 根据请求协商信息确定是否启用 HTTP2. 2. H2 处理开始NGINX 中 HTTP2 协议是由 ‘ngx_http_v2.c’ 模块实现. 在与客户端交互过程中, NGINX 会首先发送一个 SETTINGS 和 WINDOW_UPDATE 帧, 通知客户端 NGINX 支持的最大流数量、窗口大小、帧大小, 此时帧会先进行 queue 合并发送. TCP 连接的读/写事件处理函数为 ngx_http_v2_read_handler, ngx_http_v2_write_handler, HTTP2 状态机初始状态是 ngx_http_v2_state_preface. ngx_http_v2_state_preface 检查发送“前言”是否正确, “前言”必须是 PRI * HTTP/2.0\\r\\n\\r\\nSM\\r\\n\\r\\n. 在“前言”处理完毕后会进入请求头处理 ngx_http_v2_state_head, 此时会根据帧首部 Type 使用不同的处理函数处理. 不同类型帧对应处理函数: 123456789101112static ngx_http_v2_handler_pt ngx_http_v2_frame_states[] = &#123; ngx_http_v2_state_data, /* NGX_HTTP_V2_DATA_FRAME */ ngx_http_v2_state_headers, /* NGX_HTTP_V2_HEADERS_FRAME */ ngx_http_v2_state_priority, /* NGX_HTTP_V2_PRIORITY_FRAME */ ngx_http_v2_state_rst_stream, /* NGX_HTTP_V2_RST_STREAM_FRAME */ ngx_http_v2_state_settings, /* NGX_HTTP_V2_SETTINGS_FRAME */ ngx_http_v2_state_push_promise, /* NGX_HTTP_V2_PUSH_PROMISE_FRAME */ ngx_http_v2_state_ping, /* NGX_HTTP_V2_PING_FRAME */ ngx_http_v2_state_goaway, /* NGX_HTTP_V2_GOAWAY_FRAME */ ngx_http_v2_state_window_update, /* NGX_HTTP_V2_WINDOW_UPDATE_FRAME */ ngx_http_v2_state_continuation /* NGX_HTTP_V2_CONTINUATION_FRAME */&#125;; 3. 请求头处理H2 同样遵循 HTTP1.1 的语义, 需要先发送请求行、请求头, 不过在 H2 中将请求行信息转换成特殊的请求头. 对于 HTTP1.1 请求行是 Method SP Request-URI SP HTTP-Version CRLF 格式, 在 H2 中会将其拆分成 :method, :path 请求头. 请求头是通过 ngx_http_v2_state_headers, ngx_http_v2_state_header_block, ngx_http_v2_state_field_len(ngx_http_v2_state_field_huff/ngx_http_v2_state_field_raw), ngx_http_v2_state_process_header, ngx_http_v2_state_header_complete 函数处理. ngx_http_v2_state_headers 判断 StreamId 是否正确、请求头是否超限、流并发是否超限、分配 Stream 结构建立流依赖树. ngx_http_v2_state_header_block 请求头处理, 有 5 种类型的请求头(具体看 HPACK 协议, 不展开). 根据请求头长度进行处理. ngx_http_v2_state_field_len(ngx_http_v2_state_field_huff/ngx_http_v2_state_field_raw) 使用霍夫曼编码或原始编码解析请求头. ngx_http_v2_state_process_header 对解析出来的请求头进行处理: 校验是否合法, 将其保存到 r-&gt;headers_in.headers 中. ngx_http_v2_state_header_complete 判断是否有后续请求头, 进入 ngx_http_v2_state_header_block 继续处理. 如果设置标记 HEADERS 帧结束, 进入请求处理. 4. 请求处理在 H2 请求头处理结束后会进入 ngx_http_v2_run_request 进行请求处理: 将 H2 格式请求信息转换成 HTTP1 格式信息(NGINX 内部使用, 能够复用 NGINX 原有功能); 进入 HTTP1 的请求处理函数 ngx_http_process_request, 调用 ngx_http_handler 运行 HTTP 处理的 11 个阶段. 在调用 ngx_http_v2_run_request 时使用的是 stream-&gt;request 作为参数, 是在 ngx_http_v2_state_headers 函数中创建的假的 request/connection, 读/写回调函数都是 ngx_http_v2_close_stream_handler. 在 ngx_http_process_request 中将请求读回调函数修改为 ngx_http_block_reading. 在 ngx_http_handler 中将请求写回调函数修改为 ngx_http_core_run_phases. 在 ngx_http_v2_read_request_body 中将读/写回调函数修改为 ngx_http_v2_read_client_request_body_handler/ngx_http_request_empty_handler. 5. 何时读取请求体?前面已经提到在 ngx_http_handler 中会运行 HTTP 处理的 11 个阶段, 假设当前 location 用于反向代理那必定会运行 ngx_http_proxy_handler 函数. 可以追踪到函数调用链(注意, ngx_http_v2_read_client_request_body_handler 是通过回调触发): 1234567891011121314151617graph LRsubgraph HTTP 框架ngx_http_handler --&gt; ngx_http_core_run_phasesngx_http_core_run_phases --&gt; ...endsubgraph Proxy... --&gt; ngx_http_proxy_handlerngx_http_proxy_handler --&gt; ngx_http_read_client_request_bodyendsubgraph HTTP V2ngx_http_read_client_request_body --&gt; ngx_http_v2_read_request_bodyngx_http_v2_read_request_body -.-&gt; ngx_http_v2_read_client_request_body_handlerend 看到这里是不是会想 ngx_http_v2_read_client_request_body_handler 负责请求体读取操作操作? 跟进函数去没有读取操作, 而且函数参数 r-&gt;connection 并没有与 socket 关联无法进行读写操作. 对于 H2 数据是通过 DATA 帧进行传输, 还是得从 ngx_http_v2_frame_states 状态机跟进. ngx_http_v2_state_data 用于处理 DATA 帧, 其中调用链如下: 1234graph LRngx_http_v2_state_data --&gt; ngx_http_v2_state_read_datangx_http_v2_state_read_data --&gt; ngx_http_v2_process_request_bodyngx_http_v2_process_request_body --&gt; post_handler 此处 post_handler 就是 ngx_http_upstream_init, 是 ngx_http_proxy_handler 中设置. 6. 响应NGINX 响应分为 HEADER、BODY 两个阶段, 看下源码有 ngx_http_v2_filter_module 模块, 模块只介入 header_filter 处理阶段, 在其中以 H2 格式发送响应头, 有两点需要注意: 连接(connection)以及对应的套接字(socket): 对于 H2 在 header_filter/body_filter 的入参 request 是“假”的, 其关联的 connection 也是假的. 需要使用 H2 初始建立的连接, 通过 r-&gt;stream-&gt;connection 索引. 响应体处理: H2 模块没有添加 body_filter 处理函数, 在 header_filter 阶段修改 connection 的 send_chain 回调函数为 ngx_http_v2_send_chain 用于 H2 响应体发送. 响应 Stream Id: 在响应阶段 request 是“假”的, 已经与请求 Stream 关联, 通过 r-&gt;stream-&gt;node-&gt;id 可以获得 sid. 这里只做了简略分析, 优先级、推送、窗口更新都没有提及. 四 抓包观察1. 配置NGINX 可以不基于 HTTPS 启用 H2, 配置如下: 123456789101112131415server &#123; listen 8000 default_server http2; location / &#123; content_by_lua_block &#123; ngx.log(ngx.ERR, &quot;content phase&quot;) local content = &quot;Our examples focus on using server push to improve page load performance in web browsers.&quot; for i = 1, 100 do ngx.say(content) ngx.sleep(0.1) end &#125; &#125;&#125; 2. 请求可以使用 CURL 发起 H2 请求: 1234567curl -i --http2-prior-knowledge http://127.0.0.1:8000/HTTP/2 200server: openresty/1.15.8.2date: Wed, 11 Aug 2021 01:17:25 GMTcontent-type: text/plaincontent phase CURL 也支持发起 H3 请求, 方便抓包测试. 3. 抓包客户端发送的 SETTINGS 帧信息 服务端发送的 SETTINGS 帧信息 注意, 服务端在响应 SETTINGS、WINDOW_UPDATE 帧时 Stream ID 都为 0; 在发送 HEADERS 帧 Stream ID 为 1, 是对客户端发起的 Stream ID 为 1 的响应. 即请求/响应在同一个流中进行. 五 参考文章 NGINX HTTP2 介绍 中文 HTTP2 介绍 HTTP/2 新特性浅析 HTTP2 RFC HTTP2 头部压缩 RFC HTTP2 头部压缩 RFC 中文 为 HTTP/2 头压缩专门设计的 HPACK","categories":[{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/categories/NGINX/"}],"tags":[{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/tags/NGINX/"},{"name":"HTTP2","slug":"HTTP2","permalink":"https://juzipeek.github.io/tags/HTTP2/"},{"name":"HTTP","slug":"HTTP","permalink":"https://juzipeek.github.io/tags/HTTP/"}]},{"title":"Kong 代码阅读","slug":"nginx-2021-02-28-kong-code","date":"2022-09-03T12:55:44.523Z","updated":"2022-09-03T12:55:44.523Z","comments":true,"path":"2022/09/03/nginx-2021-02-28-kong-code/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/nginx-2021-02-28-kong-code/","excerpt":"","text":"一 基于源码安装1. 依赖安装Kong 依赖 OpenResty、 Nginx 补丁、 OpenResy 补丁、 OpenSSL、 PCRE、 LuaRocks、 LibYAML. 使用 kong-build-tools 工具可以方便安装依赖. 1234567891011121314151617181920git clone git@github.com:Kong/kong-build-tools.gitcd kong-build-tools./openresty-build-tools/kong-ngx-build \\ --prefix $&#123;HOME&#125;/work/kong-deps \\ --work $&#123;HOME&#125;/work/kong-work \\ --openresty 1.17.8.2 \\ --openssl 1.1.1i \\ --kong-nginx-module 0.0.8 \\ --pcre 8.44# 设置 PATHexport KONG_DEPS_PATH=$&#123;HOME&#125;/work/kong-depsexport OPENSSL_DIR=$&#123;KONG_DEPS_PATH&#125;/opensslexport PATH=$&#123;KONG_DEPS_PATH&#125;/openresty/bin:$PATHexport PATH=$&#123;KONG_DEPS_PATH&#125;/openresty/nginx/sbin:$PATHexport PATH=$&#123;KONG_DEPS_PATH&#125;/openssl/bin:$PATHexport PATH=$&#123;KONG_DEPS_PATH&#125;/luarocks/bin:$PATHexport PATH=$&#123;HOME&#125;/work/luarocks/bin:$PATH 选项解释: --prefix : 程序安装目录 --work : 依赖文件(openresty、openssl)下载及编译目录 --openresty : 指定 OpenResty 版本 --openssl : 指定 OpenSSL 版本 --kong-nginx-module : 指定 lua-kong-nginx-module 版本, 主要是对 nginx、lua-nginx-module 补丁 --pcre : 指定 pcre 版本, 如果未指定, 则不添加 pcre 模块 --force : 删除 work、prefix 中内容, 重新下载编译 测试安装是否成功: 12/usr/local/kong/openresty/bin/openresty -vopenresty -v 安装 LibYAML 库: 12345678# Ubuntu:apt install libyaml-dev# Fedora:dnf install libyaml-devel# macOS:brew install libyaml --build-from-source ‘kong-build-tools’ 的核心是 ‘/openresty-build-tools/kong-ngx-build’ 脚本, 会依次下载 OpenSSL, OpenResty, PCRE, LuaRocks, lua-kong-nginx-module 并对 OpenResty, Nginx 打补丁. 最终会安装 OpenResty 和 LuaRocks. 2. Kong 安装123456789101112131415161718git clone git@github.com:Kong/kong.gitcd konggit checkout 2.3.2make installcp bin/kong bin/busted ~/bin/# kong 指令拷贝到 bin 目录后不需要将 kong/bin 添加到 PATH 中cd ..export PATH=$(pwd)/kong/bin:$PATH# 添加设置 Kong 安装目录到 lua 包搜索路径export KONG_LUA_PATH_OVERRIDE=$(pwd)/kong/# 导出 luarocks 库变量到终端环境, 会导出 LUA_PATH, LUA_CPATH, PATHeval $(luarocks path --bin)# 检查安装结果kong version --vv 如果不设置 KONG_LUA_PATH_OVERRIDE 环境变量, 需要进入 kong 安装目录执行 kong 命令. 执行 make install 命令会通过 luarocks 安装 Kong. 12install: @luarocks make OPENSSL_DIR=$(OPENSSL_DIR) CRYPTO_DIR=$(OPENSSL_DIR) luarocks make 会根据当前目录下 ‘kong-*.rockspec’ 文件进行 Kong 安装, 将 kong 文件拷贝到 luarocks 本地库. 安装完成后, kong 代码会被安装到 ‘/usr/local/share/lua/5.1/kong’ 目录下, 可以修改此处代码进行调试. 通过可执行文件 ‘kong’, 输出 package.path 可以找点 OpenResty 库加载路径. 二 配置管理1. Kong 配置使用 PostgreSQL 作为配置数据库, 安装 PostgreSQL 12345678910111213141516171819sudo apt-get updatesudo apt install postgresql-12# 开启sudo /etc/init.d/postgresql start# 关闭sudo /etc/init.d/postgresql stop# 重启sudo /etc/init.d/postgresql restartsudo -i -u postgres# 进入 postgre 数据库psql# 创建 kong 用户与数据库CREATE USER kong;CREATE DATABASE kong OWNER kong;ALTER USER kong WITH PASSWORD &#x27;kong&#x27;;# 修改 postgresql.conf pg_hba.conf 允许远程访问 Kong 启动时需要根据配置文件生成 NGINX 配置文件, 默认会尝试读取 ‘/etc/kong/kong.conf’, ‘/etc/kong.conf’ 作为启动配置文件. 在启动时可以通过 --conf file_path 指定配置文件. 123456789101112131415sudo mkdir -p /etc/kong/# 注意修改 postgre 数据库密码cp kong.conf.default /etc/kong/kong.conf# 检查配置是否有问题kong check# 生成 nginx 配置kong prepare# 初始化数据库kong migrations bootstrap# 启动kong start 2. Kong 默认监听端口默认情况下, Kong 监听以下端口进行转发、管理 端口 功能 配置名 8000 反向代理端口 proxy_listen 8001 管理端口, http admin_listen 8444 管理端口, https admin_listen 3. 常用 API12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364# 节点信息curl -i &quot;http://localhost:8001/&quot;# 查看状态curl -i &quot;http://localhost:8001/status&quot;# 查看工作区curl -i &quot;http://localhost:8001/workspaces&quot;# 列出 servicecurl -i &quot;http://localhost:8001/services&quot;# 创建 servicecurl -i \\-H &quot;content-type: application/json&quot; \\&quot;http://localhost:8001/services&quot; \\-d &#x27;&#123; &quot;name&quot;: &quot;my-service&quot;, &quot;retries&quot;: 5, &quot;protocol&quot;: &quot;http&quot;, &quot;host&quot;: &quot;example.com&quot;, &quot;port&quot;: 80, &quot;path&quot;: &quot;/some_api&quot;, &quot;connect_timeout&quot;: 60000, &quot;write_timeout&quot;: 60000, &quot;read_timeout&quot;: 60000, &quot;tags&quot;: [&quot;user-level&quot;, &quot;low-priority&quot;]&#125;&#x27;# 列出 routecurl -i &quot;http://localhost:8001/routes&quot;# 使用之前创建的 service 创建 routecurl -i \\-H &quot;content-type: application/json&quot; \\&quot;http://localhost:8001/routes&quot; \\-d &#x27;&#123; &quot;name&quot;: &quot;my-route&quot;, &quot;protocols&quot;: [&quot;http&quot;, &quot;https&quot;], &quot;methods&quot;: [&quot;GET&quot;, &quot;POST&quot;], &quot;hosts&quot;: [&quot;example.com&quot;, &quot;foo.test&quot;], &quot;paths&quot;: [&quot;/foo&quot;, &quot;/bar&quot;], &quot;https_redirect_status_code&quot;: 426, &quot;strip_path&quot;: true, &quot;path_handling&quot;: &quot;v0&quot;, &quot;preserve_host&quot;: true, &quot;request_buffering&quot;: true, &quot;response_buffering&quot;: true, &quot;tags&quot;: [&quot;user-level&quot;, &quot;low-priority&quot;], &quot;service&quot;: &#123;&quot;id&quot;:&quot;afa80698-f510-4f28-b12e-642cb447f91c&quot;&#125;&#125;&#x27;# 列出插件配置curl -i &quot;http://localhost:8001/plugins&quot;# 创建插件配置curl -i \\-H &quot;content-type: application/json&quot; \\&quot;http://localhost:8001/plugins&quot; \\-d &#x27;&#123; &quot;name&quot;: &quot;rate-limiting&quot;, &quot;config&quot;: &#123; &quot;hour&quot;: 500 &#125;&#125;&#x27; 三 数据层面代码在执行完 ‘kong migration bootstrap’ 后, 会生成 ‘nginx-kong.conf’ 文件(根据 ‘kong.conf’ 配置生成), 通过 ‘nginx-kong.conf’ 文件可以看到 kong 介入的处理阶段. 下面介绍各个阶段执行流程. 1. 库加载在导入 kong 模块时会调用 ‘kong.globalpatches’ 对 ngx.socket.tcp, ngx.socket.udp 进行 hook, 目的时在进行连接时调用 resty.dns.client 进行地址解析. lua-resty-dns-client 是独立的库. 2. init ‘.kong_env’ 配置文件加载, 作为全局配置数据 重置共享内存内容 根据 Kong 版本加载相应的 PDK 加载, 插件加载后可以直接通过全局 ‘kong’ 实例访问插件代码 数据库初始化:初始化数据库实体模型(schema): Connector 和 Strategy. 在 init、init_worker 阶段可以使用 luasocket 进行同步网络操作, 建立与数据库连接进行查询. 初始化 dns_client 如果转发端口开启 HTTPS, 加载转发使用的 SSL 证书、秘钥 加载集群数据层面、控制层面 SSL 证书、秘钥 加载插件数据库实体模型(schema)是通过 DB.__index 元方法加载 DAO 中的 ‘plugins’. 构建插件迭代器:插件配置的 ‘combos’ 数组, 通过 ‘combos’ 可以实现插件配置优先级. Route、Service、Consumer 相互组合后优先级. 在一次请求中, 最多运行插件一次, 但是插件使用的配置可以有多种选择. 选择使用 Service、Route、Consumer 的配置是有优先级顺序的.插件可以介入多个处理阶段(init_worker/access…), 在插件迭代器构建阶段, 会将插件的处理函数插入 workspace 中阶段表中. 路由初始化构建路由匹配表, 路由匹配优先级: 完整域名 &gt; 正则域名 &gt; 请求头特征多 &gt; 请求头特征少 &gt; 正则优先级高 &gt; 正则优先级低 &gt; URI 路径长 &gt; URI 路径短 &gt; 创建时间晚 &gt; 创建时间早. 详见四 数据层面代码 - 路由初始化. 3. init_worker 数据库、缓存初始化 创建统计信息上报定时器, 定时向 kong-hf.konghq.com 发送报告, 将统计信息上报 检查插件是否更新, 构建插件迭代器(plugins_iterator) 插件初始化 4. ssl_certificate 根据 SNI(非请求头 host)查找对应的证书、私钥, 并更新到请求信息中 执行插件 5. rewrite 执行插件 6. access 路由匹配, 未匹配返回 404 balancer 预处理: 初始化 balancer_data, 设置默认超时时间、重试次数; service 证书、秘钥处理 websocket 升级处理、XFF 头处理 如果 service 使用 grpc 协议, 跳转到 grpc location 处理 根据路由是否启用请求体、响应体缓存, 跳转到相应 location 处理 执行插件 balancer 执行:将数据库 upstream 表中所有 upstream 加载到进程内(在 init 阶段可能已经加载到进程内).根据路由匹配的 service 名, 从 upstream 字典中查找 upstream.根据 upstream.id 从缓存获取或创建 balancer 对象, 支持: 一致哈希(resty.dns.balancer.consistent_hashing)、最小连接(resty.dns.balancer.least_connections)、轮询(resty.dns.balancer.ring)三种负载均衡器. 从缓存或数据中获取 upstream 的负载实例(target), 并添加到负载均衡器中. 创建相应的健康检查对象, 并缓存负载均衡对象. 尝试使用 balancer 对象查找负载实例, 失败则直接响应 503.如果未查找到 balancer 对象, 使用 dns 解析(resty.dns.client)域名获得 IP、Port.保存获取到的 IP、Port 转发使用. 7. balancer 通过 balancer 对象获取负载实例, 设置后端实例 IP、Port. 如果是重试进入 balancer 阶段, 上报上个实例的健康状态 设置实例超时时间 设置 keepalive (kong 修改了 lua-nginx-module, 可以通过 lua 代码控制开启长连接) 8. header filter websocket upgrade 处理, 请求头过滤 执行插件 9. body filter 执行插件 10. log 执行插件 balancer 健康检查上报 四 数据层面代码 - 路由初始化在 ‘init’ 阶段会进行路由初始化, 构建路由匹配表. 1. 优先级路由匹配优先级: 完整域名 &gt; 正则域名 &gt; 请求头特征多 &gt; 请求头特征少 &gt; 正则优先级高 &gt; 正则优先级低 &gt; URI 路径长 &gt; URI 路径短 &gt; 创建时间晚 &gt; 创建时间早. 2. 路由分类累加路由启用的匹配类别得到路由匹配类别(categories), 依次路由匹配特征以特征值为键, 路由为值保存到匹配表中. 在路由分类处理中, 使用路由的 ‘match_weight’ 作为类别的 ‘match_weight’, 因为路由已经根据优先级进行排序, 类别的 ‘match_weight’ 是本类别中所有路由最大的 ‘match_weight’. 路由类别(categories)会根据优先级从高到低进行排序, 在路由匹配过程中会尝试从高优先级开启匹配, 直至匹配成功. 3. 路由匹配路由匹配逻辑复杂, 会先根据请求特征(方法、URI、域名、源地址/端口、目的地址/端口、SNI)从缓存中获取历史匹配结果. 缓存获取失败, 会根据请求头、域名、URI、方法、源/目的地址、SNI单独匹配, 记录适用匹配类别和命中的特征(每各类别仅命中一次). 在构建匹配索引(‘plain_indexes’, ‘prefix_uris’, ‘regex_uris’…)时已经根据路由优先级排好序, 高优先级在前.使用上一步的处理结果, 遍历比命中的匹配类别低的所有类别; 对于每个类别, 取类别中 routes_by_hosts/routes_by_headers… 中最小数量的路由数组(使用最小集合进行匹配, 提高效率; 最小集合匹配失败后会遍历所有路由进行匹配). 对于集合(最小集合/全部路由集合)中的每个路由, 使用匹配的请求特征进行匹配, 路由必须满着所有匹配的请求特征. 代码: 1234567891011121314151617181920212223242526272829303132333435--- ctx 中保存有匹配的请求特征值match_route = function(route_t, ctx) -- run cached matcher if type(matchers[route_t.match_rules]) == &quot;function&quot; then clear_tab(ctx.matches) return matchers[route_t.match_rules](route_t, ctx) end -- build and cache matcher local matchers_set = &#123;&#125; for _, bit_match_rule in pairs(MATCH_RULES) do --- 遍历特征 匹配 if band(route_t.match_rules, bit_match_rule) ~= 0 then matchers_set[#matchers_set + 1] = matchers[bit_match_rule] end end matchers[route_t.match_rules] = function(route_t, ctx) -- clear matches context for this try on this route clear_tab(ctx.matches) -- 路由 route_t 必须满足匹配的所有特征 for i = 1, #matchers_set do if not matchers_set[i](route_t, ctx) then return end end return true end return matchers[route_t.match_rules](route_t, ctx)end 路由构建, 路由分类函数 ‘categorize_route_t’ 代码片段: 123456789101112131415161718... -- init, omitinsert(category.all, route_t)for _, host_t in ipairs(route_t.hosts) do if not category.routes_by_hosts[host_t.value] then category.routes_by_hosts[host_t.value] = &#123;&#125; end insert(category.routes_by_hosts[host_t.value], route_t)end--- omit code,--- category.routes_by_headers--- category.routes_by_uris--- category.routes_by_methods--- category.routes_by_sources--- category.routes_by_destinations--- category.routes_by_sni 分类后 ‘categories’ 结构示意: 12345678910111213141516&#123; &quot;category_bit, 类别二进制位&quot; : &#123; &quot;match_weight&quot;: &quot;同类别中, 最高优先级路由的匹配权重&quot;, &quot;all&quot; : [ &quot;route-1 对象&quot;, &quot;route-2 对象&quot; ], &quot;routes_by_hosts&quot;: &#123; &quot;host-a&quot; : [&quot;route-1 对象&quot;, &quot;route 对象&quot;], &quot;host-b&quot; : [&quot;route-1 对象&quot;] &#125;, &quot;routes_by_headers&quot; : &#123; &quot;header&quot; : [&quot;route 对象&quot;] &#125;, &quot;routes_by_uris&quot; : &#123; &quot;uri&quot; : [&quot;route 对象&quot;] &#125;, &quot;routes_by_methods&quot; : &#123; &quot;method&quot; : [&quot;route 对象&quot;] &#125;, &quot;routes_by_sources&quot; : &#123; &quot;source&quot; : [&quot;route 对象&quot;] &#125;, &quot;routes_by_destinations&quot; : &#123; &quot;dest&quot; : [&quot;route 对象&quot;] &#125;, &quot;routes_by_sni&quot; : &#123; &quot;sni&quot; : [&quot;route 对象&quot;] &#125;, &#125;&#125; 地址/端口: 目的地址、端口其实是 Nginx 接收请求时 Server 端的地址、端口.地址端口匹配用于 Stream 模式. 路由匹配实现函数 ‘find_route’ 代码片段: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495-- header matchfor _, header_name in ipairs(plain_indexes.headers) do if req_headers[header_name] then req_category = bor(req_category, MATCH_RULES.HEADER) hits.header_name = header_name break // 匹配后结束 header 类别匹配 endend-- host matchif plain_indexes.hosts[host_with_port] or plain_indexes.hosts[host_no_port] then req_category = bor(req_category, MATCH_RULES.HOST)elseif ctx.req_host then for i = 1, #wildcard_hosts do local from, _, err = re_find(host_with_port, wildcard_hosts[i].regex, &quot;ajo&quot;) ... -- omit if from then hits.host = wildcard_hosts[i].value req_category = bor(req_category, MATCH_RULES.HOST) break end endend-- uri matchfor i = 1, #regex_uris do local from, _, err = re_find(req_uri, regex_uris[i].regex, &quot;ajo&quot;) ... -- omit if from then hits.uri = regex_uris[i].value req_category = bor(req_category, MATCH_RULES.URI) break endendif not hits.uri then if plain_indexes.uris[req_uri] then hits.uri = req_uri req_category = bor(req_category, MATCH_RULES.URI) else for i = 1, #prefix_uris do if find(req_uri, prefix_uris[i].value, nil, true) == 1 then hits.uri = prefix_uris[i].value req_category = bor(req_category, MATCH_RULES.URI) break end end endend-- method matchif plain_indexes.methods[req_method] then req_category = bor(req_category, MATCH_RULES.METHOD)end-- src matchif plain_indexes.sources[ctx.src_ip] then req_category = bor(req_category, MATCH_RULES.SRC)elseif plain_indexes.sources[ctx.src_port] then req_category = bor(req_category, MATCH_RULES.SRC)else for i = 1, #src_trust_funcs do if src_trust_funcs[i](ctx.src_ip) then req_category = bor(req_category, MATCH_RULES.SRC) break end endend-- dst matchif plain_indexes.destinations[ctx.dst_ip] then req_category = bor(req_category, MATCH_RULES.DST)elseif plain_indexes.destinations[ctx.dst_port] then req_category = bor(req_category, MATCH_RULES.DST)else for i = 1, #dst_trust_funcs do if dst_trust_funcs[i](ctx.dst_ip) then req_category = bor(req_category, MATCH_RULES.DST) break end endend-- sni matchif plain_indexes.snis[ctx.sni] then req_category = bor(req_category, MATCH_RULES.SNI)end 五 数据层面代码 - 事件触发与管理API1. 事件在 init_worker 阶段 runloop 执行 register_events 函数, 注册 routes/services/plugins/upstreams/targes 的 ‘crud’ 事件处理回调. 对于 routes/service/plugins 会使当前版本无效, 触发重建对象. 对于 upstreams 变动会发布 balancer 事件. 在 init_worker 阶段 runloop.balancer 模块执行初始化动作: 从数据库查询 upstream, 创建 balancer, 并创建定时器检查 upstream 是否有更新, 更新后查询所有的 upstream 更新到 ‘kong.core_cache’(共享内存) 中. 2. 管理 API 管理端会调用节点 API 接口, 触发事件处理. Kong 使用 Lapis 框架提供管理 API, 所有的管理 API 位于 ‘kong.api’ 包下. ‘admin_content’ 函数使 API 入口, 在 ‘serve_content’ 中会调用 lapis.serve(&#39;kong.api&#39;) 使用 ‘kong.api’ 中所有路由进行管理. 读下 lapis 框架 serve 函数可以发现 serve 使用 require 加载模块, 并建立路由匹配对象进行请求处理. service/route/upstream 管理 API 是通过 ‘kong.api.endpoints’ 模块中 ‘generate_collection_endpoints’ 函数创建, 在 ‘kong.api’ 加载时会调用. POST 调用接口时将数据保存到数据库中, 会调用 DAO 对象的 ‘insert’ 方法调用 post_crud_event 发布 ‘worker-events’ 事件, 触发在 runloop.init_worker 中注册的回调函数进行更新操作. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263-- 生成通用 API 函数local function generate_collection_endpoints(endpoints, schema, foreign_schema, foreign_field_name) local collection_path if foreign_schema then collection_path = fmt(&quot;/%s/:%s/%s&quot;, foreign_schema.admin_api_name or foreign_schema.name, foreign_schema.name, schema.admin_api_nested_name or schema.admin_api_name or schema.name) else collection_path = fmt(&quot;/%s&quot;, schema.admin_api_name or schema.name) end endpoints[collection_path] = &#123; schema = schema, methods = &#123; --OPTIONS = method_not_allowed, --HEAD = method_not_allowed, GET = get_collection_endpoint(schema, foreign_schema, foreign_field_name), POST = post_collection_endpoint(schema, foreign_schema, foreign_field_name), --PUT = method_not_allowed, --PATCH = method_not_allowed, --DELETE = method_not_allowed, &#125;, &#125;endlocal function post_collection_endpoint(schema, foreign_schema, foreign_field_name, method) return function(self, db, helpers, post_process) if foreign_schema then local foreign_entity, _, err_t = select_entity(self, db, foreign_schema) if err_t then return handle_error(err_t) end if not foreign_entity then return not_found() end self.args.post[foreign_field_name] = foreign_schema:extract_pk_values(foreign_entity) end -- 数据插入数据库 local entity, _, err_t = insert_entity(self, db, schema, method) if err_t then return handle_error(err_t) end -- 调用注册回调方法 if post_process then entity, _, err_t = post_process(entity) if err_t then return handle_error(err_t) end end return created(entity) endend 六 负载选择kong 使用 lua-resty-dns-client 进行负载选择, 借助 lua-resty-dns 实现域名解析. 在 lua-resty-dns-client 中抽象出 balancer/host/address 对象, balancer-host, host-address 都是一对多关系, 在负载选择最后使用 address 作为结果进行转发. 在生产环境中应该考虑 host 权重与 address 权重问题, lua-resty-dns-client 对此有阐述. kong 支持轮询、哈希、最小连接负载方式, 完全由 Lua 代码实现. 1. 轮询使用表 wheel 存储 address 对象,在实现中使用 randomlist 生成一个随机序列, 用来实现负载随机分布. 每个 address 对象会存储其占用的索引, 用于释放索引时使用. wheel 中所有记录都会被占满, 不会有空隙. 12345678910111213141516171819202122232425262728293031323334353637383940414243function _M.new(opts) -- ... 忽略无关代码 local self = assert(balancer_base.new(opts)) -- .. -- inject additional properties self.wheel = nil -- 用于存储负载地址的表 self.pointer = nil -- 轮询时下个待选择地址 self.wheelSize = opts.wheelSize or 1000 -- 负载地址表大小 self.unassignedWheelIndices = nil -- wheel 中未分配的索引 -- ring_balancer 对 balancer_base 继承 -- inject overridden methods for name, method in pairs(ring_balancer) do self[name] = method end -- initialize the balancer self.wheel = new_tab(self.wheelSize, 0) self.unassignedWheelIndices = new_tab(self.wheelSize, 0) self.pointer = math.random(1, self.wheelSize) -- ensure each worker starts somewhere else -- Create a list of entries, and randomize them. local unassignedWheelIndices = self.unassignedWheelIndices local duplicateCheck = new_tab(self.wheelSize, 0) -- 使用 randomlist 创建一个 1-wheelSize 范围的随机数数组, 数值不会重复. 用于将负载地址随机分布在 wheel 数组中 local orderlist = opts.order or randomlist(self.wheelSize) for i = 1, self.wheelSize do local order = orderlist[i] unassignedWheelIndices[i] = order end -- Sort the hosts, to make order deterministic -- ... table_sort(hosts, function(a,b) return (a.name..&quot;:&quot;..(a.port or &quot;&quot;) &lt; b.name..&quot;:&quot;..(b.port or &quot;&quot;)) end) -- Insert the hosts -- 添加地址, 并在 wheel 中添加索引 for _, host in ipairs(hosts) do local ok, err = self:addHost(host.name, host.port, host.weight) end return selfend 地址变更后调用 redistributeIndices 重新分配各个负载在 ‘wheel’ 中的分布: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273function ring_balancer:redistributeIndices() local totalWeight = self.weight -- Host 变更时会在 base 中会修改 weight local movingIndexList = self.unassignedWheelIndices -- NOTE: calculations are based on the &quot;remaining&quot; indices and weights, to -- prevent issues due to rounding: eg. 10 equal systems with 19 indices. -- Calculated to get each 1.9 indices =&gt; 9 systems would get 1, last system would get 10 -- by using &quot;remaining&quot; indices, the first would get 1 index, the other 9 would get 2. -- first; reclaim extraneous indices local weightLeft = totalWeight local indicesLeft = self.wheelSize local addList = &#123;&#125; -- addresses that need additional indices local addListCount = &#123;&#125; -- how many extra indices the address needs local addCount = 0 local dropped, added = 0, 0 -- 便利所有负载 for weight, address, _ in self:addressIter() do -- 根据权重, 计算负载索引个数 local count if weightLeft == 0 then count = 0 else count = math_floor(indicesLeft * (weight / weightLeft) + 0.0001) -- 0.0001 to bypass float arithmetic issues end local drop = #address.indices - count if drop &gt; 0 then -- we need to reclaim some indices address:dropIndices(movingIndexList, drop) dropped = dropped + drop elseif drop &lt; 0 then -- this one needs extra indices, so record the changes needed -- 记录需要添加索引的地址, 稍后为地址分配索引 addCount = addCount + 1 addList[addCount] = address addListCount[addCount] = -drop -- negate because we need to add them end indicesLeft = indicesLeft - count weightLeft = weightLeft - weight end -- 为地址分配索引 -- second: add freed indices to the recorded addresses that were short of them for i, address in ipairs(addList) do address:addIndices(movingIndexList, addListCount[i]) added = added + addListCount[i] end return selfendfunction ring_address:addIndices(availableIndicesList, count) count = count or #availableIndicesList if count &gt; 0 then local myWheelIndices = self.indices local size = #myWheelIndices -- ... local wheel = self.host.balancer.wheel local lsize = #availableIndicesList + 1 for i = 1, count do -- 获取一个未分配索引 local availableIdx = lsize - i local wheelIdx = availableIndicesList[availableIdx] availableIndicesList[availableIdx] = nil -- 当前地址增加一个索引,(地址删除索引时使用) myWheelIndices[size + i] = wheelIdx wheel[wheelIdx] = self end end return selfend 2. 一致哈希与轮询相似, 使用表 continuum 存储所有负载, 每个负载根据权重得出其在 continuum 表中的索引条数. 在添加负载时会根据 IP、Port、第几条索引计算哈希值, 确定其在 continuum 表中的索引, 参见 consistent_hashing:afterHostUpdate 函数. 负载选择时会根据哈希值选择负载, 如果 continuum 表中条目为空则索引减一尝试选择之前索引, 参见 consistent_hashing:getPeer 函数. 3. 最小连接与 Nginx 实现不同, Kong 实现的最小连接是通过使用最小堆记录每个负载的连接数, 选择连接数最小的负载. 使用者需要在负载使用完毕后调用(或通过 GC 触发) release 方法更新负载连接数. 七 konga可以使用 konga 作为管理端, 在编译时需要使用 node 10.x 版本, 安装操作: 123456789101112131415npm install -g n#切换到 10.24.0sudo n v10.24.0node -v# 数据库初始化su - postgrespsql# 创建用户CREATE USER konga WITH PASSWORD &#x27;konga&#x27;;# 创建数据库CREATE DATABASE konga OWNER konga;# 授权GRANT ALL PRIVILEGES ON DATABASE konga TO konga; 参考文档 教你使用luarocks来创建rock包 Kong Api kong admin ui demo kong admin ui Lapis openresty-notes-lapis","categories":[{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/categories/NGINX/"}],"tags":[{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/tags/NGINX/"},{"name":"OpenResty","slug":"OpenResty","permalink":"https://juzipeek.github.io/tags/OpenResty/"},{"name":"Kong","slug":"Kong","permalink":"https://juzipeek.github.io/tags/Kong/"}]},{"title":"Kong 初探","slug":"nginx-2020-08-22-kong","date":"2022-09-03T12:55:44.522Z","updated":"2022-09-03T12:55:44.522Z","comments":true,"path":"2022/09/03/nginx-2020-08-22-kong/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/nginx-2020-08-22-kong/","excerpt":"","text":"安装测试使用 docker 搭建 kong 测试环境. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697## 创建 postgre 数据库, 没有密码docker run -d \\--name kong-database \\-p 5432:5432 \\-e &quot;POSTGRES_USER=kong&quot; \\-e &quot;POSTGRES_DB=kong&quot; \\-e &quot;POSTGRES_HOST_AUTH_METHOD=trust&quot; \\postgres:9.6## db initdocker run --rm \\--link kong-database:kong-database \\-e &quot;KONG_DATABASE=postgres&quot; \\-e &quot;KONG_PG_HOST=kong-database&quot; \\kong kong migrations bootstrap## 创建容器并运行docker run -d --name kong \\--link kong-database:kong-database \\-e &quot;KONG_DATABASE=postgres&quot; \\-e &quot;KONG_PG_HOST=kong-database&quot; \\-e &quot;KONG_PROXY_ACCESS_LOG=/dev/stdout&quot; \\-e &quot;KONG_ADMIN_ACCESS_LOG=/dev/stdout&quot; \\-e &quot;KONG_PROXY_ERROR_LOG=/dev/stderr&quot; \\-e &quot;KONG_ADMIN_ERROR_LOG=/dev/stderr&quot; \\-e &quot;KONG_ADMIN_LISTEN=0.0.0.0:8001, 0.0.0.0:8444 ssl&quot; \\-p 8000:8000 \\-p 8443:8443 \\-p 8001:8001 \\-p 8444:8444 \\kong## konga kong 管理端## konga 数据库准备docker run --rm \\--link kong-database:kong-database \\pantsel/konga -c prepare -a postgres -u postgresql://kong@kong-database:5432/konga_db--network=kong-net \\## konga 启动docker run -d -p 1337:1337 \\--link kong-database:kong-database \\-e &quot;DB_ADAPTER=postgres&quot; \\-e &quot;DB_HOST=kong-database&quot; \\-e &quot;DB_USER=kong&quot; \\-e &quot;DB_DATABASE=konga_db&quot; \\-e &quot;KONGA_HOOK_TIMEOUT=120000&quot; \\-e &quot;NODE_ENV=production&quot; \\--name konga \\pantsel/konga# 访问 kongahttp://127.0.0.1:1337# kong 运行docker start kongdocker stop kong# 杀掉容器docker kill kong# 删除容器docker rm kongdocker rm kong-databasedocker attach --sig-proxy=false kong# 进入容器内docker exec -it kong /bin/bash# kong-docker 日志输出在终端, 使用 docker log 查看日志docker log -f kongdocker ps -a# 通过 konga 添加 service, route, upstream.# 添加服务curl -i -X POST \\--url http://localhost:8001/services/ \\--data &#x27;name=example-service&#x27; \\--data &#x27;url=http://mockbin.org&#x27;# 添加路由curl -i -X POST \\--url http://localhost:8001/services/example-service/routes \\--data &#x27;hosts[]=example.com&#x27;# 测试命令curl -i -X GET \\--url http://localhost:8000/ \\--header &#x27;Host: example.com&#x27;curl -i \\-H &quot;Host: echo_server&quot; \\http://10.161.112.28:8000/acurl -i \\-H &quot;Host: echo-ip&quot; \\http://10.161.112.28:8000/a 概述kong 有三个核心概念: route, service, upstream. upstream 管理后端服务负载, route 用来匹配客户端请求, service 用来将两者进行耦合, 所有的 route 必须归属于 service, 由 service 确定 upstream. Kong 在 access 阶段进行路由匹配, 关键函数是 router.lua::exec. 在 access.after 阶段进行 balancer 处理, 确定使用的 upstream, target. upstream 定义负载选择方法和健康检查信息, target 定义负载主机信息. 路由匹配路由匹配核心是根据请求特征查找 service. 在请求处理 access 阶段会进行路由匹配(kong/runloop/handler.lua::access.before), 路由匹配核心是 kong/router.lua 库. kong 将所有路由放在表中进行处理. 在 access.before 阶段还会根据 service 数据进行负载均衡预处理. 负载均衡kong 支持三种负载管理: DNS, Upstream, IP. 在 service 中配置的 host 如果在 Upstream 能找到, 则使用 Upstream 中的负载作为转发后端; 如果未找到, 则使用 DNS 进行解析, 使用得到的机器作为转发后端. 如果在 service 中配置的是 IP 地址, 则直接使用 IP 地址作为转发后端. 在 kong/runloop/balancer.lua::attach_healthchecker_to_balancer 函数中注册了健康检查回调, 在负载健康检查状态发生变化时通过回调调用 balancer:setAddressStatus 将负载置为可用或不可用. 函数 setAddressStatus 定义在 resty/dns/balancer 库中. 插件处理除了插件自身的功能外需要考虑两点: 插件如何与路由绑定, 每个路由的插件配置是否相同.在 init worker 阶段会执行 update_plugins_iterator 创建全局插件迭代器 plugins_iterator.在请求处理过程中, kong 会在 rewrite 阶段会调用 execute_plugins_iterator 遍历插件调用 rewrite 阶段处理函数. rewrite 阶段是首次调用插件迭代器, 请求与插件匹配逻辑是在插件迭代器中实现(kong/runloop/plugins_iterator.lua::get_next 函数).","categories":[{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/categories/NGINX/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/tags/NGINX/"},{"name":"Kong","slug":"Kong","permalink":"https://juzipeek.github.io/tags/Kong/"}]},{"title":"proxy_request_buffering 请求体缓存","slug":"nginx-2020-11-21-proxy-request-buffering","date":"2022-09-03T12:55:44.522Z","updated":"2022-09-03T12:55:44.522Z","comments":true,"path":"2022/09/03/nginx-2020-11-21-proxy-request-buffering/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/nginx-2020-11-21-proxy-request-buffering/","excerpt":"","text":"概述ngx_http_proxy_module 模块提供了 proxy_request_buffering 和 proxy_buffering 两个配置项, 分别用于控制是否缓冲请求/应答. 当开启时, 客户端请求和上游应答会先在 NGINX 内暂存, 当接收到完整的请求应答后才会转发给上游或客户端. 如下图所示: 12345---------- ----------- -----------| | ---- req-ori ---&gt; |buffering| ---- req-proxy ---&gt; | || client | | NGINX | | backend || | &lt;--- resp-ori ---- |buffering| &lt;--- resp-proxy ---- | |---------- ----------- ----------- 默认情况下, NGINX 会缓冲请求/应答, 我认为这样做的目的是为了减轻上游的压力. 当代理服务器与上游服务器之间网络状况良好时, req/resp-proxy 持续时间会更短. 配置项: 1234567 Syntax: proxy_request_buffering on | off;Default: proxy_request_buffering on;Context: http, server, locationSyntax: proxy_buffering on | off;Default: proxy_buffering on;Context: http, server, location","categories":[{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/categories/NGINX/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/tags/NGINX/"}]},{"title":"HTTP Range 缓存","slug":"nginx-2020-05-01-http-range-and-cache","date":"2022-09-03T12:55:44.521Z","updated":"2022-09-03T12:55:44.521Z","comments":true,"path":"2022/09/03/nginx-2020-05-01-http-range-and-cache/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/nginx-2020-05-01-http-range-and-cache/","excerpt":"","text":"HTTP Range 请求如果 HTTP 请求的头部有 Range 头, 如 Range: bytes=1024-2047 表示客户端请求文件的第 1025 到第 2048 个字节内容(以 0 为索引开始). 这时服务器只会响应文件的这部分内容, 响应的状态码为 206, 表示返回的是响应的一部分. 如果服务器不支持 Range 请求, 仍然会返回整个文件, 这时状态码仍是 200. Range 请求需要服务端支持, 使用 NGINX 搭建静态页面服务方便演示. 测试示例12345678910111213141516171819proxy_cache_path /tmp/cache levels=1:2 keys_zone=cache:100m; server &#123; listen 8000 default_server; location /doc &#123; add_header Accept-Ranges bytes; alias /tmp/website/; &#125; location / &#123; slice 100k; proxy_cache cache; proxy_cache_key $uri$slice_range; proxy_set_header Range $slice_range; proxy_cache_valid 200 206 1h; proxy_pass http://127.0.0.1:8000/doc/bigfile.txt; &#125;&#125; 测试命令: 12345$curl -o /dev/null -i -v &quot;http://127.0.0.1:8000/&quot;$curl -o /dev/null -i -v -r 0,10 &quot;http://127.0.0.1:8000/&quot;$curl -o /dev/null -i -H &quot;Range: bytes=0-10&quot; -v &quot;http://127.0.0.1:8000/&quot;$curl -o /dev/null -i -H &quot;Range: bytes=0-10, 11-30&quot; -v &quot;http://127.0.0.1:8000/&quot;$curl -o /dev/null -i -H &quot;Range: bytes=0-10, 102500-102510&quot; -v &quot;http://127.0.0.1:8000/&quot; 源码阅读nginx 官方提供 slice 模块用于将响应按固定大小进行切分, 单纯的切分并没有太大意义, 当切分与缓存功能配合就非常有价值: 大文件切分后可以并行使用 Range 请求多个片段提高效率. 通过 nginx 进行反向代理, 如果根据 Range 头创建缓存键是不合理的. 使用 slice 模块, 内容按固定区间进行切分并确定缓存键. 客户端会接收到 Content-Range: bytes 234-639/8000 应答头, 客户端应以 Content-Range 为准而非 Range 请求头. 1. slice_range 变量获取slice_range 变量用于获取”当前” range 的起止偏移, 类似 bytes=0-1023 格式. 偏移是根据 slice 指令配置对齐的. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354static ngx_int_tngx_http_slice_range_variable(ngx_http_request_t *r, ngx_http_variable_value_t *v, uintptr_t data)&#123; u_char *p; ngx_http_slice_ctx_t *ctx; ngx_http_slice_loc_conf_t *slcf; ctx = ngx_http_get_module_ctx(r, ngx_http_slice_filter_module); // 访问 slice_range 变量并不会更新 range 的起止位置, `slice_filter` 模块在 `ngx_http_slice_header_filter` 处理中会更新 `start` 偏移. if (ctx == NULL) &#123; if (r != r-&gt;main || r-&gt;headers_out.status) &#123; v-&gt;not_found = 1; return NGX_OK; &#125; slcf = ngx_http_get_module_loc_conf(r, ngx_http_slice_filter_module); if (slcf-&gt;size == 0) &#123; v-&gt;not_found = 1; return NGX_OK; &#125; ctx = ngx_pcalloc(r-&gt;pool, sizeof(ngx_http_slice_ctx_t)); if (ctx == NULL) &#123; return NGX_ERROR; &#125; ngx_http_set_ctx(r, ctx, ngx_http_slice_filter_module); p = ngx_pnalloc(r-&gt;pool, sizeof(&quot;bytes=-&quot;) - 1 + 2 * NGX_OFF_T_LEN); if (p == NULL) &#123; return NGX_ERROR; &#125; // ngx_http_slice_get_start 函数用于从 range 请求头获取开始字节数 // 计算出边界 ctx-&gt;start = slcf-&gt;size * (ngx_http_slice_get_start(r) / slcf-&gt;size); ctx-&gt;range.data = p; ctx-&gt;range.len = ngx_sprintf(p, &quot;bytes=%O-%O&quot;, ctx-&gt;start, ctx-&gt;start + (off_t) slcf-&gt;size - 1) - p; &#125; v-&gt;data = ctx-&gt;range.data; v-&gt;valid = 1; v-&gt;not_found = 0; v-&gt;no_cacheable = 1; v-&gt;len = ctx-&gt;range.len; return NGX_OK;&#125; 2. proxy_set_headerproxy_set_header 用于在发往上游的请求中添加请求头, 在配置解析阶段, proxy_set_header 指令处理函数会在当前 location 配置项 headers_source 数组添加自定义请求头. 在创建发送到上游的请求时, 会根据自定义请求头构建请求.除自定义请求头外 proxy_pass 模块会默认添加一部分请求头, 在 ngx_http_proxy_headers 表(开启缓存时使用 ngx_http_proxy_cache_headers 表)有定义. 3. create requestproxy_pass 模块会在 CONTENT 阶段介入请求处理, 当开启缓存功能时会在共享内存中保存缓存键, 在磁盘文件保存缓存数据. 在 ngx_http_upstream_init_request 函数处理中会调用 ngx_http_proxy_create_request 函数创建发送到上游的请求. 4. ngx_http_slice_header_filter在请求处理过程中, header_filter 和 body_filter 是在应答阶段触发, header_filter 会先被触发, 并且只会被触发一次. slice 模块会在 header_filter 做更新请求上下文中的 start 偏移, 用于下次子请求时作为 range 头起始偏移. 代码中判断 ctx == NULL 是因为 slice 模块有固定的使用方式(在 proxy_pass 中增加 Range 请求头, 并通过 slice 模块计算 range 偏移), 如果不按使用方式使用, slice 模块不处理. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112static ngx_int_tngx_http_slice_header_filter(ngx_http_request_t *r)&#123; off_t end; ngx_int_t rc; ngx_table_elt_t *h; ngx_http_slice_ctx_t *ctx; ngx_http_slice_loc_conf_t *slcf; ngx_http_slice_content_range_t cr; ctx = ngx_http_get_module_ctx(r, ngx_http_slice_filter_module); // ctx 为空, 之前肯定没有使用 slice_range 变量, 不需要 slice 模块介入 if (ctx == NULL) &#123; return ngx_http_next_header_filter(r); &#125; if (r-&gt;headers_out.status != NGX_HTTP_PARTIAL_CONTENT) &#123; if (r == r-&gt;main) &#123; ngx_http_set_ctx(r, NULL, ngx_http_slice_filter_module); return ngx_http_next_header_filter(r); &#125; ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0, &quot;unexpected status code %ui in slice response&quot;, r-&gt;headers_out.status); return NGX_ERROR; &#125; h = r-&gt;headers_out.etag; if (ctx-&gt;etag.len) &#123; if (h == NULL || h-&gt;value.len != ctx-&gt;etag.len || ngx_strncmp(h-&gt;value.data, ctx-&gt;etag.data, ctx-&gt;etag.len) != 0) &#123; ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0, &quot;etag mismatch in slice response&quot;); return NGX_ERROR; &#125; &#125; if (h) &#123; ctx-&gt;etag = h-&gt;value; &#125; // 解析 content-range 应答头中的应答范围 if (ngx_http_slice_parse_content_range(r, &amp;cr) != NGX_OK) &#123; ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0, &quot;invalid range in slice response&quot;); return NGX_ERROR; &#125; if (cr.complete_length == -1) &#123; ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0, &quot;no complete length in slice response&quot;); return NGX_ERROR; &#125; ngx_log_debug3(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, &quot;http slice response range: %O-%O/%O&quot;, cr.start, cr.end, cr.complete_length); slcf = ngx_http_get_module_loc_conf(r, ngx_http_slice_filter_module); end = ngx_min(cr.start + (off_t) slcf-&gt;size, cr.complete_length); if (cr.start != ctx-&gt;start || cr.end != end) &#123; ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0, &quot;unexpected range in slice response: %O-%O&quot;, cr.start, cr.end); return NGX_ERROR; &#125; // 更新 range 起始偏移 ctx-&gt;start = end; ctx-&gt;active = 1; r-&gt;headers_out.status = NGX_HTTP_OK; r-&gt;headers_out.status_line.len = 0; r-&gt;headers_out.content_length_n = cr.complete_length; r-&gt;headers_out.content_offset = cr.start; r-&gt;headers_out.content_range-&gt;hash = 0; r-&gt;headers_out.content_range = NULL; r-&gt;allow_ranges = 1; r-&gt;subrequest_ranges = 1; r-&gt;single_range = 1; rc = ngx_http_next_header_filter(r); if (r != r-&gt;main) &#123; return rc; &#125; r-&gt;preserve_body = 1; if (r-&gt;headers_out.status == NGX_HTTP_PARTIAL_CONTENT) &#123; if (ctx-&gt;start + (off_t) slcf-&gt;size &lt;= r-&gt;headers_out.content_offset) &#123; ctx-&gt;start = slcf-&gt;size * (r-&gt;headers_out.content_offset / slcf-&gt;size); &#125; ctx-&gt;end = r-&gt;headers_out.content_offset + r-&gt;headers_out.content_length_n; &#125; else &#123; ctx-&gt;end = cr.complete_length; &#125; return rc;&#125; 5. ngx_http_slice_body_filter在接收完上游应答后, 通过子请求方式再次发起 range 请求, 每个 slice 区间会创建一个独立子请求(顺序创建, 非并发创建). 每个子请求同样会经过 header_filter 和 body_filter 处理阶段, 在子请求的 header_filter 阶段会更新请求上下文中的 start 偏移. 子请求处理完毕后会调用父请求的 r-&gt;write_event_handler(是 ngx_http_writer 函数), 在 ngx_http_writer 会调用 ngx_http_output_filter 函数, 触发父请求的 body_filter 调用, 进而再次进入 slice 模块的 body_filter 处理, 继续创建子请求. 6. 其他说明在 slice 模块, 创建子请求时使用 NGX_HTTP_SUBREQUEST_CLONE 调用 ngx_http_subrequest, 创建的子请求会从 CONTENT 阶段开始执行. 缓存文件创建是在对上游包体应答处理过程中实现的, 在 ngx_http_upstream_process_request 函数中, 会将 proxy_pass 临时文件文件(在 $workdir/proxy_temp 目录下)异动到缓存目录, 并使用缓存键作为文件名. 参考链接-Nginx的文件分片-slice模块-尝鲜：Nginx-1.9.8 推出的切片模块","categories":[{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/categories/NGINX/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/tags/NGINX/"}]},{"title":"Nginx 路由匹配","slug":"nginx-2020-03-28-location-match","date":"2022-09-03T12:55:44.520Z","updated":"2022-09-03T12:55:44.520Z","comments":true,"path":"2022/09/03/nginx-2020-03-28-location-match/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/nginx-2020-03-28-location-match/","excerpt":"","text":"一 概述在看路由匹配树构建与匹配代码时发现有 auto_redirect 类型 location, 印象中并没有此种类型配置, 梳理出文档加深记忆. 二 路由匹配路由匹配分成精确/前缀匹配和正则匹配两个阶段, 精确/前缀匹配是通过遍历 server 下的二叉树实现的, 正则匹配是通过遍历 server 下的正则匹配数组实现的. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/* * NGX_OK - exact or regex match * NGX_DONE - auto redirect * NGX_AGAIN - inclusive match * NGX_ERROR - regex error * NGX_DECLINED - no match */static ngx_int_tngx_http_core_find_location(ngx_http_request_t *r)&#123; noregex = 0; pclcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module); // 遍历匹配树 rc = ngx_http_core_find_static_location(r, pclcf-&gt;static_locations); // 前缀匹配 if (rc == NGX_AGAIN) &#123; // 在递归查找过程中会修改 r-&gt;loc_conf, 先保存当前层级匹配的前缀匹配是否允许正则匹配 clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module); noregex = clcf-&gt;noregex; /* look up nested locations */ rc = ngx_http_core_find_location(r); &#125; if (rc == NGX_OK || rc == NGX_DONE) &#123; return rc; &#125; /* rc == NGX_DECLINED or rc == NGX_AGAIN in nested location */ // 当前层级启用进行正则匹配 if (noregex == 0 &amp;&amp; pclcf-&gt;regex_locations) &#123; // 遍历正则匹配数组 for (clcfp = pclcf-&gt;regex_locations; *clcfp; clcfp++) &#123; ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, &quot;test location: ~ \\&quot;%V\\&quot;&quot;, &amp;(*clcfp)-&gt;name); n = ngx_http_regex_exec(r, (*clcfp)-&gt;regex, &amp;r-&gt;uri); if (n == NGX_OK) &#123; r-&gt;loc_conf = (*clcfp)-&gt;loc_conf; /* look up nested locations */ rc = ngx_http_core_find_location(r); return (rc == NGX_ERROR) ? rc : NGX_OK; &#125; if (n == NGX_DECLINED) &#123; continue; &#125; return NGX_ERROR; &#125; &#125; return rc;&#125; 函数 ngx_http_core_find_static_location 实现二叉树的查找, 查找过程比较简单, 但是函数会有 NGX_DONE (‘auto redirect’ 自动重定向)类型返回值. 什么是自动重定向, 又如何实现自动重定向? 三 自动重定向在 location 指令处理函数中并没有标记 auto_redirect 类型的路由, 在 nginx 源码中只在 ngx_http_proxy_module, ngx_http_fastcgi_module 等转发模块中有设置. 例如在 ngx_http_proxy_module 模块的 proxy_pass 指令处理函数中, 如果 location 路径以 / 结尾, 那么当前 location 会被标记为 auto_redirect: 12345678910111213static char *ngx_http_proxy_pass(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; // 省略无关代码 clcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module); clcf-&gt;handler = ngx_http_proxy_handler; if (clcf-&gt;name.len &amp;&amp; clcf-&gt;name.data[clcf-&gt;name.len - 1] == &#x27;/&#x27;) &#123; clcf-&gt;auto_redirect = 1; &#125; // 省略无关代码&#125; auto_redirect 会有如下作用: 在请求匹配中, 如果请求路径匹配了 auto_redirect 类型, nginx 会直接返回 301 应答. 如果有如下配置 123location /case/ &#123; proxy_pass http://backend;&#125; 使用 /case 路径请求会触发 301 重定向: 123456789101112131415161718$curl -i &quot;http://localhost:8000/case&quot;HTTP/1.1 301 Moved PermanentlyServer: openresty/1.15.8.2Date: Sat, 28 Mar 2020 15:17:44 GMTContent-Type: text/htmlContent-Length: 175Location: http://localhost:8000/case/Connection: keep-alive# 带参数请求$curl -i &quot;http://localhost:8000/case?n=1&quot;HTTP/1.1 301 Moved PermanentlyServer: openresty/1.15.8.2Date: Sat, 28 Mar 2020 15:18:25 GMTContent-Type: text/htmlContent-Length: 175Location: http://localhost:8000/case/?n=1Connection: keep-alive 如果使用 /case/ 则能正常转发到后端. auto_redirect 触发需要的条件: location 必须启用 proxy_pass, fastcgi_pass 等 location 配置路径必须以 / 结尾 请求路径与配置路径差一个 / 字符(如果有另外一个 /case 路径配置, 会匹配 /case 路径, 而不会触发 301) 个人认为 auto_redirect 存在是一种折中的选择, 因为用户配置的路径是 /case/ 而请求路径是 /case, 这是用户自己配置的错误, nginx 尝试修正错误.","categories":[{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/categories/NGINX/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/tags/NGINX/"}]},{"title":"HTTP1.0 buffering","slug":"nginx-2020-04-03-http1-0-buffering","date":"2022-09-03T12:55:44.520Z","updated":"2022-09-03T12:55:44.521Z","comments":true,"path":"2022/09/03/nginx-2020-04-03-http1-0-buffering/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/nginx-2020-04-03-http1-0-buffering/","excerpt":"","text":"示例12345678910111213141516upstream backend &#123; server 127.0.0.1:8080;&#125;server &#123; listen 8000; location /path &#123; access_by_lua_block &#123; ngx.status = 200 ngx.say(&quot;ok&quot;) &#125; set $ups &quot;&quot;; proxy_pass http://$ups; &#125;&#125; 使用 HTTP1.0 请求会提示 500 错误, 使用 HTTP1.1 则不会: 12345$ curl -i -0 &quot;http://127.0.0.1:8000/path&quot;HTTP/1.1 500 Internal Server Error$ curl -i &quot;http://127.0.0.1:8000/path&quot;HTTP/1.1 200 OK 应答上的差异这是因为 lua-nginx-module 默认开启了 lua_http10_buffering 配置, 在执行输出 ngx.say/ngx.print 操作时会对 HTTP1.0 版本请求进行输出缓存. ngx.say/ngx.print 最终都会调用 ngx_http_lua_send_chain_link 函数, 其中 in 参数是待输出内容. 123456789101112131415161718192021222324252627282930313233343536ngx_int_tngx_http_lua_send_chain_link(ngx_http_request_t *r, ngx_http_lua_ctx_t *ctx, ngx_chain_t *in)&#123; // 忽略无关代码 llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module); // 开启 http1.0 缓存功能, 并且请求使用协议版本号小于 1.1 if (llcf-&gt;http10_buffering &amp;&amp; !ctx-&gt;buffering &amp;&amp; !r-&gt;header_sent &amp;&amp; !ctx-&gt;header_sent &amp;&amp; r-&gt;http_version &lt; NGX_HTTP_VERSION_11 &amp;&amp; r-&gt;headers_out.content_length_n &lt; 0) &#123; ctx-&gt;buffering = 1; &#125; // 忽略无关代码 // 启用输出缓存时并未进行应答输出操作 if (ctx-&gt;buffering) &#123; ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, &quot;lua buffering output bufs for the HTTP 1.0 request&quot;); for (cl = ctx-&gt;out, ll = &amp;ctx-&gt;out; cl; cl = cl-&gt;next) &#123; ll = &amp;cl-&gt;next; &#125; *ll = in; return NGX_OK; &#125; // 进行应答输出操作 return ngx_http_lua_output_filter(r, in);&#125; 为什么 HTTP1.0 会出错使用 HTTP1.0 协议出错是因为虽然在 access 阶段调用了 ngx.say\\ngx.print 进行响应输出, 但是请求最终走到 content 阶段. 在 proxy_pass 模块处理中, 对 proxy_pass 的转发目的进行处理时出现错误. 对于未采用输出响应缓存的请求, 在 access_by_lua 函数执行完毕后会终止请求处理, 不会进入 content 阶段处理. 当请求在 access 阶段将应答头发送出去时, lua-nginx-module 在 acess 阶段执行的应答码为 NGX_HTTP_OK, nginx 的处理函数 ngx_http_core_access_phase 会终止请求执行. access_by_lua 执行函数: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687static ngx_int_tngx_http_lua_access_by_chunk(lua_State *L, ngx_http_request_t *r)&#123; // 创建 access 阶段的协程 /* &#123;&#123;&#123; new coroutine to handle request */ co = ngx_http_lua_new_thread(r, L, &amp;co_ref); if (co == NULL) &#123; // ... return NGX_HTTP_INTERNAL_SERVER_ERROR; &#125; /* move code closure to new coroutine */ lua_xmove(L, co, 1); // ... /* save nginx request in coroutine globals table */ ngx_http_lua_set_req(co, r); /* &#123;&#123;&#123; initialize request context */ ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module); dd(&quot;ctx = %p&quot;, ctx); if (ctx == NULL) &#123; return NGX_ERROR; &#125; ngx_http_lua_reset_ctx(r, L, ctx); ctx-&gt;entered_access_phase = 1; ctx-&gt;cur_co_ctx = &amp;ctx-&gt;entry_co_ctx; ctx-&gt;cur_co_ctx-&gt;co = co; ctx-&gt;cur_co_ctx-&gt;co_ref = co_ref; /* &#125;&#125;&#125; */ // ... ctx-&gt;context = NGX_HTTP_LUA_CONTEXT_ACCESS; // ... c = r-&gt;connection; nreqs = c-&gt;requests; // 在协程内进行请求处理, 调用 lua 代码 rc = ngx_http_lua_run_thread(L, r, ctx, 0); if (rc == NGX_ERROR || rc &gt; NGX_OK) &#123; return rc; &#125; // ... if (rc == NGX_OK) &#123; // 执行完毕, 并且响应头已经发出, 返回 NGX_HTTP_OK // 输出应答缓冲区内容 if (r-&gt;header_sent) &#123; dd(&quot;header already sent&quot;); /* response header was already generated in access_by_lua*, * so it is no longer safe to proceed to later phases * which may generate responses again */ if (!ctx-&gt;eof) &#123; dd(&quot;eof not yet sent&quot;); rc = ngx_http_lua_send_chain_link(r, ctx, NULL /* indicate last_buf */); if (rc == NGX_ERROR || rc &gt; NGX_OK) &#123; return rc; &#125; &#125; return NGX_HTTP_OK; &#125; // 未发送响应头时返回 NGX_OK, 在 nginx 中会继续执行后续阶段 return NGX_OK; &#125; return NGX_DECLINED;&#125; lua_http10_buffering 指令 syntax: lua_http10_buffering on|off default: lua_http10_buffering on context: http, server, location, location-if 启用或禁用 HTTP1.0（或更旧版本）请求的自动响应缓冲, 此缓冲机制主要用于 HTTP1.0 连接保持存活, 因为 HTTP1.1 以前的版本在请求响应后会关闭连接.如果设置 Content-Length 响应头, 会关闭响应缓冲区.","categories":[{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/categories/NGINX/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/tags/NGINX/"},{"name":"OpenResty","slug":"OpenResty","permalink":"https://juzipeek.github.io/tags/OpenResty/"}]},{"title":"NGINX WebSocket 支持","slug":"nginx-2020-03-09-nginx-websocket-support","date":"2022-09-03T12:55:44.519Z","updated":"2022-09-03T12:55:44.519Z","comments":true,"path":"2022/09/03/nginx-2020-03-09-nginx-websocket-support/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/nginx-2020-03-09-nginx-websocket-support/","excerpt":"","text":"NGINX 处理WebSocket 处理的的关键点是 Upgrade 握手处理, 在 NGINX 中 Upgrade 是预定义的请求处理头. 在请求处理过程中会解析请求头, 并在存储在 ngx_http_headers_in_t::upgrade 中. 在 proxy_pass 模块内, 当服务端应答行为 HTTP/1.1 101 Switching Protocols 时, NGINX 对请求进行升级, 只进行 package 转发, 并且后端负载不会变化. proxy_pass 模块处理上游 server 应答头, 检测到应答状态码为 101 时会标记需要进行升级 upgrade. 1234567891011121314151617181920212223242526272829303132333435363738static ngx_int_tngx_http_proxy_process_header(ngx_http_request_t *r)&#123; for ( ;; ) &#123; rc = ngx_http_parse_header_line(r, &amp;r-&gt;upstream-&gt;buffer, 1); // ... 省略无关代码 // 上游应答头解析结束 if (rc == NGX_HTTP_PARSE_HEADER_DONE) &#123; /* a whole header has been parsed successfully */ ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, &quot;http proxy header done&quot;); u = r-&gt;upstream; if (u-&gt;headers_in.chunked) &#123; u-&gt;headers_in.content_length_n = -1; &#125; // NGX_HTTP_SWITCHING_PROTOCOLS == 101 // 应答状态码为 101, 标记需要升级为套接字通讯 if (u-&gt;headers_in.status_n == NGX_HTTP_SWITCHING_PROTOCOLS) &#123; u-&gt;keepalive = 0; if (r-&gt;headers_in.upgrade) &#123; u-&gt;upgrade = 1; &#125; &#125; return NGX_OK; &#125; // ...... 省略无关代码 return NGX_HTTP_UPSTREAM_INVALID_HEADER; &#125;&#125; 在给客户端发送应答时判断 upgrade 标记, 将上游读写事件修改为 ngx_http_upstream_upgraded_read_upstream\\ngx_http_upstream_upgraded_write_upstream, 下游读写事件修改为 ngx_http_upstream_upgraded_read_downstream\\ngx_http_upstream_upgraded_write_downstream. 当上下游读写事件到来时直接调用响应的处理函数, 而不经过 proxy_pass 模块的 ngx_http_upstream_init 等一系列回调函数. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980static voidngx_http_upstream_send_response(ngx_http_request_t *r, ngx_http_upstream_t *u)&#123; ssize_t n; ngx_int_t rc; ngx_event_pipe_t *p; ngx_connection_t *c; ngx_http_core_loc_conf_t *clcf; rc = ngx_http_send_header(r); if (rc == NGX_ERROR || rc &gt; NGX_OK || r-&gt;post_action) &#123; ngx_http_upstream_finalize_request(r, u, rc); return; &#125; u-&gt;header_sent = 1; if (u-&gt;upgrade) &#123; // 升级操作 ngx_http_upstream_upgrade(r, u); return; &#125; // ... 省略无关代码&#125;static voidngx_http_upstream_upgrade(ngx_http_request_t *r, ngx_http_upstream_t *u)&#123; ngx_connection_t *c; ngx_http_core_loc_conf_t *clcf; c = r-&gt;connection; clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module); /* TODO: prevent upgrade if not requested or not possible */ if (r != r-&gt;main) &#123; ngx_log_error(NGX_LOG_ERR, c-&gt;log, 0, &quot;connection upgrade in subrequest&quot;); ngx_http_upstream_finalize_request(r, u, NGX_ERROR); return; &#125; r-&gt;keepalive = 0; c-&gt;log-&gt;action = &quot;proxying upgraded connection&quot;; u-&gt;read_event_handler = ngx_http_upstream_upgraded_read_upstream; u-&gt;write_event_handler = ngx_http_upstream_upgraded_write_upstream; r-&gt;read_event_handler = ngx_http_upstream_upgraded_read_downstream; r-&gt;write_event_handler = ngx_http_upstream_upgraded_write_downstream; if (clcf-&gt;tcp_nodelay) &#123; if (ngx_tcp_nodelay(c) != NGX_OK) &#123; ngx_http_upstream_finalize_request(r, u, NGX_ERROR); return; &#125; if (ngx_tcp_nodelay(u-&gt;peer.connection) != NGX_OK) &#123; ngx_http_upstream_finalize_request(r, u, NGX_ERROR); return; &#125; &#125; if (ngx_http_send_special(r, NGX_HTTP_FLUSH) == NGX_ERROR) &#123; ngx_http_upstream_finalize_request(r, u, NGX_ERROR); return; &#125; if (u-&gt;peer.connection-&gt;read-&gt;ready || u-&gt;buffer.pos != u-&gt;buffer.last) &#123; ngx_post_event(c-&gt;read, &amp;ngx_posted_events); ngx_http_upstream_process_upgraded(r, 1, 1); return; &#125; ngx_http_upstream_process_upgraded(r, 0, 1);&#125;","categories":[{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/categories/NGINX/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/tags/NGINX/"}]},{"title":"OpenResty Api - worker id","slug":"nginx-2020-03-21-openresty-api-worker-id","date":"2022-09-03T12:55:44.519Z","updated":"2022-09-03T12:55:44.519Z","comments":true,"path":"2022/09/03/nginx-2020-03-21-openresty-api-worker-id/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/nginx-2020-03-21-openresty-api-worker-id/","excerpt":"","text":"一 概述在使用 OpenResty 实现业务逻辑时经常需要只在一个 worker 内执行某项动作, 例如读取配置文件到共享内存. 可以使用 ngx.worker.id 函数获取 worker 序号, 相对于 ngx.worker.pid 得到进程 pid 更有用. 获取 worker 序号, 进程 pid 功能是使用 FFI 技术, 由 resty.core.worker 包对外提供服务(实现 FFI 库时应该使用此种方式, 避免在业务代码中直接通过 FFI 调用 C 函数). ngx.worker.pid 调用 lua-nginx 模块的 ngx_http_lua_ffi_worker_pid 函数(从全局变量 ngx_pid 中获得进程 pid); ngx.worker.id 调用 lua-nginx模块的 ngx_http_lua_ffi_worker_id 函数. 对于 ngx.worker.id 进程序号需要考虑怎么给进程分配序号这件事情, 序号什么时候会发生变化.首先, 给进程分配序号是在 worker 启动时确定的: master 根据配置的 worker 进程数循环计数, 并将此计数作为参数传递给 worker 进程, worker 进程获得的参数就是进程序号. 第二, 其实第一点确定了序号是怎么产生的, 那只需要什么时候 worker 会启动, 分析此时启动 worker 的参数即可确定. 在 nginx 进程生命周期中有三种情况会启动 worker 进程: 初始运行(new binary 等同初始运行), 热加载, master 拉起挂掉 worker. 初始运行与热加载相同逻辑, 都需要启动一组新的 worker 进程; worker 挂掉后 master 重新拉起 worker 时会使用进程数组中保存的信息启动 worker, 会与原槽位的 worker 持有相同的序号. 二 分配序号1234567891011121314151617181920212223242526272829303132333435363738// master 启动 worker 进程static voidngx_start_worker_processes(ngx_cycle_t *cycle, ngx_int_t n, ngx_int_t type)&#123; ngx_int_t i; ngx_channel_t ch; ngx_log_error(NGX_LOG_NOTICE, cycle-&gt;log, 0, &quot;start worker processes&quot;); ngx_memzero(&amp;ch, sizeof(ngx_channel_t)); ch.command = NGX_CMD_OPEN_CHANNEL; for (i = 0; i &lt; n; i++) &#123; // 将序号 i 传递给 worker 进程 ngx_spawn_process(cycle, ngx_worker_process_cycle, (void *) (intptr_t) i, &quot;worker process&quot;, type); ch.pid = ngx_processes[ngx_process_slot].pid; ch.slot = ngx_process_slot; ch.fd = ngx_processes[ngx_process_slot].channel[0]; ngx_pass_open_channel(cycle, &amp;ch); &#125;&#125;static voidngx_worker_process_cycle(ngx_cycle_t *cycle, void *data)&#123; // 序号参数保存到全局变量 ngx_worker 中 ngx_int_t worker = (intptr_t) data; ngx_worker = worker; ngx_worker_process_init(cycle, worker); ngx_setproctitle(&quot;worker process&quot;); ... // 省略无关代码&#125; 三 重新拉起 worker在启动时 nginx 会注册 SIGCHLD 信号处理函数, 当 worker 挂掉时会调用信号处理函数, 设置 master 进程全局变量 ngx_reap=1. 在 master 进程的主循环逻辑中根据 ngx_reap 变量进入 ngx_reap_children 处理. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169static ngx_uint_tngx_reap_children(ngx_cycle_t *cycle)&#123; ngx_int_t i, n; ngx_uint_t live; ngx_channel_t ch; ngx_core_conf_t *ccf; ngx_memzero(&amp;ch, sizeof(ngx_channel_t)); ch.command = NGX_CMD_CLOSE_CHANNEL; ch.fd = -1; live = 0; for (i = 0; i &lt; ngx_last_process; i++) &#123; ngx_log_debug7(NGX_LOG_DEBUG_EVENT, cycle-&gt;log, 0, &quot;child: %i %P e:%d t:%d d:%d r:%d j:%d&quot;, i, ngx_processes[i].pid, ngx_processes[i].exiting, ngx_processes[i].exited, ngx_processes[i].detached, ngx_processes[i].respawn, ngx_processes[i].just_spawn); if (ngx_processes[i].pid == -1) &#123; continue; &#125; if (ngx_processes[i].exited) &#123; ... // 重新拉起 worker if (ngx_processes[i].respawn &amp;&amp; !ngx_processes[i].exiting &amp;&amp; !ngx_terminate &amp;&amp; !ngx_quit) &#123; // 使用存储在 ngx_processes 中的序号(data) 启动 worker 进程 if (ngx_spawn_process(cycle, ngx_processes[i].proc, ngx_processes[i].data, ngx_processes[i].name, i) == NGX_INVALID_PID) &#123; ngx_log_error(NGX_LOG_ALERT, cycle-&gt;log, 0, &quot;could not respawn %s&quot;, ngx_processes[i].name); continue; &#125; ch.command = NGX_CMD_OPEN_CHANNEL; ch.pid = ngx_processes[ngx_process_slot].pid; ch.slot = ngx_process_slot; ch.fd = ngx_processes[ngx_process_slot].channel[0]; ngx_pass_open_channel(cycle, &amp;ch); live = 1; continue; &#125; ... if (i == ngx_last_process - 1) &#123; ngx_last_process--; &#125; else &#123; ngx_processes[i].pid = -1; &#125; &#125; else if (ngx_processes[i].exiting || !ngx_processes[i].detached) &#123; live = 1; &#125; &#125; return live;&#125;// 在 master 第一次启动时同样会进入此函数; data 为 worker 序号ngx_pid_tngx_spawn_process(ngx_cycle_t *cycle, ngx_spawn_proc_pt proc, void *data, char *name, ngx_int_t respawn)&#123; u_long on; ngx_pid_t pid; ngx_int_t s; ... // 省略无关代码 ngx_process_slot = s; pid = fork(); switch (pid) &#123; case -1: ngx_log_error(NGX_LOG_ALERT, cycle-&gt;log, ngx_errno, &quot;fork() failed while spawning \\&quot;%s\\&quot;&quot;, name); ngx_close_channel(ngx_processes[s].channel, cycle-&gt;log); return NGX_INVALID_PID; case 0: ngx_parent = ngx_pid; ngx_pid = ngx_getpid(); // 子进程作为 worker, 执行 work 处理逻辑, 将 data 传个 worker proc(cycle, data); break; default: break; &#125; ngx_log_error(NGX_LOG_NOTICE, cycle-&gt;log, 0, &quot;start %s %P&quot;, name, pid); ngx_processes[s].pid = pid; ngx_processes[s].exited = 0; // master 拉起 worker 时 respawn &gt;=0 if (respawn &gt;= 0) &#123; return pid; &#125; // master 初始启动 worker 时会走到此次; respawn 值为 NGX_PROCESS_RESPAWN // 将 worker 分配序号存储在 ngx_processes 数组中 ngx_processes[s].proc = proc; ngx_processes[s].data = data; ngx_processes[s].name = name; ngx_processes[s].exiting = 0; switch (respawn) &#123; case NGX_PROCESS_NORESPAWN: ngx_processes[s].respawn = 0; ngx_processes[s].just_spawn = 0; ngx_processes[s].detached = 0; break; case NGX_PROCESS_JUST_SPAWN: ngx_processes[s].respawn = 0; ngx_processes[s].just_spawn = 1; ngx_processes[s].detached = 0; break; case NGX_PROCESS_RESPAWN: ngx_processes[s].respawn = 1; ngx_processes[s].just_spawn = 0; ngx_processes[s].detached = 0; break; case NGX_PROCESS_JUST_RESPAWN: ngx_processes[s].respawn = 1; ngx_processes[s].just_spawn = 1; ngx_processes[s].detached = 0; break; case NGX_PROCESS_DETACHED: ngx_processes[s].respawn = 0; ngx_processes[s].just_spawn = 0; ngx_processes[s].detached = 1; break; &#125; if (s == ngx_last_process) &#123; ngx_last_process++; &#125; return pid;&#125; 四 获取进程序号12345678910111213141516intngx_http_lua_ffi_worker_id(void)&#123;#if (nginx_version &gt;= 1009001) if (ngx_process != NGX_PROCESS_WORKER &amp;&amp; ngx_process != NGX_PROCESS_SINGLE) &#123; return -1; &#125; // 直接返回全局变量 return (int) ngx_worker;#else return -1;#endif&#125;","categories":[{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/categories/NGINX/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"Lua","slug":"Lua","permalink":"https://juzipeek.github.io/tags/Lua/"},{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/tags/NGINX/"},{"name":"OpenResty","slug":"OpenResty","permalink":"https://juzipeek.github.io/tags/OpenResty/"}]},{"title":"Nginx 匹配树构建","slug":"nginx-2020-03-23-location-tree","date":"2022-09-03T12:55:44.519Z","updated":"2022-09-03T12:55:44.520Z","comments":true,"path":"2022/09/03/nginx-2020-03-23-location-tree/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/nginx-2020-03-23-location-tree/","excerpt":"","text":"一 概述location 是 nginx 的核心指令, 在 ngx_http_block 处理 http 指令过程中, 当所有 http 模块解析完配置后会遍历所有 server(保存在 cmcf-&gt;servers 中)建立匹配匹配树. 配置匹配树构建需要两个步骤: 初始化(ngx_http_init_locations)和构建匹配树(ngx_http_init_static_location_trees). 二 匹配树预处理匹配树预处理是将 location 队列中的 location 进行分类,排序. 处理结束后会在移除队列中的无名 location, 命名 location 存储在 cscf-&gt;named_locations 中,正则 location 存储在 clcf-&gt;regex_locations 中. 队列中仅保存绝对匹配和前缀匹配 location(并且是排序好的). 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138static ngx_int_tngx_http_init_locations(ngx_conf_t *cf, ngx_http_core_srv_conf_t *cscf, ngx_http_core_loc_conf_t *pclcf)&#123; ngx_uint_t n; ngx_queue_t *q, *locations, *named, tail; ngx_http_core_loc_conf_t *clcf; ngx_http_location_queue_t *lq; ngx_http_core_loc_conf_t **clcfp;#if (NGX_PCRE) ngx_uint_t r; ngx_queue_t *regex;#endif locations = pclcf-&gt;locations; if (locations == NULL) &#123; return NGX_OK; &#125; // 将当前层级下所有 location 排序 // 排序后顺序为: 精确匹配-前缀匹配-正则匹配-命名 location-无名 location. 精确匹配在前, 无名 location 最后. ngx_queue_sort(locations, ngx_http_cmp_locations); named = NULL; n = 0;#if (NGX_PCRE) regex = NULL; r = 0;#endif for (q = ngx_queue_head(locations); q != ngx_queue_sentinel(locations); q = ngx_queue_next(q)) &#123; lq = (ngx_http_location_queue_t *) q; clcf = lq-&gt;exact ? lq-&gt;exact : lq-&gt;inclusive; if (ngx_http_init_locations(cf, NULL, clcf) != NGX_OK) &#123; return NGX_ERROR; &#125;#if (NGX_PCRE) if (clcf-&gt;regex) &#123; r++; // 因为已经排序, 只需要用 regex 变量存储第一个节点, r 指示有多少个正则匹配节点即可 if (regex == NULL) &#123; regex = q; &#125; continue; &#125;#endif if (clcf-&gt;named) &#123; n++; // 因为已经排序, 只需要用 regex 变量存储第一个节点, r 指示有多少个正则匹配节点即可 if (named == NULL) &#123; named = q; &#125; continue; &#125; // 无名 location if (clcf-&gt;noname) &#123; break; &#125; &#125; // 有两种情况会跳出上面的循环: 遍历结束; 遇到无名 location. // 遍历结束时不需要将 q 从队列中移除; 遇到无名 location 时将其从队列移除. if (q != ngx_queue_sentinel(locations)) &#123; ngx_queue_split(locations, q, &amp;tail); &#125; // 将所有命名 location 单独存储 if (named) &#123; clcfp = ngx_palloc(cf-&gt;pool, (n + 1) * sizeof(ngx_http_core_loc_conf_t *)); if (clcfp == NULL) &#123; return NGX_ERROR; &#125; // 命名 location 保存在 server 层级的 named_locations 内 cscf-&gt;named_locations = clcfp; for (q = named; q != ngx_queue_sentinel(locations); q = ngx_queue_next(q)) &#123; lq = (ngx_http_location_queue_t *) q; *(clcfp++) = lq-&gt;exact; &#125; *clcfp = NULL; // 将命名 location 移除 ngx_queue_split(locations, named, &amp;tail); &#125;#if (NGX_PCRE) // 将所有正则 location 单独存储 if (regex) &#123; clcfp = ngx_palloc(cf-&gt;pool, (r + 1) * sizeof(ngx_http_core_loc_conf_t *)); if (clcfp == NULL) &#123; return NGX_ERROR; &#125; // 正则 location 保存在上层 location 的 regex_locations 内 pclcf-&gt;regex_locations = clcfp; for (q = regex; q != ngx_queue_sentinel(locations); q = ngx_queue_next(q)) &#123; lq = (ngx_http_location_queue_t *) q; *(clcfp++) = lq-&gt;exact; &#125; *clcfp = NULL; // 将正则 location 移除 ngx_queue_split(locations, regex, &amp;tail); &#125;#endif return NGX_OK;&#125; 三 匹配树构建1. 匹配树预处理 - 合并前缀匹配与精确匹配前缀匹配和精确匹配 location 是否应该共存? 在 nginx 中支持前缀匹配与精确匹配相同的情况, 即可以同时存在 location = /a 与 location /a. 但是如果同时存在两个相同的精确匹配或两个相同的前缀匹配是错误的. 函数 ngx_http_join_exact_locations 有两个功能: 用于判断是否有两个相同的前缀或精确匹配 location; 将相同的 location 合并到精确匹配 location 中. 1234567891011121314151617181920212223242526272829303132333435363738394041static ngx_int_tngx_http_join_exact_locations(ngx_conf_t *cf, ngx_queue_t *locations)&#123; ngx_queue_t *q, *x; ngx_http_location_queue_t *lq, *lx; q = ngx_queue_head(locations); while (q != ngx_queue_last(locations)) &#123; x = ngx_queue_next(q); lq = (ngx_http_location_queue_t *) q; lx = (ngx_http_location_queue_t *) x; if (lq-&gt;name-&gt;len == lx-&gt;name-&gt;len &amp;&amp; ngx_filename_cmp(lq-&gt;name-&gt;data, lx-&gt;name-&gt;data, lx-&gt;name-&gt;len) == 0) &#123; // 两个相同的精确匹配或前缀匹配 if ((lq-&gt;exact &amp;&amp; lx-&gt;exact) || (lq-&gt;inclusive &amp;&amp; lx-&gt;inclusive)) &#123; ngx_log_error(NGX_LOG_EMERG, cf-&gt;log, 0, &quot;duplicate location \\&quot;%V\\&quot; in %s:%ui&quot;, lx-&gt;name, lx-&gt;file_name, lx-&gt;line); return NGX_ERROR; &#125; // 删除前缀匹配, 合并到精确匹配中 lq-&gt;inclusive = lx-&gt;inclusive; ngx_queue_remove(x); continue; &#125; q = ngx_queue_next(q); &#125; return NGX_OK;&#125; 2. 匹配树预处理 - 创建构建匹配树用的 list函数 ngx_http_create_locations_list 用来将 locations 队列中有相同前缀的前缀匹配 location 放在最短前缀的 list 成员中, 用于后续构建二叉树使用. 此过程是递归过程. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566static voidngx_http_create_locations_list(ngx_queue_t *locations, ngx_queue_t *q)&#123; u_char *name; size_t len; ngx_queue_t *x, tail; ngx_http_location_queue_t *lq, *lx; // 递归结束依据 if (q == ngx_queue_last(locations)) &#123; return; &#125; lq = (ngx_http_location_queue_t *) q; // 跳过非前缀匹配 if (lq-&gt;inclusive == NULL) &#123; ngx_http_create_locations_list(locations, ngx_queue_next(q)); return; &#125; len = lq-&gt;name-&gt;len; name = lq-&gt;name-&gt;data; // 找到最后一个具有 q 节点名前缀的节点的 next 节点 x for (x = ngx_queue_next(q); x != ngx_queue_sentinel(locations); x = ngx_queue_next(x)) &#123; lx = (ngx_http_location_queue_t *) x; // len &gt; lx-&gt;name-&gt;len 是注意点, 如果 lx-&gt;name-&gt;len &lt; len 在进行比较时会出现 coredump if (len &gt; lx-&gt;name-&gt;len || ngx_filename_cmp(name, lx-&gt;name-&gt;data, len) != 0) &#123; break; &#125; &#125; q = ngx_queue_next(q); // 未找到具有 q 节点名前缀的节点, 递归处理 q 的下一个节点 if (q == x) &#123; ngx_http_create_locations_list(locations, x); return; &#125; // 将原 locatins 队列以 q 为节点分成两个队列, q 作为新队列的头 // tail 是临时变量, 在调用 ngx_queue_add 后, tail 会从队列中移除 ngx_queue_split(locations, q, &amp;tail); ngx_queue_add(&amp;lq-&gt;list, &amp;tail); // x == ngx_queue_sentinel(locations) 说明已经遍历到队列尾, 现在对拆分出的队列递归处理 if (x == ngx_queue_sentinel(locations)) &#123; ngx_http_create_locations_list(&amp;lq-&gt;list, ngx_queue_head(&amp;lq-&gt;list)); return; &#125; // x 非队列尾, 需要将 x 及其后续合并到原 locations 队列 ngx_queue_split(&amp;lq-&gt;list, x, &amp;tail); ngx_queue_add(locations, &amp;tail); // 分别对两个拆分出来的队列进行处理, 先递归, 再遍历 ngx_http_create_locations_list(&amp;lq-&gt;list, ngx_queue_head(&amp;lq-&gt;list)); ngx_http_create_locations_list(locations, x);&#125; 3. 二叉匹配树构建nginx 中的匹配树应该是三叉树, 有左右子树与当前节点的子树. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677static ngx_http_location_tree_node_t *ngx_http_create_locations_tree(ngx_conf_t *cf, ngx_queue_t *locations, size_t prefix)&#123; size_t len; ngx_queue_t *q, tail; ngx_http_location_queue_t *lq; ngx_http_location_tree_node_t *node; // 中间节点作为根 q = ngx_queue_middle(locations); lq = (ngx_http_location_queue_t *) q; len = lq-&gt;name-&gt;len - prefix; node = ngx_palloc(cf-&gt;pool, offsetof(ngx_http_location_tree_node_t, name) + len); if (node == NULL) &#123; return NULL; &#125; // 根节点 node-&gt;left = NULL; node-&gt;right = NULL; node-&gt;tree = NULL; node-&gt;exact = lq-&gt;exact; node-&gt;inclusive = lq-&gt;inclusive; node-&gt;auto_redirect = (u_char) ((lq-&gt;exact &amp;&amp; lq-&gt;exact-&gt;auto_redirect) || (lq-&gt;inclusive &amp;&amp; lq-&gt;inclusive-&gt;auto_redirect)); // 当前节点的名; 仅保存于前缀不重复的部分 node-&gt;len = (u_char) len; ngx_memcpy(node-&gt;name, &amp;lq-&gt;name-&gt;data[prefix], len); ngx_queue_split(locations, q, &amp;tail); if (ngx_queue_empty(locations)) &#123; /* * ngx_queue_split() insures that if left part is empty, * then right one is empty too */ goto inclusive; &#125; // 左子树; 递归调用; 注意, 此时实参 prefix 为 prefix node-&gt;left = ngx_http_create_locations_tree(cf, locations, prefix); if (node-&gt;left == NULL) &#123; return NULL; &#125; // 右子树不包含根节点 ngx_queue_remove(q); if (ngx_queue_empty(&amp;tail)) &#123; goto inclusive; &#125; // 右子树; 递归调用; 注意, 此时实参 prefix 为 prefix node-&gt;right = ngx_http_create_locations_tree(cf, &amp;tail, prefix); if (node-&gt;right == NULL) &#123; return NULL; &#125;inclusive: if (ngx_queue_empty(&amp;lq-&gt;list)) &#123; return node; &#125; // 对根节点包含的节点递归处理; 注意, 此时实参 prefix 为 prefix + len node-&gt;tree = ngx_http_create_locations_tree(cf, &amp;lq-&gt;list, prefix + len); if (node-&gt;tree == NULL) &#123; return NULL; &#125; return node;&#125; 4. 总结在匹配树构建过程中, nginx 会遍历所有的 server 进行前三个步骤构建匹配树, 每个步骤又是递归调用. 使用 ngx_http_init_static_location_trees 函数处理 server 内的 locations. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950static ngx_int_tngx_http_init_static_location_trees(ngx_conf_t *cf, ngx_http_core_loc_conf_t *pclcf)&#123; ngx_queue_t *q, *locations; ngx_http_core_loc_conf_t *clcf; ngx_http_location_queue_t *lq; locations = pclcf-&gt;locations; // 递归调用, 结束判断依据 if (locations == NULL) &#123; return NGX_OK; &#125; // 递归调用, 结束判断依据 if (ngx_queue_empty(locations)) &#123; return NGX_OK; &#125; // 遍历第一层级的 location, 递归调用 ngx_http_init_static_location_trees 函数 for (q = ngx_queue_head(locations); q != ngx_queue_sentinel(locations); q = ngx_queue_next(q)) &#123; lq = (ngx_http_location_queue_t *) q; clcf = lq-&gt;exact ? lq-&gt;exact : lq-&gt;inclusive; if (ngx_http_init_static_location_trees(cf, clcf) != NGX_OK) &#123; return NGX_ERROR; &#125; &#125; // 对第一层级 location 进行步骤 a 处理 if (ngx_http_join_exact_locations(cf, locations) != NGX_OK) &#123; return NGX_ERROR; &#125; // 对第一层级 location 进行步骤 b 处理 ngx_http_create_locations_list(locations, ngx_queue_head(locations)); // 对第一层级 location 进行步骤 c 处理 pclcf-&gt;static_locations = ngx_http_create_locations_tree(cf, locations, 0); if (pclcf-&gt;static_locations == NULL) &#123; return NGX_ERROR; &#125; return NGX_OK;&#125; 四 参考链接 Nginx 源代码笔记 - URI 匹配","categories":[{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/categories/NGINX/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/tags/NGINX/"}]},{"title":"OpenResty Api - balancer","slug":"nginx-2019-10-12-openresty-api-balancer","date":"2022-09-03T12:55:44.518Z","updated":"2022-09-03T12:55:44.518Z","comments":true,"path":"2022/09/03/nginx-2019-10-12-openresty-api-balancer/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/nginx-2019-10-12-openresty-api-balancer/","excerpt":"","text":"一 概述如何使用 OpenResty 实现负载均衡模块？使用 balancer_by_lua_file|block 指令能够使用 Lua 实现负载均衡模块，在 Lua 代码中必须使用 ngx.balancer.set_current_peer 函数设置当前使用 server 地址端口。 OpenResty 使用 balancer_by_lua_file|block 指令修改 ngx_http_upstream_module 模块的 ngx_http_upstream_srv_conf_t::peer.init_upstream 回调函数指针，在 upstream 初始化时会再次将当前 upstream 配置的 ngx_http_upstream_srv_conf_t::peer.init 回调函数指针修改，实现 server 获取释放（get/free）注入功能。 二 指令1. balancer_by_lua_block123syntax: balancer_by_lua_block &#123; lua-script &#125;context: upstreamphase: content 注入 Lua 代码块，实现负载均衡功能。如果 lua-script 处理失败会回退到 round robin 模块进行负载均衡处理。 2. balancer_by_lua_file123syntax: balancer_by_lua_file &lt;path-to-lua-file&gt;context: upstreamphase: content 注入 Lua 代码文件，实现负载均衡功能。 三 函数1. set_current_peer12syntax: ok, err = balancer.set_current_peer(host, port)context: balancer_by_lua* 设置当前使用的 server 地址和端口。支持 unix 域地址，IPv4 和 IPv6，但是不支持域名。 2. set_more_tries12syntax: ok, err = balancer.set_more_tries(count)context: balancer_by_lua* 设置当前请求重试次数（不包含当前尝试）。count 不能大于 proxy_next_upstream_tries 设置值。 3. get_last_failure12syntax: state_name, status_code = balancer.get_last_failure()context: balancer_by_lua* 在触发重试机制时，查询先前失败的详细信息。如果有失败，则返回状态名称已经状态码。如果当前尝试是首次尝试，返回值为 nil。 4. set_timeouts12syntax: ok, err = balancer.set_timeouts(connect_timeout, send_timeout, read_timeout)context: balancer_by_lua* 设置当前和后续 upstream 连接的超时时间（连接超时，发送超时，读超时），以秒为单位精确到毫秒。超时时间必须大于零，不能等于零或小于零。 四 实现1. balancer_by_lua_block|file模块指令 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100static ngx_command_t ngx_http_lua_cmds[] = &#123; ... &#123; ngx_string(&quot;balancer_by_lua_file&quot;), NGX_HTTP_UPS_CONF|NGX_CONF_TAKE1, ngx_http_lua_balancer_by_lua, NGX_HTTP_SRV_CONF_OFFSET, 0, (void *) ngx_http_lua_balancer_handler_file &#125;, ...&#125;;// balancer_by_lua 配置解析函数char *ngx_http_lua_balancer_by_lua(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; ... value = cf-&gt;args-&gt;elts; // 设置处理函数指针 // cmd-&gt;post 为 ngx_http_lua_balancer_handler_inline lscf-&gt;balancer.handler = (ngx_http_lua_srv_conf_handler_pt) cmd-&gt;post; if (cmd-&gt;post == ngx_http_lua_balancer_handler_file) &#123; /* Lua code in an external file */ // 外部 lua 文件 ... &#125; else &#123; /* inlined Lua code */ // 配置文件中 lua 代码 ... &#125; // 修改 upstream 模块的 peer.init_upstream 指针，lua_module 介入处理 // 跟踪代码可以发现，lua-nginx-module 只在请求的 peer.get/peer.free 介入处理 uscf = ngx_http_conf_get_module_srv_conf(cf, ngx_http_upstream_module); if (uscf-&gt;peer.init_upstream) &#123; ngx_conf_log_error(NGX_LOG_WARN, cf, 0, &quot;load balancing method redefined&quot;); &#125; uscf-&gt;peer.init_upstream = ngx_http_lua_balancer_init; uscf-&gt;flags = NGX_HTTP_UPSTREAM_CREATE |NGX_HTTP_UPSTREAM_WEIGHT |NGX_HTTP_UPSTREAM_MAX_FAILS |NGX_HTTP_UPSTREAM_FAIL_TIMEOUT |NGX_HTTP_UPSTREAM_DOWN; return NGX_CONF_OK;&#125;static ngx_int_tngx_http_lua_balancer_init(ngx_conf_t *cf, ngx_http_upstream_srv_conf_t *us)&#123; if (ngx_http_upstream_init_round_robin(cf, us) != NGX_OK) &#123; return NGX_ERROR; &#125; /* this callback is called upon individual requests */ us-&gt;peer.init = ngx_http_lua_balancer_init_peer; return NGX_OK;&#125;static ngx_int_tngx_http_lua_balancer_init_peer(ngx_http_request_t *r, ngx_http_upstream_srv_conf_t *us)&#123; ngx_http_lua_srv_conf_t *bcf; ngx_http_lua_balancer_peer_data_t *bp; bp = ngx_pcalloc(r-&gt;pool, sizeof(ngx_http_lua_balancer_peer_data_t)); if (bp == NULL) &#123; return NGX_ERROR; &#125; r-&gt;upstream-&gt;peer.data = &amp;bp-&gt;rrp; if (ngx_http_upstream_init_round_robin_peer(r, us) != NGX_OK) &#123; return NGX_ERROR; &#125; r-&gt;upstream-&gt;peer.get = ngx_http_lua_balancer_get_peer; r-&gt;upstream-&gt;peer.free = ngx_http_lua_balancer_free_peer; ... bcf = ngx_http_conf_upstream_srv_conf(us, ngx_http_lua_module); bp-&gt;conf = bcf; bp-&gt;request = r; return NGX_OK;&#125; 2. ngx.balancer.set_current_peer123syntax: ok, err = balancer.set_current_peer(host, port)context: balancer_by_lua* 用于设置后端地址、端口, 不能使用域名. 在 lua-nginx-module 模块中 set_current_peer 通过修改 UPSTREAM 配置中 balancer_peer_data 字段达到目的. 看代码, set_current_peer 并没有直接修改 r-&gt;upstream-&gt;peer.data 字段, 是因为需要与其他 UPSTREAM 模块配合, 避免被修改. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657intngx_http_lua_ffi_balancer_set_current_peer(ngx_http_request_t *r, const u_char *addr, size_t addr_len, int port, char **err)&#123; ... ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module); ... lmcf = ngx_http_get_module_main_conf(r, ngx_http_lua_module); // 不直接修改 peer.data 的原因: /* we cannot read r-&gt;upstream-&gt;peer.data here directly because * it could be overridden by other modules like * ngx_http_upstream_keepalive_module. */ bp = lmcf-&gt;balancer_peer_data; if (bp == NULL) &#123; *err = &quot;no upstream peer data found&quot;; return NGX_ERROR; &#125; ngx_memzero(&amp;url, sizeof(ngx_url_t)); url.url.data = ngx_palloc(r-&gt;pool, addr_len); if (url.url.data == NULL) &#123; *err = &quot;no memory&quot;; return NGX_ERROR; &#125; ngx_memcpy(url.url.data, addr, addr_len); url.url.len = addr_len; url.default_port = (in_port_t) port; url.uri_part = 0; url.no_resolve = 1; if (ngx_parse_url(r-&gt;pool, &amp;url) != NGX_OK) &#123; if (url.err) &#123; *err = url.err; &#125; return NGX_ERROR; &#125; // 设置转发后端地址 if (url.addrs &amp;&amp; url.addrs[0].sockaddr) &#123; bp-&gt;sockaddr = url.addrs[0].sockaddr; bp-&gt;socklen = url.addrs[0].socklen; bp-&gt;host = &amp;url.addrs[0].name; &#125; else &#123; *err = &quot;no host allowed&quot;; return NGX_ERROR; &#125; return NGX_OK;&#125; 后端信息通过 ngx_http_lua_module 模块配置中 balancer_peer_data 字段暂存. 看代码中注释, balancer_peer_data 在 balancer 阶段只会被一个请求修改, 不会有竞争状态. 1234567891011121314typedef struct ngx_http_lua_main_conf_s ngx_http_lua_main_conf_t;struct ngx_http_lua_main_conf_s &#123; ... ngx_http_lua_balancer_peer_data_t *balancer_peer_data; /* neither yielding nor recursion is possible in * balancer_by_lua*, so there cannot be any races among * concurrent requests and it is safe to store the peer * data pointer in the main conf. */ ...&#125;; 3. ngx.balancer.set_current_peer NGINX 原生在 NGINX UPSTREAM 处理框架中, ngx_http_upstream_connect 函数会调用 ngx_event_connect_peer 进行连接处理, 会调用 lua-nginx 模块设置的回调函数, 读取 bp 中的内容, 进行后端地址设置; 使用非阻塞连接方式建立连接, 使用 epoll 模块时会对连接同时添加读/写事件监听. 非阻塞连接, 连接建立成功时会是可写状态, 失败时是可读、可写状态. 需要通过调用 getsockopt 函数, 判断 socket 是否有错误. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950static voidngx_http_upstream_connect(ngx_http_request_t *r, ngx_http_upstream_t *u)&#123; r-&gt;connection-&gt;log-&gt;action = &quot;connecting to upstream&quot;; ... // 状态设置 u-&gt;state-&gt;response_time = ngx_current_msec; u-&gt;state-&gt;connect_time = (ngx_msec_t) -1; u-&gt;state-&gt;header_time = (ngx_msec_t) -1; // 作为客户端发起与上游连接 rc = ngx_event_connect_peer(&amp;u-&gt;peer); ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, &quot;http upstream connect: %i&quot;, rc); // 错误处理 ... /* rc == NGX_OK || rc == NGX_AGAIN || rc == NGX_DONE */ c = u-&gt;peer.connection; c-&gt;data = r; // 事件回调函数设置 c-&gt;write-&gt;handler = ngx_http_upstream_handler; c-&gt;read-&gt;handler = ngx_http_upstream_handler; u-&gt;write_event_handler = ngx_http_upstream_send_request_handler; u-&gt;read_event_handler = ngx_http_upstream_process_header; c-&gt;sendfile &amp;= r-&gt;connection-&gt;sendfile; u-&gt;output.sendfile = c-&gt;sendfile; ... // 设置连接超时时间 // u-&gt;conf 实际指向的是 lua-nginx 模块创建的临时内存 if (rc == NGX_AGAIN) &#123; ngx_add_timer(c-&gt;write, u-&gt;conf-&gt;connect_timeout); return; &#125; ... ngx_http_upstream_send_request(r, u, 1);&#125; 连接操作: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293ngx_int_tngx_event_connect_peer(ngx_peer_connection_t *pc)&#123; int rc, type;#if (NGX_HAVE_IP_BIND_ADDRESS_NO_PORT || NGX_LINUX) in_port_t port;#endif ngx_int_t event; ngx_err_t err; ngx_uint_t level; ngx_socket_t s; ngx_event_t *rev, *wev; ngx_connection_t *c; // 调用 lua-nginx 模块回调函数 // pc-&gt;get 指向 ngx_http_lua_balancer_get_peer 函数 rc = pc-&gt;get(pc, pc-&gt;data); if (rc != NGX_OK) &#123; return rc; &#125; ... c = ngx_get_connection(s, pc-&gt;log); ... // 将 socket 设置为非阻塞模式 if (ngx_nonblocking(s) == -1) &#123; ngx_log_error(NGX_LOG_ALERT, pc-&gt;log, ngx_socket_errno, ngx_nonblocking_n &quot; failed&quot;); goto failed; &#125; ... // epoll 模块有 ngx_add_conn 函数, 为 ngx_epoll_add_connection // 会添加连接的读、写事件监听 if (ngx_add_conn) &#123; if (ngx_add_conn(c) == NGX_ERROR) &#123; goto failed; &#125; &#125; // 调用 connect rc = connect(s, pc-&gt;sockaddr, pc-&gt;socklen); ... // 错误处理 // epoll 模块有 ngx_add_conn 函数 if (ngx_add_conn) &#123; if (rc == -1) &#123; /* NGX_EINPROGRESS */ return NGX_AGAIN; &#125; ngx_log_debug0(NGX_LOG_DEBUG_EVENT, pc-&gt;log, 0, &quot;connected&quot;); wev-&gt;ready = 1; return NGX_OK; &#125; // 非 Linux 平台处理 ...&#125;// epoll 事件模块, 添加连接static ngx_int_tngx_epoll_add_connection(ngx_connection_t *c)&#123; struct epoll_event ee; // 监听读、写事件 ee.events = EPOLLIN|EPOLLOUT|EPOLLET|EPOLLRDHUP; ee.data.ptr = (void *) ((uintptr_t) c | c-&gt;read-&gt;instance); ngx_log_debug2(NGX_LOG_DEBUG_EVENT, c-&gt;log, 0, &quot;epoll add connection: fd:%d ev:%08XD&quot;, c-&gt;fd, ee.events); if (epoll_ctl(ep, EPOLL_CTL_ADD, c-&gt;fd, &amp;ee) == -1) &#123; ngx_log_error(NGX_LOG_ALERT, c-&gt;log, ngx_errno, &quot;epoll_ctl(EPOLL_CTL_ADD, %d) failed&quot;, c-&gt;fd); return NGX_ERROR; &#125; c-&gt;read-&gt;active = 1; c-&gt;write-&gt;active = 1; return NGX_OK;&#125; 4. ngx.balancer.set_timeouts123syntax: ok, err = balancer.set_timeouts(connect_timeout, send_timeout, read_timeout)context: balancer_by_lua* 超时时间设置与后端地址设置有所不同, 每个请求会创建独立的 UPSTREAM CONF 结构, 确保请求间超时时间独立. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758intngx_http_lua_ffi_balancer_set_timeouts(ngx_http_request_t *r, long connect_timeout, long send_timeout, long read_timeout, char **err)&#123; ngx_http_lua_ctx_t *ctx; ngx_http_upstream_t *u;#if !(HAVE_NGX_UPSTREAM_TIMEOUT_FIELDS) ngx_http_upstream_conf_t *ucf;#endif ngx_http_lua_main_conf_t *lmcf; ngx_http_lua_balancer_peer_data_t *bp; ... u = r-&gt;upstream; ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module); ... lmcf = ngx_http_get_module_main_conf(r, ngx_http_lua_module); bp = lmcf-&gt;balancer_peer_data; ... // 创建独立的 upstream conf 内存, 每个请求都可以有独立的超时时间#if !(HAVE_NGX_UPSTREAM_TIMEOUT_FIELDS) if (!bp-&gt;cloned_upstream_conf) &#123; /* we clone the upstream conf for the current request so that * we do not affect other requests at all. */ ucf = ngx_palloc(r-&gt;pool, sizeof(ngx_http_upstream_conf_t)); if (ucf == NULL) &#123; *err = &quot;no memory&quot;; return NGX_ERROR; &#125; ngx_memcpy(ucf, u-&gt;conf, sizeof(ngx_http_upstream_conf_t)); u-&gt;conf = ucf; bp-&gt;cloned_upstream_conf = 1; &#125; else &#123; ucf = u-&gt;conf; &#125;#endif if (connect_timeout &gt; 0) &#123;#if (HAVE_NGX_UPSTREAM_TIMEOUT_FIELDS) u-&gt;connect_timeout = (ngx_msec_t) connect_timeout;#else ucf-&gt;connect_timeout = (ngx_msec_t) connect_timeout;#endif &#125; ... return NGX_OK;&#125; 5. ngx.balancer.set_more_tries123syntax: ok, err = balancer.set_more_tries(count)context: balancer_by_lua* 设置允许重试次数, 最大重试次数受限于 proxy_next_upstream_tries 配置项. NGINX 中重试是通过 ngx_http_upstream_next 函数实现, 是否允许重试需要同时考虑允许重试状态码、超时时间以及重试次数, 当超过重试次数时直接给客户端响应. 允许重试是通过递减允许重试次数, 当允许重试次数为零时, 不允许进行重试. ngx_peer_connection_t::tries 为允许重试次数. UPSTREAM 处理框架中有 peer.get, peer.free 分别用于后端地址获取、释放. 在获取时设置允许重试次数(根据用户 lua 代码更新), 释放时重试次数减一. 1234567891011121314static ngx_int_tngx_http_lua_balancer_init_peer(ngx_http_request_t *r, ngx_http_upstream_srv_conf_t *us)&#123; ... // 获取后端地址 r-&gt;upstream-&gt;peer.get = ngx_http_lua_balancer_get_peer; // 释放后端地址 r-&gt;upstream-&gt;peer.free = ngx_http_lua_balancer_free_peer; ... return NGX_OK;&#125; 获取: 1234567891011121314151617181920212223242526272829static ngx_int_tngx_http_lua_balancer_get_peer(ngx_peer_connection_t *pc, void *data)&#123; ... // 运行 lua 代码 rc = lscf-&gt;balancer.handler(r, lscf, L); ... if (bp-&gt;sockaddr &amp;&amp; bp-&gt;socklen) &#123; pc-&gt;sockaddr = bp-&gt;sockaddr; pc-&gt;socklen = bp-&gt;socklen; pc-&gt;cached = 0; pc-&gt;connection = NULL; pc-&gt;name = bp-&gt;host; bp-&gt;rrp.peers-&gt;single = 0; // 如果有设置重试次数, 更新允许重试次数 if (bp-&gt;more_tries) &#123; r-&gt;upstream-&gt;peer.tries += bp-&gt;more_tries; &#125; dd(&quot;tries: %d&quot;, (int) r-&gt;upstream-&gt;peer.tries); return NGX_OK; &#125; return ngx_http_upstream_get_round_robin_peer(pc, &amp;bp-&gt;rrp);&#125; 释放: 123456789101112131415161718192021222324voidngx_http_lua_balancer_free_peer(ngx_peer_connection_t *pc, void *data, ngx_uint_t state)&#123; ngx_http_lua_balancer_peer_data_t *bp = data; ngx_log_debug1(NGX_LOG_DEBUG_HTTP, pc-&gt;log, 0, &quot;lua balancer free peer, tries: %ui&quot;, pc-&gt;tries); if (bp-&gt;sockaddr &amp;&amp; bp-&gt;socklen) &#123; bp-&gt;last_peer_state = (int) state; if (pc-&gt;tries) &#123; // 重试次数减一 pc-&gt;tries--; &#125; return; &#125; /* fallback */ ngx_http_upstream_free_round_robin_peer(pc, data, state);&#125; 在与后端 connect、send_request、process_header 出错时会调用失败重试判断函数 ngx_http_upstream_next: 12345678910111213141516171819202122232425262728293031323334353637383940static voidngx_http_upstream_next(ngx_http_request_t *r, ngx_http_upstream_t *u, ngx_uint_t ft_type)&#123; ... if (u-&gt;peer.sockaddr) &#123; if (ft_type == NGX_HTTP_UPSTREAM_FT_HTTP_403 || ft_type == NGX_HTTP_UPSTREAM_FT_HTTP_404) &#123; state = NGX_PEER_NEXT; &#125; else &#123; state = NGX_PEER_FAILED; &#125; // 调用 peer.free 触发重试次数减一 u-&gt;peer.free(&amp;u-&gt;peer, u-&gt;peer.data, state); u-&gt;peer.sockaddr = NULL; &#125; ... // 允许重试次数为零时, 请求处理结束 if (u-&gt;peer.tries == 0 || ((u-&gt;conf-&gt;next_upstream &amp; ft_type) != ft_type) || (u-&gt;request_sent &amp;&amp; r-&gt;request_body_no_buffering) || (timeout &amp;&amp; ngx_current_msec - u-&gt;peer.start_time &gt;= timeout)) &#123; ... ngx_http_upstream_finalize_request(r, u, status); return; &#125; ... // 重新回到连接阶段 ngx_http_upstream_connect(r, u);&#125;","categories":[{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/categories/NGINX/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"Lua","slug":"Lua","permalink":"https://juzipeek.github.io/tags/Lua/"},{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/tags/NGINX/"},{"name":"OpenResty","slug":"OpenResty","permalink":"https://juzipeek.github.io/tags/OpenResty/"}]},{"title":"OpenResty Api - socket tcp","slug":"nginx-2019-10-05-openresty-api-thread-api","date":"2022-09-03T12:55:44.517Z","updated":"2022-09-03T12:55:44.518Z","comments":true,"path":"2022/09/03/nginx-2019-10-05-openresty-api-thread-api/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/nginx-2019-10-05-openresty-api-thread-api/","excerpt":"","text":"一 概述ngx.thread 提供了以 Lua 协程为基础构建的轻量级线程，在 OpenResty 中有两类轻量级线程：普通轻量级线程和主轻量级线程（entry thread）。主轻量级线程是由 access_by_lua,content_by_lua,rewrite_by_lua 指令创建的轻量级线程，普通轻量级线程是在 entry thread 内动态创建的，两者皆由 Openresty 调度。与轻量级线程不同，Lua 原生语义创建的协程并非轻量级线程，两者的区别在于：轻量级线程在遇到 IO 调用时会自动 yield 让出，而原生协程需要协程自己 yield。不过两者（原生协程、轻量级线程）都会被 Openresty 协程调度框架调度。 指令1. spawn12syntax: co = ngx.thread.spawn(func, arg1, arg2, ...)context: rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua* 使用 func 以及可选的参数 arg1,arg2… 创建协程作为轻量级线程返回，ngx.thread.spawn 创建的线程由 ngx_lua 模块调度。新创建的协程会先运行（在 spawn 调用前已经运行，由 ngx_lua 调度实现），直到出错或进行 IO 操作而让出执行。spawn 返回后，新建的轻量级协程会在其“关注”的 IO 事件触发后异步执行（由 ngx_lua 调度实现）。 其实，由 rewrite_by_lua,access_by_lua,content_by_lua 运行的 Lua 代码块会由 ngx_lua 自动创建轻量级线程，这些轻量级线程被称为入口线程。这些入口线程会在以下三种情况下终止： 入口线程和所有的用户轻量级线程已经终止（意味着请求正常处理完毕）； 入口线程或用户轻量级线程调用 ngx.exit, ngx.exec, ngx.redirect, ngx.req.set_uri(uri, true); 入口线程因为 Lua 异常而终止（用户轻量级线程出错不会导致其他轻量级线程终止）； 在 Nginx 实现中子请求不能被终止，如果一个线程正在执行子请求，那么该线程不允许被终止。对于具有子请求的线程，应该使用 ngx.thread.wait 等待其终止，异常情况下可以使用 ngx.ERROR, 408, 444, 499 调用 ngx.exit 来终止子请求。 轻量级线程不会以抢占方式进行调度，线程会一直运行直至以下三种情况才会让出执行： 非阻塞 IO 无法在一次运行中完成； 线程调用 coroutine.yield 主动让出； 触发 Lua 异常而退出或者调用 ngx.exit, ngx.exec, ngx.redirect, ngx.req.set_uri(uri, true) 而退出； 线程有父子关系，只有父线程能调用 ngx.thread.wait, ngx.thread.kill 去等待或杀掉子线程。轻量级线程有“僵尸”状态：当前线程已经结束（正常或错误退出），它的父线程还存活但是父线程未使用 ngx.thread.wait 等待线程结束。 2. wait12syntax: ok, res1 = ngx.thread.wait(thread1, thread2, ...)context: rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua* 等待一个或多个之前通过 ngx.thread.spawn 创建的线程结束，当其中一个线程结束或退出时函数返回。返回值与 coroutine.resume 返回值相同。ok 表示线程是否成功终止，而后续返回值是用户函数的返回值或其执行错误。 3. kill12syntax: ok, err = ngx.thread.kill(thread)context: rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua* 关闭之前由 spawn 创建的线程，当成功时 ok 为 true，失败时返回 nil 以及错误描述。 实现1. spawn123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115// 创建新的请轻量级线程// 在此次并未执行新创建的协程，本函数结束后，会处罚协程调度，在协程调度中执行新创建协程static intngx_http_lua_uthread_spawn(lua_State *L)&#123; // ... ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module); // 创建协程 ngx_http_lua_coroutine_create_helper(L, r, ctx, &amp;coctx); /* anchor the newly created coroutine into the Lua registry */ lua_pushlightuserdata(L, &amp;ngx_http_lua_coroutines_key); // 从 LUA_REGISTRYINDEX 伪索引中获得 ngx_http_lua_coroutines_key 指向的表，并将其压入栈顶 lua_rawget(L, LUA_REGISTRYINDEX); // 此时 -2 索引指向新创建的协程 coctx-&gt;co，创建其拷贝并压入栈顶 lua_pushvalue(L, -2); // 将新创建的协程从栈顶移除，并在 ngx_http_lua_coroutines_key 指定表中存储 coctx-&gt;co_ref = luaL_ref(L, -2); lua_pop(L, 1); // 将新创建协程出栈 // 将新创建的协程运行参数从其父协程移动到新创建的协程中，会保持原先顺序 if (n &gt; 1) &#123; lua_replace(L, 1); lua_xmove(L, coctx-&gt;co, n - 1); &#125; coctx-&gt;is_uthread = 1; ctx-&gt;uthreads++; // 设置新建协程状态 coctx-&gt;co_status = NGX_HTTP_LUA_CO_RUNNING; // 设置当前协程状态 ctx-&gt;co_op = NGX_HTTP_LUA_USER_THREAD_RESUME; ctx-&gt;cur_co_ctx-&gt;thread_spawn_yielded = 1; // 将新创建的协程存储在请求 ctx 中的 posted_threads if (ngx_http_lua_post_thread(r, ctx, ctx-&gt;cur_co_ctx) != NGX_OK) &#123; return luaL_error(L, &quot;no memory&quot;); &#125; coctx-&gt;parent_co_ctx = ctx-&gt;cur_co_ctx; ctx-&gt;cur_co_ctx = coctx; // dtrace 使用，忽略 ngx_http_lua_probe_user_thread_spawn(r, L, coctx-&gt;co); dd(&quot;yielding with arg %s, top=%d, index-1:%s&quot;, luaL_typename(L, -1), (int) lua_gettop(L), luaL_typename(L, 1)); // 调用协程让出，以便新创建的协程运行，返回一个协程结果 return lua_yield(L, 1);&#125;// 创建协程intngx_http_lua_coroutine_create_helper(lua_State *L, ngx_http_request_t *r, ngx_http_lua_ctx_t *ctx, ngx_http_lua_co_ctx_t **pcoctx)&#123; // ... omit vm = ngx_http_lua_get_lua_vm(r, ctx); /* create new coroutine on root Lua state, so it always yields * to main Lua thread */ co = lua_newthread(vm); // dtrace 检测使用，忽略 ngx_http_lua_probe_user_coroutine_create(r, L, co); // 创建 coctx coctx = ngx_http_lua_get_co_ctx(co, ctx); if (coctx == NULL) &#123; coctx = ngx_http_lua_create_co_ctx(r, ctx); if (coctx == NULL) &#123; return luaL_error(L, &quot;no memory&quot;); &#125; &#125; else &#123; ngx_memzero(coctx, sizeof(ngx_http_lua_co_ctx_t)); coctx-&gt;co_ref = LUA_NOREF; &#125; coctx-&gt;co = co; coctx-&gt;co_status = NGX_HTTP_LUA_CO_SUSPENDED; /* make new coroutine share globals of the parent coroutine. * NOTE: globals don&#x27;t have to be separated! */ // 将协程环境的全局变量压入栈顶 // 协程环境的全局变量都在 LUA_GLOBALSINDEX 伪索引指向的表中 // 运行的 C 函数的全局变量都在 LUA_ENVIRONINDEX 伪索引指向的表中 ngx_http_lua_get_globals_table(L); // 将 L 协程栈中 1 索引处值出栈，压入 co 协程的栈顶 lua_xmove(L, co, 1); // 将 co 协程栈顶的全局环境表移动到 LUA_GLOBALSINDEX 处，实现继承父协程的全局环境 ngx_http_lua_set_globals_table(co); // 将主协程 vm 栈底的元素 co 协程移动到 L 协程栈顶 lua_xmove(vm, L, 1); /* move coroutine from main thread to L */ // 将栈底的函数拷贝并压入栈顶 lua_pushvalue(L, 1); /* copy entry function to top of L*/ // 从 L 协程栈底移动到 co 协程栈顶 lua_xmove(L, co, 1); /* move entry function from L to co */ if (pcoctx) &#123; *pcoctx = coctx; &#125;#ifdef NGX_LUA_USE_ASSERT coctx-&gt;co_top = 1;#endif return 1; /* return new coroutine to Lua */&#125; 2. wait1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889// syntax: ok, res1, res2, ... = ngx.thread.wait(thread1, thread2, ...)static intngx_http_lua_uthread_wait(lua_State *L)&#123; // ... 忽略代码 ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module); if (ctx == NULL) &#123; return luaL_error(L, &quot;no request ctx found&quot;); &#125; // 允许介入阶段 ngx_http_lua_check_context(L, ctx, NGX_HTTP_LUA_CONTEXT_REWRITE | NGX_HTTP_LUA_CONTEXT_ACCESS | NGX_HTTP_LUA_CONTEXT_CONTENT | NGX_HTTP_LUA_CONTEXT_TIMER | NGX_HTTP_LUA_CONTEXT_SSL_CERT); coctx = ctx-&gt;cur_co_ctx; nargs = lua_gettop(L); for (i = 1; i &lt;= nargs; i++) &#123; sub_co = lua_tothread(L, i); luaL_argcheck(L, sub_co, i, &quot;lua thread expected&quot;); sub_coctx = ngx_http_lua_get_co_ctx(sub_co, ctx); if (sub_coctx == NULL) &#123; return luaL_error(L, &quot;no co ctx found&quot;); &#125; if (!sub_coctx-&gt;is_uthread) &#123; return luaL_error(L, &quot;attempt to wait on a coroutine that is &quot; &quot;not a user thread&quot;); &#125; if (sub_coctx-&gt;parent_co_ctx != coctx) &#123; return luaL_error(L, &quot;only the parent coroutine can wait on the &quot; &quot;thread&quot;); &#125; switch (sub_coctx-&gt;co_status) &#123; case NGX_HTTP_LUA_CO_ZOMBIE: ngx_http_lua_probe_info(&quot;found zombie child&quot;); nrets = lua_gettop(sub_coctx-&gt;co); dd(&quot;child retval count: %d, %s: %s&quot;, (int) nrets, luaL_typename(sub_coctx-&gt;co, -1), lua_tostring(sub_coctx-&gt;co, -1)); if (nrets) &#123; lua_xmove(sub_coctx-&gt;co, L, nrets); &#125;#if 1 ngx_http_lua_del_thread(r, L, ctx, sub_coctx); ctx-&gt;uthreads--;#endif return nrets; case NGX_HTTP_LUA_CO_DEAD: dd(&quot;uthread already waited: %p (parent %p)&quot;, sub_coctx, coctx); if (i &lt; nargs) &#123; /* just ignore it if it is not the last one */ continue; &#125; /* being the last one */ lua_pushnil(L); lua_pushliteral(L, &quot;already waited or killed&quot;); return 2; default: dd(&quot;uthread %p still alive, status: %d, parent %p&quot;, sub_coctx, sub_coctx-&gt;co_status, coctx); break; &#125; ngx_http_lua_probe_user_thread_wait(L, sub_coctx-&gt;co); sub_coctx-&gt;waited_by_parent = 1; &#125; // 调用协程让出，返回 0 个参数 return lua_yield(L, 0);&#125; 3. kill123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// syntax: ok, err = ngx.thread.kill(thread)static intngx_http_lua_uthread_kill(lua_State *L)&#123; // ... 忽略参数判断 // 阶段判断 ngx_http_lua_check_context(L, ctx, NGX_HTTP_LUA_CONTEXT_REWRITE | NGX_HTTP_LUA_CONTEXT_ACCESS | NGX_HTTP_LUA_CONTEXT_CONTENT | NGX_HTTP_LUA_CONTEXT_TIMER | NGX_HTTP_LUA_CONTEXT_SSL_CERT); coctx = ctx-&gt;cur_co_ctx; // 栈底元素转换为协程对象 sub_co = lua_tothread(L, 1); luaL_argcheck(L, sub_co, 1, &quot;lua thread expected&quot;); sub_coctx = ngx_http_lua_get_co_ctx(sub_co, ctx); if (sub_coctx == NULL) &#123; return luaL_error(L, &quot;no co ctx found&quot;); &#125; if (!sub_coctx-&gt;is_uthread) &#123; lua_pushnil(L); lua_pushliteral(L, &quot;not user thread&quot;); return 2; &#125; if (sub_coctx-&gt;parent_co_ctx != coctx) &#123; lua_pushnil(L); lua_pushliteral(L, &quot;killer not parent&quot;); return 2; &#125; if (sub_coctx-&gt;pending_subreqs &gt; 0) &#123; lua_pushnil(L); lua_pushliteral(L, &quot;pending subrequests&quot;); return 2; &#125; switch (sub_coctx-&gt;co_status) &#123; case NGX_HTTP_LUA_CO_ZOMBIE: // 从索引表中删除协程 ngx_http_lua_del_thread(r, L, ctx, sub_coctx); ctx-&gt;uthreads--; lua_pushnil(L); lua_pushliteral(L, &quot;already terminated&quot;); return 2; case NGX_HTTP_LUA_CO_DEAD: lua_pushnil(L); lua_pushliteral(L, &quot;already waited or killed&quot;); return 2; default: // 调用 clenup 回调函数进行清理 ngx_http_lua_cleanup_pending_operation(sub_coctx); ngx_http_lua_del_thread(r, L, ctx, sub_coctx); ctx-&gt;uthreads--; lua_pushinteger(L, 1); return 1; &#125; /* not reacheable */&#125; 协程调度以 access_by_lua 指令为例，查看 thread 调度。 1. access_by_lua123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161// entry threadstatic ngx_int_tngx_http_lua_access_by_chunk(lua_State *L, ngx_http_request_t *r)&#123; int co_ref; ngx_int_t rc; lua_State *co; ngx_event_t *rev; ngx_connection_t *c; ngx_http_lua_ctx_t *ctx; ngx_http_cleanup_t *cln; ngx_http_lua_loc_conf_t *llcf; /* &#123;&#123;&#123; new coroutine to handle request */ co = ngx_http_lua_new_thread(r, L, &amp;co_ref); if (co == NULL) &#123; ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0, &quot;lua: failed to create new coroutine &quot; &quot;to handle request&quot;); return NGX_HTTP_INTERNAL_SERVER_ERROR; &#125; /* move code closure to new coroutine */ lua_xmove(L, co, 1); /* set closure&#x27;s env table to new coroutine&#x27;s globals table */ ngx_http_lua_get_globals_table(co); lua_setfenv(co, -2); /* save nginx request in coroutine globals table */ ngx_http_lua_set_req(co, r); /* &#123;&#123;&#123; initialize request context */ ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module); dd(&quot;ctx = %p&quot;, ctx); if (ctx == NULL) &#123; return NGX_ERROR; &#125; ngx_http_lua_reset_ctx(r, L, ctx); ctx-&gt;entered_access_phase = 1; ctx-&gt;cur_co_ctx = &amp;ctx-&gt;entry_co_ctx; ctx-&gt;cur_co_ctx-&gt;co = co; ctx-&gt;cur_co_ctx-&gt;co_ref = co_ref;#ifdef NGX_LUA_USE_ASSERT ctx-&gt;cur_co_ctx-&gt;co_top = 1;#endif /* &#125;&#125;&#125; */ /* &#123;&#123;&#123; register request cleanup hooks */ if (ctx-&gt;cleanup == NULL) &#123; cln = ngx_http_cleanup_add(r, 0); if (cln == NULL) &#123; return NGX_HTTP_INTERNAL_SERVER_ERROR; &#125; cln-&gt;handler = ngx_http_lua_request_cleanup_handler; cln-&gt;data = ctx; ctx-&gt;cleanup = &amp;cln-&gt;handler; &#125; /* &#125;&#125;&#125; */ ctx-&gt;context = NGX_HTTP_LUA_CONTEXT_ACCESS; llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module); if (llcf-&gt;check_client_abort) &#123; r-&gt;read_event_handler = ngx_http_lua_rd_check_broken_connection;#if (NGX_HTTP_V2) if (!r-&gt;stream) &#123;#endif rev = r-&gt;connection-&gt;read; if (!rev-&gt;active) &#123; if (ngx_add_event(rev, NGX_READ_EVENT, 0) != NGX_OK) &#123; return NGX_ERROR; &#125; &#125;#if (NGX_HTTP_V2) &#125;#endif &#125; else &#123; r-&gt;read_event_handler = ngx_http_block_reading; &#125; // 进入线程调度 thread scheduler rc = ngx_http_lua_run_thread(L, r, ctx, 0); dd(&quot;returned %d&quot;, (int) rc); if (rc == NGX_ERROR || rc &gt; NGX_OK) &#123; return rc; &#125; c = r-&gt;connection; if (rc == NGX_AGAIN) &#123; rc = ngx_http_lua_run_posted_threads(c, L, r, ctx); if (rc == NGX_ERROR || rc == NGX_DONE || rc &gt; NGX_OK) &#123; return rc; &#125; if (rc != NGX_OK) &#123; return NGX_DECLINED; &#125; &#125; else if (rc == NGX_DONE) &#123; ngx_http_lua_finalize_request(r, NGX_DONE); rc = ngx_http_lua_run_posted_threads(c, L, r, ctx); if (rc == NGX_ERROR || rc == NGX_DONE || rc &gt; NGX_OK) &#123; return rc; &#125; if (rc != NGX_OK) &#123; return NGX_DECLINED; &#125; &#125;#if 1 if (rc == NGX_OK) &#123; if (r-&gt;header_sent) &#123; dd(&quot;header already sent&quot;); /* response header was already generated in access_by_lua*, * so it is no longer safe to proceed to later phases * which may generate responses again */ if (!ctx-&gt;eof) &#123; dd(&quot;eof not yet sent&quot;); rc = ngx_http_lua_send_chain_link(r, ctx, NULL /* indicate last_buf */); if (rc == NGX_ERROR || rc &gt; NGX_OK) &#123; return rc; &#125; &#125; return NGX_HTTP_OK; &#125; return NGX_OK; &#125;#endif return NGX_DECLINED;&#125; 2. ngx_http_lua_run_thread123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576// 调度线程/* * description: * run a Lua coroutine specified by ctx-&gt;cur_co_ctx-&gt;co * return value: * NGX_AGAIN: I/O interruption: r-&gt;main-&gt;count intact * NGX_DONE: I/O interruption: r-&gt;main-&gt;count already incremented by 1 * NGX_ERROR: error * &gt;= 200 HTTP status code */ngx_int_tngx_http_lua_run_thread(lua_State *L, ngx_http_request_t *r, ngx_http_lua_ctx_t *ctx, volatile int nrets)&#123; ngx_http_lua_co_ctx_t *next_coctx, *parent_coctx, *orig_coctx; int rv, success = 1; lua_State *next_co; lua_State *old_co; const char *err, *msg, *trace; ngx_int_t rc;#if (NGX_PCRE) ngx_pool_t *old_pool = NULL;#endif ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, &quot;lua run thread, top:%d c:%ud&quot;, lua_gettop(L), r-&gt;main-&gt;count); /* set Lua VM panic handler */ lua_atpanic(L, ngx_http_lua_atpanic); dd(&quot;ctx = %p&quot;, ctx); NGX_LUA_EXCEPTION_TRY &#123; // 协程刚刚创建？ if (ctx-&gt;cur_co_ctx-&gt;thread_spawn_yielded) &#123; ngx_http_lua_probe_info(&quot;thread spawn yielded&quot;); ctx-&gt;cur_co_ctx-&gt;thread_spawn_yielded = 0; nrets = 1; &#125; for ( ;; ) &#123; dd(&quot;calling lua_resume: vm %p, nret %d&quot;, ctx-&gt;cur_co_ctx-&gt;co, (int) nrets);#if (NGX_PCRE) /* XXX: work-around to nginx regex subsystem */ old_pool = ngx_http_lua_pcre_malloc_init(r-&gt;pool);#endif /* run code */ dd(&quot;ctx: %p&quot;, ctx); dd(&quot;cur co: %p&quot;, ctx-&gt;cur_co_ctx-&gt;co); dd(&quot;cur co status: %d&quot;, ctx-&gt;cur_co_ctx-&gt;co_status); // 当前待执行线程 orig_coctx = ctx-&gt;cur_co_ctx;#ifdef NGX_LUA_USE_ASSERT dd(&quot;%p: saved co top: %d, nrets: %d, true top: %d&quot;, orig_coctx-&gt;co, (int) orig_coctx-&gt;co_top, (int) nrets, (int) lua_gettop(orig_coctx-&gt;co));#endif#if DDEBUG if (lua_gettop(orig_coctx-&gt;co) &gt; 0) &#123; dd(&quot;top elem: %s&quot;, luaL_typename(orig_coctx-&gt;co, -1)); &#125;#endif ngx_http_lua_assert(orig_coctx-&gt;co_top + nrets == lua_gettop(orig_coctx-&gt;co)); // 执行线程 rv = lua_resume(orig_coctx-&gt;co, nrets);#if (NGX_PCRE) /* XXX: work-around to nginx regex subsystem */ ngx_http_lua_pcre_malloc_done(old_pool);#endif#if 0 /* test the longjmp thing */ if (rand() % 2 == 0) &#123; NGX_LUA_EXCEPTION_THROW(1); &#125;#endif ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, &quot;lua resume returned %d&quot;, rv); switch (rv) &#123; // rv == YIELD 线程主动让出 case LUA_YIELD: /* yielded, let event handler do the rest job */ /* FIXME: add io cmd dispatcher here */ ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, &quot;lua thread yielded&quot;);#ifdef NGX_LUA_USE_ASSERT dd(&quot;%p: saving curr top after yield: %d (co-op: %d)&quot;, orig_coctx-&gt;co, (int) lua_gettop(orig_coctx-&gt;co), (int) ctx-&gt;co_op); orig_coctx-&gt;co_top = lua_gettop(orig_coctx-&gt;co);#endif // uri rewrite，执行 server_rewrite if (r-&gt;uri_changed) &#123; return ngx_http_lua_handle_rewrite_jump(L, r, ctx); &#125; // 调用了 ngx.exit，请求处理结束处理 if (ctx-&gt;exited) &#123; return ngx_http_lua_handle_exit(L, r, ctx); &#125; // 调用了 ngx.exec，执行 server_rewrite if (ctx-&gt;exec_uri.len) &#123; return ngx_http_lua_handle_exec(L, r, ctx); &#125; /* * check if coroutine.resume or coroutine.yield called * lua_yield() */ switch(ctx-&gt;co_op) &#123; // 等待 io 事件触发 case NGX_HTTP_LUA_USER_CORO_NOP: dd(&quot;hit! it is the API yield&quot;); ngx_http_lua_assert(lua_gettop(ctx-&gt;cur_co_ctx-&gt;co) == 0); ctx-&gt;cur_co_ctx = NULL; return NGX_AGAIN; // 创建新线程，break 后再次执行循环，执行新创建的线程 case NGX_HTTP_LUA_USER_THREAD_RESUME: ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, &quot;lua user thread resume&quot;); ctx-&gt;co_op = NGX_HTTP_LUA_USER_CORO_NOP; nrets = lua_gettop(ctx-&gt;cur_co_ctx-&gt;co) - 1; dd(&quot;nrets = %d&quot;, nrets);#ifdef NGX_LUA_USE_ASSERT /* ignore the return value (the thread) already pushed */ orig_coctx-&gt;co_top--;#endif break; // 用户线程调用 resume 运行其他线程 // 此时 ctx-&gt;cur_co_ctx 是待执行的线程， // 在整个模块中只有 ngx_http_lua_coroutine_resume 函数设置 co_op 为 RESUME 状态 case NGX_HTTP_LUA_USER_CORO_RESUME: ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, &quot;lua coroutine: resume&quot;); /* * the target coroutine lies at the base of the * parent&#x27;s stack */ ctx-&gt;co_op = NGX_HTTP_LUA_USER_CORO_NOP; old_co = ctx-&gt;cur_co_ctx-&gt;parent_co_ctx-&gt;co; nrets = lua_gettop(old_co); if (nrets) &#123; dd(&quot;moving %d return values to parent&quot;, nrets); // 将父线程调用 resume 的 nrets 个参数从父线程移动到子线程 lua_xmove(old_co, ctx-&gt;cur_co_ctx-&gt;co, nrets);#ifdef NGX_LUA_USE_ASSERT ctx-&gt;cur_co_ctx-&gt;parent_co_ctx-&gt;co_top -= nrets;#endif &#125; // break 后会执行 resume 调用的函数 break; default: /* ctx-&gt;co_op == NGX_HTTP_LUA_USER_CORO_YIELD */ ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, &quot;lua coroutine: yield&quot;); ctx-&gt;co_op = NGX_HTTP_LUA_USER_CORO_NOP; // entry thread 无父线程，只能忽略其返还参数，并尝试将其放入 posted_threads 中 if (ngx_http_lua_is_thread(ctx)) &#123; ngx_http_lua_probe_thread_yield(r, ctx-&gt;cur_co_ctx-&gt;co); /* discard any return values from user * coroutine.yield()&#x27;s arguments */ lua_settop(ctx-&gt;cur_co_ctx-&gt;co, 0);#ifdef NGX_LUA_USE_ASSERT ctx-&gt;cur_co_ctx-&gt;co_top = 0;#endif ngx_http_lua_probe_info(&quot;set co running&quot;); ctx-&gt;cur_co_ctx-&gt;co_status = NGX_HTTP_LUA_CO_RUNNING; if (ctx-&gt;posted_threads) &#123; ngx_http_lua_post_thread(r, ctx, ctx-&gt;cur_co_ctx); ctx-&gt;cur_co_ctx = NULL; return NGX_AGAIN; &#125; /* no pending threads, so resume the thread * immediately */ nrets = 0; continue; &#125; /* being a user coroutine that has a parent */ // 用户线程，找到其父线程，并将结果拷贝到父线程栈中，继续进行循环，触发父线程处理 nrets = lua_gettop(ctx-&gt;cur_co_ctx-&gt;co); next_coctx = ctx-&gt;cur_co_ctx-&gt;parent_co_ctx; next_co = next_coctx-&gt;co; /* * prepare return values for coroutine.resume * (true plus any retvals) */ lua_pushboolean(next_co, 1); if (nrets) &#123; dd(&quot;moving %d return values to next co&quot;, nrets); lua_xmove(ctx-&gt;cur_co_ctx-&gt;co, next_co, nrets);#ifdef NGX_LUA_USE_ASSERT ctx-&gt;cur_co_ctx-&gt;co_top -= nrets;#endif &#125; nrets++; /* add the true boolean value */ ctx-&gt;cur_co_ctx = next_coctx; break; &#125; /* try resuming on the new coroutine again */ continue; // rv == 0 线程退出 case 0: ngx_http_lua_cleanup_pending_operation(ctx-&gt;cur_co_ctx); ngx_http_lua_probe_coroutine_done(r, ctx-&gt;cur_co_ctx-&gt;co, 1); ctx-&gt;cur_co_ctx-&gt;co_status = NGX_HTTP_LUA_CO_DEAD; if (ctx-&gt;cur_co_ctx-&gt;zombie_child_threads) &#123; ngx_http_lua_cleanup_zombie_child_uthreads(r, L, ctx, ctx-&gt;cur_co_ctx); &#125; ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, &quot;lua light thread ended normally&quot;); if (ngx_http_lua_is_entry_thread(ctx)) &#123; // 清空栈 lua_settop(L, 0); ngx_http_lua_del_thread(r, L, ctx, ctx-&gt;cur_co_ctx); dd(&quot;uthreads: %d&quot;, (int) ctx-&gt;uthreads); if (ctx-&gt;uthreads) &#123; ctx-&gt;cur_co_ctx = NULL; return NGX_AGAIN; &#125; /* all user threads terminated already */ goto done; &#125; // 用户线程 if (ctx-&gt;cur_co_ctx-&gt;is_uthread) &#123; /* being a user thread */ lua_settop(L, 0); parent_coctx = ctx-&gt;cur_co_ctx-&gt;parent_co_ctx; if (ngx_http_lua_coroutine_alive(parent_coctx)) &#123; if (ctx-&gt;cur_co_ctx-&gt;waited_by_parent) &#123; ngx_http_lua_probe_info(&quot;parent already waiting&quot;); ctx-&gt;cur_co_ctx-&gt;waited_by_parent = 0; success = 1; goto user_co_done; &#125; ngx_http_lua_probe_info(&quot;parent still alive&quot;); if (ngx_http_lua_post_zombie_thread(r, parent_coctx, ctx-&gt;cur_co_ctx) != NGX_OK) &#123; return NGX_ERROR; &#125; lua_pushboolean(ctx-&gt;cur_co_ctx-&gt;co, 1); lua_insert(ctx-&gt;cur_co_ctx-&gt;co, 1); ctx-&gt;cur_co_ctx-&gt;co_status = NGX_HTTP_LUA_CO_ZOMBIE; ctx-&gt;cur_co_ctx = NULL; return NGX_AGAIN; &#125; ngx_http_lua_del_thread(r, L, ctx, ctx-&gt;cur_co_ctx); ctx-&gt;uthreads--; if (ctx-&gt;uthreads == 0) &#123; if (ngx_http_lua_entry_thread_alive(ctx)) &#123; ctx-&gt;cur_co_ctx = NULL; return NGX_AGAIN; &#125; /* all threads terminated already */ goto done; &#125; /* some other user threads still running */ ctx-&gt;cur_co_ctx = NULL; return NGX_AGAIN; &#125; /* being a user coroutine that has a parent */ success = 1;user_co_done: nrets = lua_gettop(ctx-&gt;cur_co_ctx-&gt;co); next_coctx = ctx-&gt;cur_co_ctx-&gt;parent_co_ctx; if (next_coctx == NULL) &#123; /* being a light thread */ goto no_parent; &#125; next_co = next_coctx-&gt;co; /* * ended successful, coroutine.resume returns true plus * any return values */ lua_pushboolean(next_co, success); if (nrets) &#123; lua_xmove(ctx-&gt;cur_co_ctx-&gt;co, next_co, nrets); &#125; if (ctx-&gt;cur_co_ctx-&gt;is_uthread) &#123; ngx_http_lua_del_thread(r, L, ctx, ctx-&gt;cur_co_ctx); ctx-&gt;uthreads--; &#125; nrets++; ctx-&gt;cur_co_ctx = next_coctx; ngx_http_lua_probe_info(&quot;set parent running&quot;); next_coctx-&gt;co_status = NGX_HTTP_LUA_CO_RUNNING; ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, &quot;lua coroutine: lua user thread ended normally&quot;); continue; // rv == LUA_ERRRUN case LUA_ERRRUN: err = &quot;runtime error&quot;; break; // rv == LUA_ERRSYNTAX case LUA_ERRSYNTAX: err = &quot;syntax error&quot;; break; case LUA_ERRMEM: err = &quot;memory allocation error&quot;; ngx_quit = 1; break; case LUA_ERRERR: err = &quot;error handler error&quot;; break; default: err = &quot;unknown error&quot;; break; &#125; // 以下为线程执行出错处理 if (ctx-&gt;cur_co_ctx != orig_coctx) &#123; ctx-&gt;cur_co_ctx = orig_coctx; &#125; // 栈顶存储错误信息 if (lua_isstring(ctx-&gt;cur_co_ctx-&gt;co, -1)) &#123; dd(&quot;user custom error msg&quot;); msg = lua_tostring(ctx-&gt;cur_co_ctx-&gt;co, -1); &#125; else &#123; msg = &quot;unknown reason&quot;; &#125; ngx_http_lua_cleanup_pending_operation(ctx-&gt;cur_co_ctx); ngx_http_lua_probe_coroutine_done(r, ctx-&gt;cur_co_ctx-&gt;co, 0); ctx-&gt;cur_co_ctx-&gt;co_status = NGX_HTTP_LUA_CO_DEAD; ngx_http_lua_thread_traceback(L, ctx-&gt;cur_co_ctx-&gt;co, ctx-&gt;cur_co_ctx); trace = lua_tostring(L, -1); // 用户线程 if (ctx-&gt;cur_co_ctx-&gt;is_uthread) &#123; ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0, &quot;lua user thread aborted: %s: %s\\n%s&quot;, err, msg, trace); lua_settop(L, 0); parent_coctx = ctx-&gt;cur_co_ctx-&gt;parent_co_ctx; // 父线程存活 if (ngx_http_lua_coroutine_alive(parent_coctx)) &#123; if (ctx-&gt;cur_co_ctx-&gt;waited_by_parent) &#123; // 父线程在等待子线程，执行父线程 ctx-&gt;cur_co_ctx-&gt;waited_by_parent = 0; success = 0; goto user_co_done; &#125; if (ngx_http_lua_post_zombie_thread(r, parent_coctx, ctx-&gt;cur_co_ctx) != NGX_OK) &#123; return NGX_ERROR; &#125; lua_pushboolean(ctx-&gt;cur_co_ctx-&gt;co, 0); lua_insert(ctx-&gt;cur_co_ctx-&gt;co, 1); ctx-&gt;cur_co_ctx-&gt;co_status = NGX_HTTP_LUA_CO_ZOMBIE; ctx-&gt;cur_co_ctx = NULL; return NGX_AGAIN; &#125; // 父线程已经结束 ngx_http_lua_del_thread(r, L, ctx, ctx-&gt;cur_co_ctx); ctx-&gt;uthreads--; if (ctx-&gt;uthreads == 0) &#123; if (ngx_http_lua_entry_thread_alive(ctx)) &#123; ctx-&gt;cur_co_ctx = NULL; return NGX_AGAIN; &#125; /* all threads terminated already */ goto done; &#125; /* some other user threads still running */ ctx-&gt;cur_co_ctx = NULL; return NGX_AGAIN; &#125; // entry 线程 if (ngx_http_lua_is_entry_thread(ctx)) &#123; ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0, &quot;lua entry thread aborted: %s: %s\\n%s&quot;, err, msg, trace); lua_settop(L, 0); /* being the entry thread aborted */ if (r-&gt;filter_finalize) &#123; ngx_http_set_ctx(r, ctx, ngx_http_lua_module); &#125; ngx_http_lua_request_cleanup(ctx, 0); dd(&quot;headers sent? %d&quot;, r-&gt;header_sent || ctx-&gt;header_sent); if (ctx-&gt;no_abort) &#123; ctx-&gt;no_abort = 0; return NGX_ERROR; &#125; return (r-&gt;header_sent || ctx-&gt;header_sent) ? NGX_ERROR : NGX_HTTP_INTERNAL_SERVER_ERROR; &#125; // 按说不会执行到此处 /* being a user coroutine that has a parent */ next_coctx = ctx-&gt;cur_co_ctx-&gt;parent_co_ctx; if (next_coctx == NULL) &#123; goto no_parent; &#125; next_co = next_coctx-&gt;co; ngx_http_lua_probe_info(&quot;set parent running&quot;); next_coctx-&gt;co_status = NGX_HTTP_LUA_CO_RUNNING; /* * ended with error, coroutine.resume returns false plus * err msg */ lua_pushboolean(next_co, 0); lua_xmove(ctx-&gt;cur_co_ctx-&gt;co, next_co, 1); nrets = 2; ctx-&gt;cur_co_ctx = next_coctx; ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0, &quot;lua coroutine: %s: %s\\n%s&quot;, err, msg, trace); /* try resuming on the new coroutine again */ continue; &#125; &#125; NGX_LUA_EXCEPTION_CATCH &#123; dd(&quot;nginx execution restored&quot;); &#125; return NGX_ERROR;no_parent: lua_settop(L, 0); ctx-&gt;cur_co_ctx-&gt;co_status = NGX_HTTP_LUA_CO_DEAD; if (r-&gt;filter_finalize) &#123; ngx_http_set_ctx(r, ctx, ngx_http_lua_module); &#125; ngx_http_lua_request_cleanup(ctx, 0); ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0, &quot;lua handler aborted: &quot; &quot;user coroutine has no parent&quot;); return (r-&gt;header_sent || ctx-&gt;header_sent) ? NGX_ERROR : NGX_HTTP_INTERNAL_SERVER_ERROR;done: if (ctx-&gt;entered_content_phase &amp;&amp; r-&gt;connection-&gt;fd != (ngx_socket_t) -1) &#123; // 发送应答 header，body rc = ngx_http_lua_send_chain_link(r, ctx, NULL /* last_buf */); if (rc == NGX_ERROR || rc &gt;= NGX_HTTP_SPECIAL_RESPONSE) &#123; return rc; &#125; &#125; return NGX_OK;&#125;","categories":[{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/categories/NGINX/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"Lua","slug":"Lua","permalink":"https://juzipeek.github.io/tags/Lua/"},{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/tags/NGINX/"},{"name":"OpenResty","slug":"OpenResty","permalink":"https://juzipeek.github.io/tags/OpenResty/"}]},{"title":"ngx_http_mirror_module","slug":"nginx-2019-10-04-ngx-http-mirror-module","date":"2022-09-03T12:55:44.516Z","updated":"2022-09-03T12:55:44.516Z","comments":true,"path":"2022/09/03/nginx-2019-10-04-ngx-http-mirror-module/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/nginx-2019-10-04-ngx-http-mirror-module/","excerpt":"","text":"一 概述ngx_http_mirror_module 模块使用子请求方式创建原始请求的镜像，子请求接收到的应答会被忽略。使用 ngx_http_mirror_module 可以方便的实现流量镜像，以供测试使用。 在 nginx-1.13.4 版本加入，ngx_http_mirror_module 在 NGX_HTTP_PRECONTENT_PHASE阶段介入处理，虽然 HTTP 请求处理还是由 11 阶段构成，但是，NGX_HTTP_TRY_FILES_PHASE 阶段被修改为 NGX_HTTP_PRECONTENT_PHASE 阶段，允许模块介入处理。 二 指令1. mirror123Syntax: mirror uri | off;Default: mirror off;Context: http, server, location 设置原始请求被镜像到的目的 uri（当前 server&#123;&#125; 内的 location），使用多个 mirror 指令可以复制多份。 2. mirror_request_body123Syntax: mirror_request_body on | off;Default: mirror_request_body on;Context: http, server, location 控制是否转发原始请求包体。启用后，将在创建子请求前读取客户端请求包体。 三 实现mirror 功能是通过子请求来实现，模块简单。对于 mirrro 指令处理，只是在模块中注册镜像 uri，在请求处理中会依次创建子请求。请求处理实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 在 NGX_HTTP_PRECONTENT_PHASE 阶段进行调用static ngx_int_tngx_http_mirror_handler(ngx_http_request_t *r)&#123; // ... 省略代码 if (r != r-&gt;main) &#123; return NGX_DECLINED; &#125; mlcf = ngx_http_get_module_loc_conf(r, ngx_http_mirror_module); if (mlcf-&gt;mirror == NULL) &#123; return NGX_DECLINED; &#125; ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, &quot;mirror handler&quot;); // 需要镜像请求包体 if (mlcf-&gt;request_body) &#123; ctx = ngx_http_get_module_ctx(r, ngx_http_mirror_module); if (ctx) &#123; return ctx-&gt;status; &#125; ctx = ngx_pcalloc(r-&gt;pool, sizeof(ngx_http_mirror_ctx_t)); if (ctx == NULL) &#123; return NGX_ERROR; &#125; ctx-&gt;status = NGX_DONE; ngx_http_set_ctx(r, ctx, ngx_http_mirror_module); // 先读取请求包体，再调用 ngx_http_mirror_body_handler 处理 rc = ngx_http_read_client_request_body(r, ngx_http_mirror_body_handler); if (rc &gt;= NGX_HTTP_SPECIAL_RESPONSE) &#123; return rc; &#125; ngx_http_finalize_request(r, NGX_DONE); return NGX_DONE; &#125; // 创建子请求 return ngx_http_mirror_handler_internal(r);&#125;","categories":[{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/categories/NGINX/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/tags/NGINX/"}]},{"title":"ngx_srcache","slug":"nginx-2019-10-04-ngx-srcache","date":"2022-09-03T12:55:44.516Z","updated":"2022-09-03T12:55:44.517Z","comments":true,"path":"2022/09/03/nginx-2019-10-04-ngx-srcache/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/nginx-2019-10-04-ngx-srcache/","excerpt":"","text":"一 概述ngx_srcache 是基于子请求的透明缓存层，能够为各种 location 提供缓存服务。通常，memc-nginx-module 与此模块一起使用以提供具体的缓存服务。 但是任何提供 REST 接口的模块都可以用作此模块使用的 fetch 和 store 子请求。 二 指令1. srcache_fetch1234syntax: srcache_fetch &lt;method&gt; &lt;uri&gt; &lt;args&gt;?default: nocontext: http, server, location, location ifphase: post-access 在 access 阶段注册处理函数，请求到来时会发出 Nginx 子请求以进行缓存查找。子请求收到非 200 应答时触发 cache-miss，会进行后续阶段的处理；当子请求收到 200 应答时会触发 cache-hit 处理，会使用子请求收到内容进行应答。确定应答头、应答体 2. srcache_fetch_skip1234syntax: srcache_fetch_skip &lt;flag&gt;default: srcache_fetch_skip 0context: http, server, location, location ifphase: post-access 使用 flag 作为条件，用来判断是否需要继续进行缓存查询。flag 可以是变量，当 flag 不是空字符串并且不为 “0” 时将跳过缓存查找。 3. srcache_store1234syntax: srcache_store &lt;method&gt; &lt;uri&gt; &lt;args&gt;?default: nocontext: http, server, location, location ifphase: output-filter 该指令注册一个输出过滤器处理函数，该处理函数将发出 Nginx 子请求，将当前主请求的响应保存到缓存中。 子请求的状态代码将被忽略。 默认情况下响应状态码、响应头（部分响应头未存储）、响应包体都会被存储在缓存中。可以通过 srcache_store_pass_header 或 srcache_store_hide_header 指令控制允许缓存的应答头。原始响应数据会被立即响应到客户端，srcache 不会影响主请求。 4. srcache_store_max_size1234syntax: srcache_store_max_size &lt;size&gt;default: srcache_store_max_size 0context: http, server, location, location ifphase: output-header-filter 当响应包体大于 srcache_store_max_size 设置，模块不会将当前应答存储缓存中。 5. srcache_store_skip1234syntax: srcache_store_skip &lt;flag&gt;default: srcache_store_skip 0context: http, server, location, location ifphase: output-header-filter 与 srcache_fetch_skip 指令类似，只不过 store_skip 指令用来控制是否需要进行缓存存储。 6. srcache_store_statuses1234syntax: srcache_store_statuses &lt;status1&gt; &lt;status2&gt; ..default: srcache_store_statuses 200 301 302context: http, server, location, location ifphase: output-header-filter 指令用来实现根据后端状态码来决定是否进行缓存。 7. srcache_store_ranges1234syntax: srcache_store_ranges on|offdefault: srcache_store_ranges offcontext: http, server, location, location ifphase: output-body-filter store_ranges 用来控制部分应答的存储，当配置为 on 时会对部分内容响应进行缓存存储，此时必须将 $http_range 添加到缓存 key 中。例如： 12345location / &#123; set $key &quot;$uri$args$http_range&quot;; srcache_fetch GET /memc $key; srcache_store PUT /memc $key;&#125; 8. srcache_header_buffer_size1234syntax: srcache_header_buffer_size &lt;size&gt;default: srcache_header_buffer_size 4k/8kcontext: http, server, location, location ifphase: output-header-filter 控制用来接收单个响应头的缓冲区大小。 9. srcache_store_hide_header1234syntax: srcache_store_hide_header &lt;header&gt;default: nocontext: http, server, location, location ifphase: output-header-filter 用来设置不需要进行缓存的应答头。在缓存存储时，默认已经将以下响应头过滤： 123456789ConnectionKeep-AliveProxy-AuthenticateProxy-AuthorizationTETrailersTransfer-EncodingUpgradeSet-Cookie 使用以下配置可以额外过滤掉 X-Foo、Last-Modified 响应头： 12srcache_store_hide_header X-Foo;srcache_store_hide_header Last-Modified; 10. srcache_store_pass_header1234syntax: srcache_store_pass_header &lt;header&gt;default: nocontext: http, server, location, location ifphase: output-header-filter 与 store_hide_header 指令相反，store_pass_header 用来控制必须存储的响应头。 11. srcache_methods1234syntax: srcache_methods &lt;method&gt;...default: srcache_methods GET HEADcontext: http, server, locationphase: post-access, output-header-filter srcache_methods 用来控制能够进行缓存 fetch、store 的请求方法。如果请求方法未在此列表中将跳过缓存处理。method 取值范围：GET, HEAD, POST, PUT, DELETE。 12. srcache_ignore_content_encoding1234syntax: srcache_ignore_content_encoding on|offdefault: srcache_ignore_content_encoding offcontext: http, server, location, location ifphase: output-header-filter 当关闭此指令（默认设置）时，非空的 Content-Encoding 响应标头将导致 srcache_store 跳过将整个响应的缓存存储，并向 nginx 的 error.log 文件写入 warn 日志，如下所示 12[warn] 12500#0: *1 srcache_store skipped due to response header &quot;Content-Encoding: gzip&quot; (maybe you forgot to disable compression on the backend?) 启用此指令将忽略 Content-Encoding 响应标头，并将其存储在缓存中（并且也不会写 warn 日志）。 13. srcache_request_cache_control1234syntax: srcache_request_cache_control on|offdefault: srcache_request_cache_control offcontext: http, server, locationphase: post-access, output-header-filter request_cache_control 指令用来控制是否根据请求头来执行不同的缓存策略，例如是否跳过缓存查询、是否跳过缓存存储。指令开启时，在缓存获取阶段如果请求头中有 Cache-Control: no-cache 或者 Pragma: no-cache，会跳过缓存处理；在缓存存储阶段，如果请求头中有 Cache-Control: no-store，会跳过缓存存储处理。 关闭此指令将不关心请求头中的缓存控制指令。 14. srcache_response_cache_control1234syntax: srcache_response_cache_control on|offdefault: srcache_response_cache_control oncontext: http, server, locationphase: output-header-filter 与 request_cache_control 类似，response_cache_control 用来控制业务端应答头中缓存控制指令是否启用。当指令开启时，如果应答头中有 Cache-Control: private|no-store|no-cache|max-age=0 或 Expires: 小于当前时间 将跳过缓存处理。 该指令优先于 srcache_store_no_store，srcache_store_no_cache 和 srcache_store_private 指令。 15. srcache_store_no_store1234syntax: srcache_store_no_store on|offdefault: srcache_store_no_store offcontext: http, server, locationphase: output-header-filter 启用此指令，在满足其他缓存存储条件下，将强制具有 Cache-Control：no-store 应答头的响应存储在缓存中。 默认为关闭。 16. srcache_store_no_cache1234syntax: srcache_store_no_cache on|offdefault: srcache_store_no_cache offcontext: http, server, locationphase: output-header-filter 启用此指令，在满足其他缓存存储条件下，将强制具有 Cache-Control：no-cache 应答头的响应存储在缓存中。 默认为关闭。 17. srcache_store_private1234syntax: srcache_store_private on|offdefault: srcache_store_private offcontext: http, server, locationphase: output-header-filter 启用此指令，在满足其他缓存存储条件下，将强制具有 Cache-Control：private 应答头的响应存储在缓存中。 默认为关闭。 18. srcache_default_expire1234syntax: srcache_default_expire &lt;time&gt;default: srcache_default_expire 60scontext: http, server, location, location ifphase: output-header-filter 设置缓存的默认过期时间，如果响应头中有 Cache-Control: max-age=N 或 Expires 将根据响应头设置缓存有效期。 19. srcache_max_expire1234syntax: srcache_max_expire &lt;time&gt;default: srcache_max_expire 0context: http, server, location, location ifphase: output-header-filter 该伪指令控制 $srcache_expire 变量值所允许的最大到期时间。 此设置优先于其他计算方法。 20. $srcache_expiresrcache_expire 变量是当前响应存储在缓存中的有效时间段（以秒为单位）。 计算值的算法如下： 当响应头中有 Cache-Control: max-age=N 头时，将使用 N 作为缓存有效期； 当响应头中有 Expires 时，会使用 Expires 指定时间与当前时间相减获得缓存有效期； 否则使用 srcache_default_expire 指令指定的有效期。 在以上三步计算完成后，会将有效期与 srcache_max_expire 设置值相比较，如果超过 srcache_max_expire 设置值，则设置为 srcache_max_expire 值。 三 实现srcache 模块同时介入 NGX_HTTP_ACCESS_PHASE 、 HEADER_FILTER、BODY_FILTER 处理阶段。缓存的读取需要 NGX_HTTP_ACCESS_PHASE 阶段与 HEADER|BODY_FILTER阶段配合实现；缓存的设置在 BODY_FILTER 阶段实现。缓存的读取、设置是在一个状态循环中实现（有些过于复杂），HEADER|BODY_FILTER 除了给主请求使用外还给子请求使用，在其中判断缓存查找是否成功、将查找缓存拷贝到 ctx 中。 1. 注册处理函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 注册除了函数static ngx_int_tngx_http_srcache_post_config(ngx_conf_t *cf)&#123; int multi_http_blocks; ngx_int_t rc; ngx_http_handler_pt *h; ngx_http_core_main_conf_t *cmcf; ngx_http_srcache_main_conf_t *smcf; rc = ngx_http_srcache_add_variables(cf); if (rc != NGX_OK) &#123; return rc; &#125; smcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_srcache_filter_module); if (ngx_http_srcache_prev_cycle != ngx_cycle) &#123; ngx_http_srcache_prev_cycle = ngx_cycle; multi_http_blocks = 0; &#125; else &#123; multi_http_blocks = 1; &#125; if (multi_http_blocks || smcf-&gt;module_used) &#123; dd(&quot;using ngx-srcache&quot;); /* register our output filters */ rc = ngx_http_srcache_filter_init(cf); if (rc != NGX_OK) &#123; return rc; &#125; cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module); /* register our access phase handler */ h = ngx_array_push(&amp;cmcf-&gt;phases[NGX_HTTP_ACCESS_PHASE].handlers); if (h == NULL) &#123; return NGX_ERROR; &#125; *h = ngx_http_srcache_access_handler; &#125; return NGX_OK;&#125; 2. 读缓存上半部123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266ngx_int_tngx_http_srcache_access_handler(ngx_http_request_t *r)&#123; ngx_str_t skip; ngx_int_t rc; ngx_http_srcache_loc_conf_t *conf; ngx_http_srcache_main_conf_t *smcf; ngx_http_srcache_ctx_t *ctx; ngx_chain_t *cl; size_t len; unsigned no_store; /* access phase handlers are skipped in subrequests, * so the current request must be a main request */ conf = ngx_http_get_module_loc_conf(r, ngx_http_srcache_filter_module); // 未配置 fetch、store 指令，不需要进行缓存处理 if (conf-&gt;fetch == NULL &amp;&amp; conf-&gt;store == NULL) &#123; dd(&quot;bypass: %.*s&quot;, (int) r-&gt;uri.len, r-&gt;uri.data); return NGX_DECLINED; &#125; dd(&quot;store defined? %p&quot;, conf-&gt;store); dd(&quot;req method: %lu&quot;, (unsigned long) r-&gt;method); dd(&quot;cache methods: %lu&quot;, (unsigned long) conf-&gt;cache_methods); // 请求方法与缓存允许方法不匹配，跳过缓存处理 if (!(r-&gt;method &amp; conf-&gt;cache_methods)) &#123; ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, &quot;srcache_fetch and srcache_store skipped due to request &quot; &quot;method %V&quot;, &amp;r-&gt;method_name); return NGX_DECLINED; &#125; // 启用 cache-control 指令，并且不需要进行 cache 处理 if (conf-&gt;req_cache_control &amp;&amp; ngx_http_srcache_request_no_cache(r, &amp;no_store) == NGX_OK) &#123; ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, &quot;srcache_fetch skipped due to request headers &quot; &quot;\\&quot;Cache-Control: no-cache\\&quot; or \\&quot;Pragma: no-cache\\&quot;&quot;); if (!no_store) &#123; /* register a ctx to give a chance to srcache_store to run */ ctx = ngx_pcalloc(r-&gt;pool, sizeof(ngx_http_srcache_filter_module)); if (ctx == NULL) &#123; return NGX_ERROR; &#125; ngx_http_set_ctx(r, ctx, ngx_http_srcache_filter_module); &#125; else &#123; ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, &quot;srcache_store skipped due to request header &quot; &quot;\\&quot;Cache-Control: no-store\\&quot;&quot;); &#125; return NGX_DECLINED; &#125; // 配置了 fetch_skip 指令，并且满足，跳过 cache lookup if (conf-&gt;fetch_skip != NULL &amp;&amp; ngx_http_complex_value(r, conf-&gt;fetch_skip, &amp;skip) == NGX_OK &amp;&amp; skip.len &amp;&amp; (skip.len != 1 || skip.data[0] != &#x27;0&#x27;)) &#123; ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, &quot;srcache_fetch skipped due to the true value fed into &quot; &quot;srcache_fetch_skip: \\&quot;%V\\&quot;&quot;, &amp;skip); /* register a ctx to give a chance to srcache_store to run */ ctx = ngx_pcalloc(r-&gt;pool, sizeof(ngx_http_srcache_filter_module)); if (ctx == NULL) &#123; return NGX_ERROR; &#125; ngx_http_set_ctx(r, ctx, ngx_http_srcache_filter_module); return NGX_DECLINED; &#125; // 模块上下文 ctx = ngx_http_get_module_ctx(r, ngx_http_srcache_filter_module); if (ctx != NULL) &#123; /* if (ctx-&gt;fetch_error) &#123; return NGX_DECLINED; &#125; */ if (ctx-&gt;waiting_subrequest) &#123; dd(&quot;waiting subrequest&quot;); return NGX_AGAIN; &#125; if (ctx-&gt;waiting_request_body) &#123; return NGX_AGAIN; &#125; // 使用 subrequest 进行 cache lookup if (ctx-&gt;request_body_done == 1) &#123; ctx-&gt;request_body_done = 0; goto do_fetch_subrequest; &#125; // 读取子请求应答 if (ctx-&gt;request_done) &#123; dd(&quot;request done&quot;); if (ngx_http_post_request(r, NULL) != NGX_OK) &#123; return NGX_ERROR; &#125; if (!ctx-&gt;from_cache) &#123; return NGX_DECLINED; &#125; dd(&quot;sending header&quot;); // cache hit // send out cached data if (ctx-&gt;body_from_cache) &#123; len = 0; for (cl = ctx-&gt;body_from_cache; cl-&gt;next; cl = cl-&gt;next) &#123; len += ngx_buf_size(cl-&gt;buf); &#125; len += ngx_buf_size(cl-&gt;buf); cl-&gt;buf-&gt;last_buf = 1; r-&gt;headers_out.content_length_n = len; rc = ngx_http_send_header(r); dd(&quot;srcache fetch header returned %d&quot;, (int) rc); if (rc == NGX_ERROR || rc &gt; NGX_OK) &#123; return rc; &#125;#if 1 if (r-&gt;header_only) &#123; return NGX_HTTP_OK; &#125;#endif if (!r-&gt;filter_finalize) &#123; rc = ngx_http_output_filter(r, ctx-&gt;body_from_cache); if (rc == NGX_ERROR || rc &gt; NGX_OK) &#123; return rc; &#125; &#125; dd(&quot;sent body from cache: %d&quot;, (int) rc); dd(&quot;finalize from here...&quot;); ngx_http_finalize_request(r, rc); /* dd(&quot;r-&gt;main-&gt;count (post): %d&quot;, (int) r-&gt;main-&gt;count); */ return NGX_DONE; &#125; // cache miss return NGX_DECLINED; &#125; &#125; else &#123; ctx = ngx_pcalloc(r-&gt;pool, sizeof(ngx_http_srcache_filter_module)); if (ctx == NULL) &#123; return NGX_ERROR; &#125; ngx_http_set_ctx(r, ctx, ngx_http_srcache_filter_module); &#125; smcf = ngx_http_get_module_main_conf(r, ngx_http_srcache_filter_module); if (!smcf-&gt;postponed_to_access_phase_end) &#123; ngx_http_core_main_conf_t *cmcf; ngx_http_phase_handler_t tmp; ngx_http_phase_handler_t *ph; ngx_http_phase_handler_t *cur_ph; ngx_http_phase_handler_t *last_ph; smcf-&gt;postponed_to_access_phase_end = 1; cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module); ph = cmcf-&gt;phase_engine.handlers; cur_ph = &amp;ph[r-&gt;phase_handler]; /* we should skip the post_access phase handler here too */ last_ph = &amp;ph[cur_ph-&gt;next - 2]; if (cur_ph &lt; last_ph) &#123; dd(&quot;swaping the contents of cur_ph and last_ph...&quot;); tmp = *cur_ph; memmove(cur_ph, cur_ph + 1, (last_ph - cur_ph) * sizeof (ngx_http_phase_handler_t)); *last_ph = tmp; r-&gt;phase_handler--; /* redo the current ph */ return NGX_DECLINED; &#125; &#125; // 未定义 fetch 操作，跳过 cache lookup if (conf-&gt;fetch == NULL) &#123; dd(&quot;fetch is not defined&quot;); return NGX_DECLINED; &#125; dd(&quot;running phase handler...&quot;); // 读入请求包体 if (!r-&gt;request_body) &#123; dd(&quot;reading request body: ctx = %p&quot;, ctx); rc = ngx_http_read_client_request_body(r, ngx_http_srcache_post_read_body); if (rc == NGX_ERROR || rc &gt; NGX_OK) &#123;#if (nginx_version &lt; 1002006) \\ || (nginx_version &gt;= 1003000 &amp;&amp; nginx_version &lt; 1003009) r-&gt;main-&gt;count--;#endif return rc; &#125; // 设置等待读入请求包体标记 if (rc == NGX_AGAIN) &#123; ctx-&gt;waiting_request_body = 1; return NGX_AGAIN; &#125; /* rc == NGX_OK */ &#125;do_fetch_subrequest: /* issue a subrequest to fetch cached stuff (if any) */ // 发起缓存查询子请求 rc = ngx_http_srcache_fetch_subrequest(r, conf, ctx); if (rc != NGX_OK) &#123; return rc; &#125; ctx-&gt;waiting_subrequest = 1; dd(&quot;quit&quot;); return NGX_AGAIN;&#125; 3. 读缓存下半部与设置缓存123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250static ngx_int_tngx_http_srcache_body_filter(ngx_http_request_t *r, ngx_chain_t *in)&#123; ngx_http_srcache_ctx_t *ctx, *pr_ctx; ngx_int_t rc; ngx_str_t skip; ngx_chain_t *cl; ngx_http_srcache_loc_conf_t *slcf; size_t len; unsigned last; dd_enter(); if (in == NULL) &#123; return ngx_http_srcache_next_body_filter(r, NULL); &#125; ctx = ngx_http_get_module_ctx(r, ngx_http_srcache_filter_module); if (ctx == NULL || ctx-&gt;from_cache || ctx-&gt;store_skip) &#123; dd(&quot;bypass: %.*s&quot;, (int) r-&gt;uri.len, r-&gt;uri.data); return ngx_http_srcache_next_body_filter(r, in); &#125; if (ctx-&gt;ignore_body || ctx-&gt;in_store_subrequest/* || ctx-&gt;fetch_error */) &#123; dd(&quot;ignore body: ignore body %d, in store sr %d&quot;, (int) ctx-&gt;ignore_body, (int) ctx-&gt;in_store_subrequest); ngx_http_srcache_discard_bufs(r-&gt;pool, in); return NGX_OK; &#125; // 缓存读取操作 // body_filter 处理 if (ctx-&gt;in_fetch_subrequest) &#123; // header 处理 if (ctx-&gt;parsing_cached_headers) &#123; /* parse the cached response&#x27;s headers and * set r-&gt;parent-&gt;headers_out */ if (ctx-&gt;process_header == NULL) &#123; dd(&quot;restore parent request header&quot;); ctx-&gt;process_header = ngx_http_srcache_process_status_line; r-&gt;state = 0; /* sw_start */ &#125; for (cl = in; cl; cl = cl-&gt;next) &#123; if (ngx_buf_in_memory(cl-&gt;buf)) &#123; dd(&quot;old pos %p, last %p&quot;, cl-&gt;buf-&gt;pos, cl-&gt;buf-&gt;last); rc = ctx-&gt;process_header(r, cl-&gt;buf); if (rc == NGX_AGAIN) &#123; dd(&quot;AGAIN/OK: new pos %p, last %p&quot;, cl-&gt;buf-&gt;pos, cl-&gt;buf-&gt;last); continue; &#125; // 处理 header 出错，忽略包体处理，设置缓存未空 if (rc == NGX_ERROR) &#123; r-&gt;state = 0; /* sw_start */ ctx-&gt;parsing_cached_headers = 0; ctx-&gt;ignore_body = 1; ngx_http_srcache_discard_bufs(r-&gt;pool, cl); pr_ctx = ngx_http_get_module_ctx(r-&gt;parent, ngx_http_srcache_filter_module); if (pr_ctx == NULL) &#123; return NGX_ERROR; &#125; pr_ctx-&gt;from_cache = 0; return NGX_OK; &#125; /* rc == NGX_OK */ dd(&quot;OK: new pos %p, last %p&quot;, cl-&gt;buf-&gt;pos, cl-&gt;buf-&gt;last); dd(&quot;buf left: %.*s&quot;, (int) (cl-&gt;buf-&gt;last - cl-&gt;buf-&gt;pos), cl-&gt;buf-&gt;pos); ctx-&gt;parsing_cached_headers = 0; break; &#125; &#125; if (cl == NULL) &#123; return NGX_OK; &#125; if (cl-&gt;buf-&gt;pos == cl-&gt;buf-&gt;last) &#123; cl = cl-&gt;next; &#125; if (cl == NULL) &#123; return NGX_OK; &#125; // header 处理结束，更新 in 指向 body in = cl; &#125; dd(&quot;save the cached response body for parent&quot;); pr_ctx = ngx_http_get_module_ctx(r-&gt;parent, ngx_http_srcache_filter_module); if (pr_ctx == NULL) &#123; return NGX_ERROR; &#125; // 将 body 拷贝到 body_from_cache rc = ngx_http_srcache_add_copy_chain(r-&gt;pool, &amp;pr_ctx-&gt;body_from_cache, in, &amp;last); if (rc != NGX_OK) &#123; return NGX_ERROR; &#125; if (last) &#123; ctx-&gt;seen_subreq_eof = 1; &#125; // 删除 in ngx_http_srcache_discard_bufs(r-&gt;pool, in); return NGX_OK; &#125; // 缓存存储操作 if (ctx-&gt;store_response) &#123; dd(&quot;storing the response: %p&quot;, in); slcf = ngx_http_get_module_loc_conf(r, ngx_http_srcache_filter_module); if (r-&gt;headers_out.status == NGX_HTTP_PARTIAL_CONTENT &amp;&amp; ctx-&gt;http_status == NGX_HTTP_OK) &#123; u_char *p; if (!slcf-&gt;store_ranges) &#123; ctx-&gt;store_response = 0; goto done; &#125; dd(&quot;fix 206 status code&quot;); /* handle 206 Partial Content generated by the range filter */ cl = ctx-&gt;body_to_cache; assert(cl &amp;&amp; cl-&gt;buf &amp;&amp; cl-&gt;buf-&gt;last - cl-&gt;buf-&gt;pos &gt; 12); p = cl-&gt;buf-&gt;pos + sizeof(&quot;HTTP/1.x 20&quot;) - 1; *p = &#x27;6&#x27;; ctx-&gt;http_status = NGX_HTTP_PARTIAL_CONTENT; &#125; for (cl = in; cl; cl = cl-&gt;next) &#123; if (ngx_buf_in_memory(cl-&gt;buf)) &#123; len = ngx_buf_size(cl-&gt;buf); ctx-&gt;response_length += len; ctx-&gt;response_body_length += len; &#125; &#125; if (slcf-&gt;store_max_size != 0 &amp;&amp; ctx-&gt;response_length &gt; slcf-&gt;store_max_size) &#123; ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, &quot;srcache_store bypassed because response body &quot; &quot;exceeded maximum size: %z (limit is: %z)&quot;, ctx-&gt;response_length, slcf-&gt;store_max_size); ctx-&gt;store_response = 0; goto done; &#125; rc = ngx_http_srcache_add_copy_chain(r-&gt;pool, &amp;ctx-&gt;body_to_cache, in, &amp;last); if (rc != NGX_OK) &#123; ctx-&gt;store_response = 0; goto done; &#125; if (last &amp;&amp; r == r-&gt;main) &#123;#if 1 if (r-&gt;headers_out.content_length_n &gt; (off_t) ctx-&gt;response_body_length) &#123; ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0, &quot;srcache_store: skipped because response body &quot; &quot;truncated: %O &gt; %uz&quot;, r-&gt;headers_out.content_length_n, ctx-&gt;response_body_length); ctx-&gt;store_response = 0; goto done; &#125; if (r-&gt;headers_out.status &gt;= NGX_HTTP_SPECIAL_RESPONSE &amp;&amp; r-&gt;headers_out.status != ctx-&gt;http_status) &#123; /* data truncation or body receive timeout */ ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0, &quot;srcache_store: skipped due to new error status &quot; &quot;code %ui (old: %ui)&quot;, r-&gt;headers_out.status, ctx-&gt;http_status); ctx-&gt;store_response = 0; goto done; &#125;#endif if (slcf-&gt;store_skip != NULL &amp;&amp; ngx_http_complex_value(r, slcf-&gt;store_skip, &amp;skip) == NGX_OK &amp;&amp; skip.len &amp;&amp; (skip.len != 1 || skip.data[0] != &#x27;0&#x27;)) &#123; ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, &quot;srcache_store skipped due to the true value in &quot; &quot;srcache_store_skip: \\&quot;%V\\&quot;&quot;, &amp;skip); ctx-&gt;store_response = 0; goto done; &#125; rc = ngx_http_srcache_store_subrequest(r, ctx); if (rc != NGX_OK) &#123; ctx-&gt;store_response = 0; goto done; &#125; &#125; &#125; else &#123; dd(&quot;NO store response&quot;); &#125;done: return ngx_http_srcache_next_body_filter(r, in);&#125;","categories":[{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/categories/NGINX/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/tags/NGINX/"}]},{"title":"ngx_http_rewrite_module","slug":"nginx-2019-10-03-ngx-http-rewrite-module","date":"2022-09-03T12:55:44.515Z","updated":"2022-09-03T12:55:44.515Z","comments":true,"path":"2022/09/03/nginx-2019-10-03-ngx-http-rewrite-module/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/nginx-2019-10-03-ngx-http-rewrite-module/","excerpt":"","text":"一 概述ngx_http_rewrite_module 的主要作用有三个：改写请求的 uri、给客户端返回重定向（301 或 302）应答、按条件更新请求使用的配置（uri 重新匹配后会进行 update_config 操作）。模块提供的 break、if、return、rewrite、set 指令会按在配置文件中出现的顺序，或者说是解析配置文件时指令出现的顺序保存在 ngx_http_rewrite_module 模块的指令动态数组中。当请求到来时，会依次处理指令。 二 指令1. rewrite123Syntax: rewrite regex replacement [flag];Default: —Context: server, location, if 如果正则表达式与请求 URI 匹配，则将 URI 按 replacement 指定进行替换。如果 replacement 以 http://、https://、$scheme 开头，会进行重定向应答（与 redirect 标记行为一致）。可选的 flag 标记可以控制指令的处理，可取值：last,break,redirect,permanent。 last 停止处理当前的 ngx_http_rewrite_module 指令，使用重写后的 URI 重新开始进行 location 查找。内部重定向，客户端无感知。 break 与 break 指令相同，停止处理当前 ngx_http_rewrite_module 模块的指令，不会触发 location 查找。客户端无感知。 redirect 给客户端 302 临时重定向应答。 permanent 给客户端 301 永久重定向应答。 如果 replacement 替换字符串中包含新的请求参数，原始请求参数会拼接在新请求参数后。如果不希望添加原始请求参数，在参数最后添加 “?” 即可，示例： 1rewrite ^/users/(.*)$ /show?user=$1? last; 2. break123Syntax: break;Default: —Context: server, location, if 停止 ngx_http_rewrite_module 模块的指令处理。 3. if123Syntax: if (condition) &#123; ... &#125;Default: —Context: server, location 判断 condition 是否为 true，如果为 true 会执行括号内的 rewrite 模块指令，同时使用括号内的配置作为当前请求配置。可选条件为：变量、变量与字符串比较、变量与正则表达式匹配、判断文件是否存在、判断目录是否存在、判断文件/目录/符号链接是否存在、判断文件是否可执行。 4. return12345Syntax: return code [text]; return code URL; return URL;Default: —Context: server, location, if 停止处理并将指定的状态码返回给客户端。 使用非标准的 444 状态码会关闭连接而不发送响应头。使用 URL 或 text 可以指定重定向 URL（对于代码 301、302、303、307 和 308 ）或响应正文（对于其他代码）。 响应正文文本和重定向 URL 可以包含变量。 5. rewrite_log123Syntax: rewrite_log on | off;Default: rewrite_log off;Context: http, server, location, if 是否使用 notice 级别在 error_log 日志记录 ngx_http_rewrite_module 模块的指令处理结果。 6. set123Syntax: set $variable value;Default: —Context: server, location, if 给变量指定值。 7. uninitialized_variable_warn123Syntax: uninitialized_variable_warn on | off;Default: uninitialized_variable_warn on;Context: http, server, location, if 控制是否记录未初始化变量的警告日志。","categories":[{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/categories/NGINX/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/tags/NGINX/"}]},{"title":"ngx_http_core_module - error_page","slug":"nginx-2019-10-02-ngx-http-core-module-error-page","date":"2022-09-03T12:55:44.514Z","updated":"2022-09-03T12:55:44.514Z","comments":true,"path":"2022/09/03/nginx-2019-10-02-ngx-http-core-module-error-page/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/nginx-2019-10-02-ngx-http-core-module-error-page/","excerpt":"","text":"一 概述error_page 指令用来控制特定错误码出现时的应答显示，由 ngx_http_core_module 模块实现。 二 指令1. error_page123Syntax: error_page code ... [=[response]] uri;Default: —Context: http, server, location, if in location 定义为特定状态码显示的 URI，URI 可以包含变量。注意：状态码取值范围是：[300, 599]。示例： 12error_page 404 /404.html;error_page 500 502 503 504 /50x.html; 如果应答状态码为 404、500、502、503、504 会内部跳转到 uri: /404.html、/50x.html，同时请求方法会修改为 GET。可以使用 =response 指定应答状态码，示例（使用 /404.php 的状态码作为应答状态码）： 1error_page 404 = /404.php; 也可以使用 301、302、303、307、308 重定向跳转（默认状态码是 302），示例： 12error_page 403 http://example.com/forbidden.html;error_page 404 =301 http://example.com/notfound.html; 2. no_error_pages123Syntax: no_error_page;Default: —Context: http, server, location, if in location 关闭 error_page 功能，与 error_page 指令不能共存。 三 实现error_page 指令在 ngx_http_core_module 中实现，会在 ngx_http_core_loc_conf_t::error_pages 动态数组中添加 error_page 元素（每个状态码对应一个动态数组元素）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129static char *ngx_http_core_error_page(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; ngx_http_core_loc_conf_t *clcf = conf; u_char *p; ngx_int_t overwrite; ngx_str_t *value, uri, args; ngx_uint_t i, n; ngx_http_err_page_t *err; ngx_http_complex_value_t cv; ngx_http_compile_complex_value_t ccv; // 已经配置了 no_error_pages 指令 if (clcf-&gt;error_pages == NULL) &#123; return &quot;conflicts with \\&quot;no_error_pages\\&quot;&quot;; &#125; if (clcf-&gt;error_pages == NGX_CONF_UNSET_PTR) &#123; clcf-&gt;error_pages = ngx_array_create(cf-&gt;pool, 4, sizeof(ngx_http_err_page_t)); if (clcf-&gt;error_pages == NULL) &#123; return NGX_CONF_ERROR; &#125; &#125; value = cf-&gt;args-&gt;elts; // 应答状态码取 i = cf-&gt;args-&gt;nelts - 2; if (value[i].data[0] == &#x27;=&#x27;) &#123; if (i == 1) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;invalid value \\&quot;%V\\&quot;&quot;, &amp;value[i]); return NGX_CONF_ERROR; &#125; if (value[i].len &gt; 1) &#123; overwrite = ngx_atoi(&amp;value[i].data[1], value[i].len - 1); if (overwrite == NGX_ERROR) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;invalid value \\&quot;%V\\&quot;&quot;, &amp;value[i]); return NGX_CONF_ERROR; &#125; &#125; else &#123; overwrite = 0; &#125; n = 2; &#125; else &#123; overwrite = -1; n = 1; &#125; // 跳转 uri uri = value[cf-&gt;args-&gt;nelts - 1]; ngx_memzero(&amp;ccv, sizeof(ngx_http_compile_complex_value_t)); ccv.cf = cf; ccv.value = &amp;uri; ccv.complex_value = &amp;cv; if (ngx_http_compile_complex_value(&amp;ccv) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; ngx_str_null(&amp;args); if (cv.lengths == NULL &amp;&amp; uri.len &amp;&amp; uri.data[0] == &#x27;/&#x27;) &#123; p = (u_char *) ngx_strchr(uri.data, &#x27;?&#x27;); if (p) &#123; cv.value.len = p - uri.data; cv.value.data = uri.data; p++; args.len = (uri.data + uri.len) - p; args.data = p; &#125; &#125; // 为每个错误状态码创建 error_page 配置 for (i = 1; i &lt; cf-&gt;args-&gt;nelts - n; i++) &#123; err = ngx_array_push(clcf-&gt;error_pages); if (err == NULL) &#123; return NGX_CONF_ERROR; &#125; // 错误码数值 err-&gt;status = ngx_atoi(value[i].data, value[i].len); if (err-&gt;status == NGX_ERROR || err-&gt;status == 499) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;invalid value \\&quot;%V\\&quot;&quot;, &amp;value[i]); return NGX_CONF_ERROR; &#125; // 错误码有效范围 if (err-&gt;status &lt; 300 || err-&gt;status &gt; 599) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;value \\&quot;%V\\&quot; must be between 300 and 599&quot;, &amp;value[i]); return NGX_CONF_ERROR; &#125; // 应答状态码 err-&gt;overwrite = overwrite; if (overwrite == -1) &#123; switch (err-&gt;status) &#123; case NGX_HTTP_TO_HTTPS: case NGX_HTTPS_CERT_ERROR: case NGX_HTTPS_NO_CERT: err-&gt;overwrite = NGX_HTTP_BAD_REQUEST; default: break; &#125; &#125; err-&gt;value = cv; err-&gt;args = args; &#125; return NGX_CONF_OK;&#125; 在 ngx_http_finalize_request 函数处理中会根据 location 配置，使用 error_page 进行应答处理。","categories":[{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/categories/NGINX/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/tags/NGINX/"}]},{"title":"ngx_http_core_module - limit_except","slug":"nginx-2019-10-02-ngx-http-core-module-limit-except","date":"2022-09-03T12:55:44.514Z","updated":"2022-09-03T12:55:44.515Z","comments":true,"path":"2022/09/03/nginx-2019-10-02-ngx-http-core-module-limit-except/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/nginx-2019-10-02-ngx-http-core-module-limit-except/","excerpt":"","text":"一 概述limit_except 限制一个 location 内允许的 HTTP 方法。 二 指令123Syntax: limit_except method ... &#123; ... &#125;Default: —Context: location 可选的 method ：GET, HEAD, POST, PUT, DELETE, MKCOL, COPY, MOVE, OPTIONS, PROPFIND, PROPPATCH, LOCK, UNLOCK, PATCH。示例： 1234limit_except GET &#123; allow 192.168.1.0/32; deny all;&#125; 配置含义是允许所有的 GET（HEAD） 请求，其他类型的请求如果来源非 192.168.1.0/32 则禁止访问。 如果使用 POST 方式进行请求会返回： 1403 Forbidden 三 实现其实 limit_except 指令主要是根据方法使用不同的 loc_conf 配置项。ngx_http_update_location_config 会根据请求方法判断是否需要更新请求的 loc_conf。当时有 limit_except 配置的 loc_conf 后，在 ngx_http_access_module 模块会对请求客户端地址进行判断。 指令处理： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103static char *ngx_http_core_limit_except(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; ngx_http_core_loc_conf_t *pclcf = conf; char *rv; void *mconf; ngx_str_t *value; ngx_uint_t i; ngx_conf_t save; ngx_http_module_t *module; ngx_http_conf_ctx_t *ctx, *pctx; ngx_http_method_name_t *name; ngx_http_core_loc_conf_t *clcf; if (pclcf-&gt;limit_except) &#123; return &quot;duplicate&quot;; &#125; pclcf-&gt;limit_except = 0xffffffff; value = cf-&gt;args-&gt;elts; for (i = 1; i &lt; cf-&gt;args-&gt;nelts; i++) &#123; for (name = ngx_methods_names; name-&gt;name; name++) &#123; if (ngx_strcasecmp(value[i].data, name-&gt;name) == 0) &#123; pclcf-&gt;limit_except &amp;= name-&gt;method; goto next; &#125; &#125; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;invalid method \\&quot;%V\\&quot;&quot;, &amp;value[i]); return NGX_CONF_ERROR; next: continue; &#125; if (!(pclcf-&gt;limit_except &amp; NGX_HTTP_GET)) &#123; pclcf-&gt;limit_except &amp;= (uint32_t) ~NGX_HTTP_HEAD; &#125; ctx = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_http_conf_ctx_t)); if (ctx == NULL) &#123; return NGX_CONF_ERROR; &#125; pctx = cf-&gt;ctx; ctx-&gt;main_conf = pctx-&gt;main_conf; ctx-&gt;srv_conf = pctx-&gt;srv_conf; // 创建新的 loc_conf 配置 ctx-&gt;loc_conf = ngx_pcalloc(cf-&gt;pool, sizeof(void *) * ngx_http_max_module); if (ctx-&gt;loc_conf == NULL) &#123; return NGX_CONF_ERROR; &#125; for (i = 0; cf-&gt;cycle-&gt;modules[i]; i++) &#123; if (cf-&gt;cycle-&gt;modules[i]-&gt;type != NGX_HTTP_MODULE) &#123; continue; &#125; module = cf-&gt;cycle-&gt;modules[i]-&gt;ctx; if (module-&gt;create_loc_conf) &#123; mconf = module-&gt;create_loc_conf(cf); if (mconf == NULL) &#123; return NGX_CONF_ERROR; &#125; ctx-&gt;loc_conf[cf-&gt;cycle-&gt;modules[i]-&gt;ctx_index] = mconf; &#125; &#125; clcf = ctx-&gt;loc_conf[ngx_http_core_module.ctx_index]; pclcf-&gt;limit_except_loc_conf = ctx-&gt;loc_conf; clcf-&gt;loc_conf = ctx-&gt;loc_conf; clcf-&gt;name = pclcf-&gt;name; clcf-&gt;noname = 1; clcf-&gt;lmt_excpt = 1; if (ngx_http_add_location(cf, &amp;pclcf-&gt;locations, clcf) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; // 使用新的 loc_conf 进行解析,解析 deny、allow 指令。 // 其实 limit_except 指令主要是根据方法使用不同的 loc_conf 配置项。 // ngx_http_update_location_config 会根据请求方法判断是否需要更新请求的 loc_conf save = *cf; cf-&gt;ctx = ctx; cf-&gt;cmd_type = NGX_HTTP_LMT_CONF; // 对 limit_except &#123;&#125; 进行指令处理 // 只有 allow、deny 可以在 LMT_CONF 中配置 rv = ngx_conf_parse(cf, NULL); *cf = save; return rv;&#125; 在请求处理过程中更新请求配置： 123456789101112131415voidngx_http_update_location_config(ngx_http_request_t *r)&#123; ngx_http_core_loc_conf_t *clcf; clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module); // 更新配置 if (r-&gt;method &amp; clcf-&gt;limit_except) &#123; r-&gt;loc_conf = clcf-&gt;limit_except_loc_conf; clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module); &#125; // ... 省略其他代码&#125; allow、deny 指令定义： 1234567891011121314151617181920static ngx_command_t ngx_http_access_commands[] = &#123; // 可以出来 NGX_HTTP_LMT_CONF 块内配置 &#123; ngx_string(&quot;allow&quot;), NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_HTTP_LMT_CONF |NGX_CONF_TAKE1, ngx_http_access_rule, NGX_HTTP_LOC_CONF_OFFSET, 0, NULL &#125;, &#123; ngx_string(&quot;deny&quot;), NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_HTTP_LMT_CONF |NGX_CONF_TAKE1, ngx_http_access_rule, NGX_HTTP_LOC_CONF_OFFSET, 0, NULL &#125;, ngx_null_command&#125;;","categories":[{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/categories/NGINX/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/tags/NGINX/"}]},{"title":"OpenResty Api - socket tcp","slug":"nginx-2019-09-15-openresty-api-socket-tcp","date":"2022-09-03T12:55:44.513Z","updated":"2022-09-03T12:55:44.513Z","comments":true,"path":"2022/09/03/nginx-2019-09-15-openresty-api-socket-tcp/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/nginx-2019-09-15-openresty-api-socket-tcp/","excerpt":"","text":"一 概述cosocket 提供了非阻塞的通讯方式，cosocket 分为两类，第一类是与下游通讯的 cosocket,第二类是在 OpenResty 内主动创建的 cosocket。第一类是基于原始请求的连接建立，由 ngx.req.socket 函数创建。对于第二类 cosocket 分为 TCP 与 UDP 两类，分别由 ngx.socket.tcp,ngx.socket.stream 和 ngx.socket.udp 创建。 二 downstream socket1. 指令123syntax: tcpsock, err = ngx.req.socket()syntax: tcpsock, err = ngx.req.socket(raw)context: rewrite_by_lua*, access_by_lua*, content_by_lua* 返回只读的 downstream 方向连接的 cosocket 对象，只支持 receive, receiveuntil 方法。此方法通常用于以流式读取当前请求的包体，不应该与 lua_need_request_body 指令或 ngx.req.read_body,ngx.req.discard_body 混用。当使用 true 参数调用函数时返回的 tcpsock 是全双工的 cosocket，除了 receive, receiveuntil 方法外还可以调用 send 方法向下游发送应答。注意，当调用 ngx.req.socket(true) 时缓冲区中不能存在之前由于调用 ngx.say, ngx.print, ngx.send_headers 发送的数据。正确的方式是，先调用 ngx.flush(ture) 将缓冲区中数据写出然后再调用 ngx.req.socket(true)，以保证缓冲区中无待发送数据。 2. 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250// 注册 ngx.req.socketvoidngx_http_lua_inject_req_socket_api(lua_State *L)&#123; lua_pushcfunction(L, ngx_http_lua_req_socket); lua_setfield(L, -2, &quot;socket&quot;);&#125;// 创建一个 downstream socketstatic intngx_http_lua_req_socket(lua_State *L)&#123; // 省略变量定义，参数判断 r = ngx_http_lua_get_req(L); if (r != r-&gt;main) &#123; return luaL_error(L, &quot;attempt to read the request body in a &quot; &quot;subrequest&quot;); &#125; // 不支持 SPDY, HTTP2 协议#if (NGX_HTTP_SPDY) if (r-&gt;spdy_stream) &#123; return luaL_error(L, &quot;spdy not supported yet&quot;); &#125;#endif#if (NGX_HTTP_V2) if (r-&gt;stream) &#123; return luaL_error(L, &quot;http v2 not supported yet&quot;); &#125;#endif // 不支持 CHUNKED 传输编码#if nginx_version &gt;= 1003009 if (!raw &amp;&amp; r-&gt;headers_in.chunked) &#123; lua_pushnil(L); lua_pushliteral(L, &quot;chunked request bodies not supported yet&quot;); return 2; &#125;#endif ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module); if (ctx == NULL) &#123; return luaL_error(L, &quot;no ctx found&quot;); &#125; // 阶段判断 ngx_http_lua_check_context(L, ctx, NGX_HTTP_LUA_CONTEXT_REWRITE | NGX_HTTP_LUA_CONTEXT_ACCESS | NGX_HTTP_LUA_CONTEXT_CONTENT); // downstream socket 基于原始请求的 connection c = r-&gt;connection; if (raw) &#123;#if !defined(nginx_version) || nginx_version &lt; 1003013 lua_pushnil(L); lua_pushliteral(L, &quot;nginx version too old&quot;); return 2;#else // 判断是否已经读入请求包体 if (r-&gt;request_body) &#123; if (r-&gt;request_body-&gt;rest &gt; 0) &#123; lua_pushnil(L); lua_pushliteral(L, &quot;pending request body reading in some &quot; &quot;other thread&quot;); return 2; &#125; &#125; else &#123; rb = ngx_pcalloc(r-&gt;pool, sizeof(ngx_http_request_body_t)); if (rb == NULL) &#123; return luaL_error(L, &quot;no memory&quot;); &#125; r-&gt;request_body = rb; &#125; if (c-&gt;buffered &amp; NGX_HTTP_LOWLEVEL_BUFFERED) &#123; lua_pushnil(L); lua_pushliteral(L, &quot;pending data to write&quot;); return 2; &#125; if (ctx-&gt;buffering) &#123; lua_pushnil(L); lua_pushliteral(L, &quot;http 1.0 buffering&quot;); return 2; &#125; if (!r-&gt;header_sent) &#123; /* prevent other parts of nginx from sending out * the response header */ r-&gt;header_sent = 1; &#125; ctx-&gt;header_sent = 1; dd(&quot;ctx acquired raw req socket: %d&quot;, ctx-&gt;acquired_raw_req_socket); if (ctx-&gt;acquired_raw_req_socket) &#123; lua_pushnil(L); lua_pushliteral(L, &quot;duplicate call&quot;); return 2; &#125; ctx-&gt;acquired_raw_req_socket = 1; r-&gt;keepalive = 0; r-&gt;lingering_close = 1;#endif &#125; else &#123; /* request body reader */ // 已经读入请求包体 if (r-&gt;request_body) &#123; lua_pushnil(L); lua_pushliteral(L, &quot;request body already exists&quot;); return 2; &#125; // 已经设置丢弃请求包体 if (r-&gt;discard_body) &#123; lua_pushnil(L); lua_pushliteral(L, &quot;request body discarded&quot;); return 2; &#125; dd(&quot;req content length: %d&quot;, (int) r-&gt;headers_in.content_length_n); // 无请求包体 if (r-&gt;headers_in.content_length_n &lt;= 0) &#123; lua_pushnil(L); lua_pushliteral(L, &quot;no body&quot;); return 2; &#125; // 判断是否是有 expect 100 请求头，并进行应答，允许客户端继续发送包体 // 与主逻辑无关 if (ngx_http_lua_test_expect(r) != NGX_OK) &#123; lua_pushnil(L); lua_pushliteral(L, &quot;test expect failed&quot;); return 2; &#125; /* prevent other request body reader from running */ rb = ngx_pcalloc(r-&gt;pool, sizeof(ngx_http_request_body_t)); if (rb == NULL) &#123; return luaL_error(L, &quot;no memory&quot;); &#125; rb-&gt;rest = r-&gt;headers_in.content_length_n; r-&gt;request_body = rb; &#125; // 创建 req_socket 表 lua_createtable(L, 3 /* narr */, 1 /* nrec */); /* the object */ // 根据是否为 raw 设置不同的 _index 元表 if (raw) &#123; lua_pushlightuserdata(L, &amp;ngx_http_lua_raw_req_socket_metatable_key); &#125; else &#123; lua_pushlightuserdata(L, &amp;ngx_http_lua_req_socket_metatable_key); &#125; // 设置 table 元表为 ngx_http_lua_raw_req_socket_metatable_key|ngx_http_lua_req_socket_metatable_key 伪索引指定的表 lua_rawget(L, LUA_REGISTRYINDEX); lua_setmetatable(L, -2); // 创建新的 socket 对象 u = lua_newuserdata(L, sizeof(ngx_http_lua_socket_tcp_upstream_t)); if (u == NULL) &#123; return luaL_error(L, &quot;no memory&quot;); &#125;#if 1 // 设置 socket 的元表为伪索引中由 ngx_http_lua_downstream_udata_metatable_key 指定的表 lua_pushlightuserdata(L, &amp;ngx_http_lua_downstream_udata_metatable_key); lua_rawget(L, LUA_REGISTRYINDEX); lua_setmetatable(L, -2);#endif // 将 socket 保存到 req_socket 表 // req_socket[SOCKET_CTX_INDEX] = u lua_rawseti(L, 1, SOCKET_CTX_INDEX); ngx_memzero(u, sizeof(ngx_http_lua_socket_tcp_upstream_t)); if (raw) &#123; u-&gt;raw_downstream = 1; &#125; else &#123; u-&gt;body_downstream = 1; &#125; coctx = ctx-&gt;cur_co_ctx; u-&gt;request = r; llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module); u-&gt;conf = llcf; // 使用 location 默认的读、连接、写超时时间 u-&gt;read_timeout = u-&gt;conf-&gt;read_timeout; u-&gt;connect_timeout = u-&gt;conf-&gt;connect_timeout; u-&gt;send_timeout = u-&gt;conf-&gt;send_timeout; cln = ngx_http_lua_cleanup_add(r, 0); if (cln == NULL) &#123; u-&gt;ft_type |= NGX_HTTP_LUA_SOCKET_FT_ERROR; lua_pushnil(L); lua_pushliteral(L, &quot;no memory&quot;); return 2; &#125; // 清理函数 // downstream 不会关闭连接；非 downstream 会将其进行关闭 cln-&gt;handler = ngx_http_lua_socket_tcp_cleanup; cln-&gt;data = u; u-&gt;cleanup = &amp;cln-&gt;handler; pc = &amp;u-&gt;peer; pc-&gt;log = c-&gt;log; pc-&gt;log_error = NGX_ERROR_ERR; // c 是原始连接 r-&gt;connection; pc-&gt;connection = c; dd(&quot;setting data to %p&quot;, u); coctx-&gt;data = u; ctx-&gt;downstream = u; // 删除原先的读超时定时器 if (c-&gt;read-&gt;timer_set) &#123; ngx_del_timer(c-&gt;read); &#125; if (raw) &#123; // 删除原先的写超时定时器 if (c-&gt;write-&gt;timer_set) &#123; ngx_del_timer(c-&gt;write); &#125; &#125; // 返回 req_socket 表 lua_settop(L, 1); return 1;&#125; 三 TCP1. 指令123syntax: tcpsock = ngx.socket.tcp()syntax: tcpsock = ngx.socket.stream()context: rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua* 创建并返回一个 TCP 或流式 UNINX 域 socket 对象，支持：connect, sslhandshake, send, receive, close, settimeout, settimeouts, setoption, receiveany, receiveuntil, setkeepalive, getreusedtimes 方法，这些方法都是非阻塞的。tcpsock 与创建它的 lua-handler 有相同生命周期，为避免 panic 不能将 tcpsock 传递给其他 lua-handler (包括 ngx.timer)，当然也不能共享给其他请求。对于每个 cosocket 对象底层的连接，如果没有显示调用 close 进行关闭，或者使用 setkeepalive 放入连接池，那么当当前请求结束或者 cosocket 被 gc 时会关闭连接。当操作 cosocket 对象出现致命错误（读超时不被当做致命错误）时会关闭 cosocket，如果再次调用 close 进行关闭会返回 “closed” 错误信息。 2. 实现向 ngx 注入函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196voidngx_http_lua_inject_socket_tcp_api(ngx_log_t *log, lua_State *L)&#123; ngx_int_t rc; // 创建一个 table 用来存储 ngx.socket 操作函数 lua_createtable(L, 0, 4 /* nrec */); /* ngx.socket */ // ngx_http_lua_socket_tcp lua_pushcfunction(L, ngx_http_lua_socket_tcp); // 复制 ngx_http_lua_socket_tcp 并压入栈顶 lua_pushvalue(L, -1); // ngx.socket[&#x27;tcp&#x27;] = ngx_http_lua_socket_tcp // 向表添加 tcp 函数索引 lua_setfield(L, -3, &quot;tcp&quot;); // ngx.socket[stream] = ngx_http_lua_socket_tcp // 向表添加 stream 函数索引 lua_setfield(L, -2, &quot;stream&quot;); &#123; const char buf[] = &quot;local sock = ngx.socket.tcp()&quot; &quot; local ok, err = sock:connect(...)&quot; &quot; if ok then return sock else return nil, err end&quot;; // 会将函数压入栈顶 rc = luaL_loadbuffer(L, buf, sizeof(buf) - 1, &quot;=ngx.socket.connect&quot;); &#125; if (rc != NGX_OK) &#123; ngx_log_error(NGX_LOG_CRIT, log, 0, &quot;failed to load Lua code for ngx.socket.connect(): %i&quot;, rc); &#125; else &#123; // 向表添加 connect 函数索引 // ngx.socket[connect] = func lua_setfield(L, -2, &quot;connect&quot;); &#125; // 向 ngx 表添加 socket 表索引 // ngx[socket] = &#123; tcp = func, stream = func, connect = func&#125; lua_setfield(L, -2, &quot;socket&quot;); // 以下为注册 req_socket 的元表 /* &#123;&#123;&#123;req socket object metatable */ // 将 ngx_http_lua_req_socket_metatable_key 的地址作为 key 压入栈 lua_pushlightuserdata(L, &amp;ngx_http_lua_req_socket_metatable_key); // 创建 table_0，并压入栈顶 lua_createtable(L, 0 /* narr */, 4 /* nrec */); // 在 table_0 添加函数索引：table_0[&#x27;receive&#x27;] = ngx_http_lua_socket_tcp_receive lua_pushcfunction(L, ngx_http_lua_socket_tcp_receive); lua_setfield(L, -2, &quot;receive&quot;); // 在 table_0 添加函数索引：table_0[&#x27;receiveuntil&#x27;] = ngx_http_lua_socket_tcp_receiveuntil lua_pushcfunction(L, ngx_http_lua_socket_tcp_receiveuntil); lua_setfield(L, -2, &quot;receiveuntil&quot;); // 在 table_0 添加函数索引：table_0[&#x27;settimeout&#x27;] = ngx_http_lua_socket_tcp_settimeout lua_pushcfunction(L, ngx_http_lua_socket_tcp_settimeout); lua_setfield(L, -2, &quot;settimeout&quot;); /* ngx socket mt */ // 创建 table_0 拷贝，并压入栈顶，此时栈结构： // 索引 索引 值 // 1 -4 ngx[&#x27;socket&#x27;] = &#123; tcp=func, stream=func, connect = func &#125; // 2 -3 key (address of ngx_http_lua_req_socket_metatable_key) // 3 -2 table_0 = &#123;receive=func, receiveuntil=func, settimeout=func&#125; // 4 -1 table_0_copy lua_pushvalue(L, -1); // 给 table_0 添加 __index 元表 lua_setfield(L, -2, &quot;__index&quot;); // 向虚拟注册表注册值 lua_rawset(L, LUA_REGISTRYINDEX); /* &#125;&#125;&#125; */ /* &#123;&#123;&#123;raw req socket object metatable */ // 将 ngx_http_lua_raw_req_socket_metatable_key 的地址作为 key 压入栈 lua_pushlightuserdata(L, &amp;ngx_http_lua_raw_req_socket_metatable_key); // 创建新表 table_1，并压入栈顶 lua_createtable(L, 0 /* narr */, 5 /* nrec */); // 在 table_1 中插入值，table_1[&#x27;receive&#x27;] = ngx_http_lua_socket_tcp_receive lua_pushcfunction(L, ngx_http_lua_socket_tcp_receive); lua_setfield(L, -2, &quot;receive&quot;); // 在 table_1 中插入值，table_1[&#x27;receiveuntil&#x27;] = ngx_http_lua_socket_tcp_receiveuntil lua_pushcfunction(L, ngx_http_lua_socket_tcp_receiveuntil); lua_setfield(L, -2, &quot;receiveuntil&quot;); // 在 table_1 中插入值，table_1[&#x27;send&#x27;] = ngx_http_lua_socket_tcp_send lua_pushcfunction(L, ngx_http_lua_socket_tcp_send); lua_setfield(L, -2, &quot;send&quot;); // 在 table_1 中插入值，table_1[&#x27;settimeout&#x27;] = ngx_http_lua_socket_tcp_settimeout lua_pushcfunction(L, ngx_http_lua_socket_tcp_settimeout); lua_setfield(L, -2, &quot;settimeout&quot;); /* ngx socket mt */ // 创建 table_1 拷贝，并压入栈顶 lua_pushvalue(L, -1); // 给 table_0 添加 __index 元表 lua_setfield(L, -2, &quot;__index&quot;); // 向虚拟注册表注册值 lua_rawset(L, LUA_REGISTRYINDEX); /* &#125;&#125;&#125; */ /* &#123;&#123;&#123;tcp object metatable */ lua_pushlightuserdata(L, &amp;ngx_http_lua_tcp_socket_metatable_key); lua_createtable(L, 0 /* narr */, 11 /* nrec */); lua_pushcfunction(L, ngx_http_lua_socket_tcp_connect); lua_setfield(L, -2, &quot;connect&quot;);#if (NGX_HTTP_SSL) lua_pushcfunction(L, ngx_http_lua_socket_tcp_sslhandshake); lua_setfield(L, -2, &quot;sslhandshake&quot;);#endif lua_pushcfunction(L, ngx_http_lua_socket_tcp_receive); lua_setfield(L, -2, &quot;receive&quot;); lua_pushcfunction(L, ngx_http_lua_socket_tcp_receiveuntil); lua_setfield(L, -2, &quot;receiveuntil&quot;); lua_pushcfunction(L, ngx_http_lua_socket_tcp_send); lua_setfield(L, -2, &quot;send&quot;); lua_pushcfunction(L, ngx_http_lua_socket_tcp_close); lua_setfield(L, -2, &quot;close&quot;); lua_pushcfunction(L, ngx_http_lua_socket_tcp_setoption); lua_setfield(L, -2, &quot;setoption&quot;); lua_pushcfunction(L, ngx_http_lua_socket_tcp_settimeout); lua_setfield(L, -2, &quot;settimeout&quot;); /* ngx socket mt */ lua_pushcfunction(L, ngx_http_lua_socket_tcp_getreusedtimes); lua_setfield(L, -2, &quot;getreusedtimes&quot;); lua_pushcfunction(L, ngx_http_lua_socket_tcp_setkeepalive); lua_setfield(L, -2, &quot;setkeepalive&quot;); lua_pushvalue(L, -1); lua_setfield(L, -2, &quot;__index&quot;); lua_rawset(L, LUA_REGISTRYINDEX); /* &#125;&#125;&#125; */ /* &#123;&#123;&#123;upstream userdata metatable */ lua_pushlightuserdata(L, &amp;ngx_http_lua_upstream_udata_metatable_key); lua_createtable(L, 0 /* narr */, 1 /* nrec */); /* metatable */ lua_pushcfunction(L, ngx_http_lua_socket_tcp_upstream_destroy); lua_setfield(L, -2, &quot;__gc&quot;); lua_rawset(L, LUA_REGISTRYINDEX); /* &#125;&#125;&#125; */ /* &#123;&#123;&#123;downstream userdata metatable */ lua_pushlightuserdata(L, &amp;ngx_http_lua_downstream_udata_metatable_key); lua_createtable(L, 0 /* narr */, 1 /* nrec */); /* metatable */ lua_pushcfunction(L, ngx_http_lua_socket_downstream_destroy); lua_setfield(L, -2, &quot;__gc&quot;); lua_rawset(L, LUA_REGISTRYINDEX); /* &#125;&#125;&#125; */ /* &#123;&#123;&#123;socket pool userdata metatable */ lua_pushlightuserdata(L, &amp;ngx_http_lua_pool_udata_metatable_key); lua_createtable(L, 0, 1); /* metatable */ lua_pushcfunction(L, ngx_http_lua_socket_shutdown_pool); lua_setfield(L, -2, &quot;__gc&quot;); lua_rawset(L, LUA_REGISTRYINDEX); /* &#125;&#125;&#125; */ /* &#123;&#123;&#123;socket compiled pattern userdata metatable */ lua_pushlightuserdata(L, &amp;ngx_http_lua_pattern_udata_metatable_key); lua_createtable(L, 0 /* narr */, 1 /* nrec */); /* metatable */ lua_pushcfunction(L, ngx_http_lua_socket_cleanup_compiled_pattern); lua_setfield(L, -2, &quot;__gc&quot;); lua_rawset(L, LUA_REGISTRYINDEX); /* &#125;&#125;&#125; */#if (NGX_HTTP_SSL) /* &#123;&#123;&#123;ssl session userdata metatable */ lua_pushlightuserdata(L, &amp;ngx_http_lua_ssl_session_metatable_key); lua_createtable(L, 0 /* narr */, 1 /* nrec */); /* metatable */ lua_pushcfunction(L, ngx_http_lua_ssl_free_session); lua_setfield(L, -2, &quot;__gc&quot;); lua_rawset(L, LUA_REGISTRYINDEX); /* &#125;&#125;&#125; */#endif&#125; 调用 ngx.socket.tcp 创建 tcpsocket 对象，在此过程中并未创建 socket 对象，仅创建了 cosocket table，在调用其 connect 方法时才会进行创建： 12345678910111213141516171819202122232425262728293031323334353637383940// 创建 cosocketstatic intngx_http_lua_socket_tcp(lua_State *L)&#123; ngx_http_request_t *r; ngx_http_lua_ctx_t *ctx; if (lua_gettop(L) != 0) &#123; return luaL_error(L, &quot;expecting zero arguments, but got %d&quot;, lua_gettop(L)); &#125; r = ngx_http_lua_get_req(L); if (r == NULL) &#123; return luaL_error(L, &quot;no request found&quot;); &#125; ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module); if (ctx == NULL) &#123; return luaL_error(L, &quot;no ctx found&quot;); &#125; // 阶段检查 ngx_http_lua_check_context(L, ctx, NGX_HTTP_LUA_CONTEXT_REWRITE | NGX_HTTP_LUA_CONTEXT_ACCESS | NGX_HTTP_LUA_CONTEXT_CONTENT | NGX_HTTP_LUA_CONTEXT_TIMER | NGX_HTTP_LUA_CONTEXT_SSL_CERT | NGX_HTTP_LUA_CONTEXT_SSL_SESS_FETCH); // 创建 tcp socket table 并设置元表 lua_createtable(L, 3 /* narr */, 1 /* nrec */); lua_pushlightuserdata(L, &amp;ngx_http_lua_tcp_socket_metatable_key); lua_rawget(L, LUA_REGISTRYINDEX); lua_setmetatable(L, -2); dd(&quot;top: %d&quot;, lua_gettop(L)); return 1;&#125; tcpsock:connect(host, port, options_table?) 实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353// 创建并建立连接// connect 签名：tcpsock:connect(host, port, options_table?)static intngx_http_lua_socket_tcp_connect(lua_State *L)&#123; ngx_http_request_t *r; ngx_http_lua_ctx_t *ctx; ngx_str_t host; int port; ngx_resolver_ctx_t *rctx, temp; ngx_http_core_loc_conf_t *clcf; int saved_top; int n; u_char *p; size_t len; ngx_url_t url; ngx_int_t rc; ngx_http_lua_loc_conf_t *llcf; ngx_peer_connection_t *pc; int timeout; unsigned custom_pool; int key_index; const char *msg; ngx_http_lua_co_ctx_t *coctx; ngx_http_lua_socket_tcp_upstream_t *u; n = lua_gettop(L); if (n != 2 &amp;&amp; n != 3 &amp;&amp; n != 4) &#123; return luaL_error(L, &quot;ngx.socket connect: expecting 2, 3, or 4 &quot; &quot;arguments (including the object), but seen %d&quot;, n); &#125; r = ngx_http_lua_get_req(L); if (r == NULL) &#123; return luaL_error(L, &quot;no request found&quot;); &#125; ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module); if (ctx == NULL) &#123; return luaL_error(L, &quot;no ctx found&quot;); &#125; // 介入阶段判断 ngx_http_lua_check_context(L, ctx, NGX_HTTP_LUA_CONTEXT_REWRITE | NGX_HTTP_LUA_CONTEXT_ACCESS | NGX_HTTP_LUA_CONTEXT_CONTENT | NGX_HTTP_LUA_CONTEXT_TIMER | NGX_HTTP_LUA_CONTEXT_SSL_CERT | NGX_HTTP_LUA_CONTEXT_SSL_SESS_FETCH); // 检查栈底参数类型 luaL_checktype(L, 1, LUA_TTABLE); p = (u_char *) luaL_checklstring(L, 2, &amp;len); key_index = 2; custom_pool = 0; // 如果最后一个参数时 table 类型 // 解析调用 connect 函数的 options_table 参数 if (lua_type(L, n) == LUA_TTABLE) &#123; /* found the last optional option table */ lua_getfield(L, n, &quot;pool&quot;); switch (lua_type(L, -1)) &#123; case LUA_TNUMBER: lua_tostring(L, -1); case LUA_TSTRING: custom_pool = 1; lua_pushvalue(L, -1); lua_rawseti(L, 1, SOCKET_KEY_INDEX); key_index = n + 1; break; case LUA_TNIL: lua_pop(L, 2); break; default: msg = lua_pushfstring(L, &quot;bad \\&quot;pool\\&quot; option type: %s&quot;, luaL_typename(L, -1)); luaL_argerror(L, n, msg); break; &#125; n--; &#125; if (n == 3) &#123; port = luaL_checkinteger(L, 3); if (port &lt; 0 || port &gt; 65536) &#123; lua_pushnil(L); lua_pushfstring(L, &quot;bad port number: %d&quot;, port); return 2; &#125; if (!custom_pool) &#123; lua_pushliteral(L, &quot;:&quot;); lua_insert(L, 3); lua_concat(L, 3); &#125; dd(&quot;socket key: %s&quot;, lua_tostring(L, -1)); &#125; else &#123; /* n == 2 */ port = 0; &#125; if (!custom_pool) &#123; /* the key&#x27;s index is 2 */ lua_pushvalue(L, 2); lua_rawseti(L, 1, SOCKET_KEY_INDEX); &#125; lua_rawgeti(L, 1, SOCKET_CTX_INDEX); u = lua_touserdata(L, -1); lua_pop(L, 1); if (u) &#123; if (u-&gt;request &amp;&amp; u-&gt;request != r) &#123; return luaL_error(L, &quot;bad request&quot;); &#125; ngx_http_lua_socket_check_busy_connecting(r, u, L); ngx_http_lua_socket_check_busy_reading(r, u, L); ngx_http_lua_socket_check_busy_writing(r, u, L); if (u-&gt;body_downstream || u-&gt;raw_downstream) &#123; return luaL_error(L, &quot;attempt to re-connect a request socket&quot;); &#125; if (u-&gt;peer.connection) &#123; ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, &quot;lua tcp socket reconnect without shutting down&quot;); ngx_http_lua_socket_tcp_finalize(r, u); &#125; ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, &quot;lua reuse socket upstream ctx&quot;); &#125; else &#123; // 调用 ngx.socket.tcp 时并没有创建 socket 对象，在第一次调用 connect 时创建 u = lua_newuserdata(L, sizeof(ngx_http_lua_socket_tcp_upstream_t)); if (u == NULL) &#123; return luaL_error(L, &quot;no memory&quot;); &#125;#if 1 lua_pushlightuserdata(L, &amp;ngx_http_lua_upstream_udata_metatable_key); lua_rawget(L, LUA_REGISTRYINDEX); lua_setmetatable(L, -2);#endif lua_rawseti(L, 1, SOCKET_CTX_INDEX); &#125; ngx_memzero(u, sizeof(ngx_http_lua_socket_tcp_upstream_t)); coctx = ctx-&gt;cur_co_ctx; u-&gt;request = r; /* set the controlling request */ llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module); u-&gt;conf = llcf; pc = &amp;u-&gt;peer; pc-&gt;log = r-&gt;connection-&gt;log; pc-&gt;log_error = NGX_ERROR_ERR; dd(&quot;lua peer connection log: %p&quot;, pc-&gt;log); lua_rawgeti(L, 1, SOCKET_TIMEOUT_INDEX); timeout = (ngx_int_t) lua_tointeger(L, -1); lua_pop(L, 1); if (timeout &gt; 0) &#123; u-&gt;send_timeout = (ngx_msec_t) timeout; u-&gt;read_timeout = (ngx_msec_t) timeout; u-&gt;connect_timeout = (ngx_msec_t) timeout; &#125; else &#123; u-&gt;read_timeout = u-&gt;conf-&gt;read_timeout; u-&gt;send_timeout = u-&gt;conf-&gt;send_timeout; u-&gt;connect_timeout = u-&gt;conf-&gt;connect_timeout; &#125; // 尝试从连接池中查找 rc = ngx_http_lua_get_keepalive_peer(r, L, key_index, u); if (rc == NGX_OK) &#123; lua_pushinteger(L, 1); return 1; &#125; if (rc == NGX_ERROR) &#123; lua_pushnil(L); lua_pushliteral(L, &quot;error in get keepalive peer&quot;); return 2; &#125; /* rc == NGX_DECLINED */ /* TODO: we should avoid this in-pool allocation */ // connect 函数调用中 host 参数解析 host.data = ngx_palloc(r-&gt;pool, len + 1); if (host.data == NULL) &#123; return luaL_error(L, &quot;no memory&quot;); &#125; host.len = len; ngx_memcpy(host.data, p, len); host.data[len] = &#x27;\\0&#x27;; ngx_memzero(&amp;url, sizeof(ngx_url_t)); url.url.len = host.len; url.url.data = host.data; url.default_port = (in_port_t) port; url.no_resolve = 1; // 地址解析获得地址 if (ngx_parse_url(r-&gt;pool, &amp;url) != NGX_OK) &#123; lua_pushnil(L); if (url.err) &#123; lua_pushfstring(L, &quot;failed to parse host name \\&quot;%s\\&quot;: %s&quot;, host.data, url.err); &#125; else &#123; lua_pushfstring(L, &quot;failed to parse host name \\&quot;%s\\&quot;&quot;, host.data); &#125; return 2; &#125; ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, &quot;lua tcp socket connect timeout: %M&quot;, u-&gt;connect_timeout); u-&gt;resolved = ngx_pcalloc(r-&gt;pool, sizeof(ngx_http_upstream_resolved_t)); if (u-&gt;resolved == NULL) &#123; return luaL_error(L, &quot;no memory&quot;); &#125; if (url.addrs &amp;&amp; url.addrs[0].sockaddr) &#123; ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, &quot;lua tcp socket network address given directly&quot;); u-&gt;resolved-&gt;sockaddr = url.addrs[0].sockaddr; u-&gt;resolved-&gt;socklen = url.addrs[0].socklen; u-&gt;resolved-&gt;naddrs = 1; u-&gt;resolved-&gt;host = url.addrs[0].name; &#125; else &#123; u-&gt;resolved-&gt;host = host; u-&gt;resolved-&gt;port = (in_port_t) port; &#125; // ngx_parse_url 成功，已经有地址 if (u-&gt;resolved-&gt;sockaddr) &#123; // 直接进行连接 rc = ngx_http_lua_socket_resolve_retval_handler(r, u, L); if (rc == NGX_AGAIN) &#123; return lua_yield(L, 0); &#125; return rc; &#125; // 需要进行 dns 解析 clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module); temp.name = host; rctx = ngx_resolve_start(clcf-&gt;resolver, &amp;temp); if (rctx == NULL) &#123; u-&gt;ft_type |= NGX_HTTP_LUA_SOCKET_FT_RESOLVER; lua_pushnil(L); lua_pushliteral(L, &quot;failed to start the resolver&quot;); return 2; &#125; if (rctx == NGX_NO_RESOLVER) &#123; u-&gt;ft_type |= NGX_HTTP_LUA_SOCKET_FT_RESOLVER; lua_pushnil(L); lua_pushfstring(L, &quot;no resolver defined to resolve \\&quot;%s\\&quot;&quot;, host.data); return 2; &#125; rctx-&gt;name = host;#if !defined(nginx_version) || nginx_version &lt; 1005008 rctx-&gt;type = NGX_RESOLVE_A;#endif rctx-&gt;handler = ngx_http_lua_socket_resolve_handler; rctx-&gt;data = u; rctx-&gt;timeout = clcf-&gt;resolver_timeout; u-&gt;resolved-&gt;ctx = rctx; u-&gt;write_co_ctx = ctx-&gt;cur_co_ctx; ngx_http_lua_cleanup_pending_operation(coctx); coctx-&gt;cleanup = ngx_http_lua_tcp_resolve_cleanup; coctx-&gt;data = u; saved_top = lua_gettop(L); if (ngx_resolve_name(rctx) != NGX_OK) &#123; ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, &quot;lua tcp socket fail to run resolver immediately&quot;); u-&gt;ft_type |= NGX_HTTP_LUA_SOCKET_FT_RESOLVER; u-&gt;resolved-&gt;ctx = NULL; lua_pushnil(L); lua_pushfstring(L, &quot;%s could not be resolved&quot;, host.data); return 2; &#125; if (u-&gt;conn_waiting) &#123; dd(&quot;resolved and already connecting&quot;); return lua_yield(L, 0); &#125; n = lua_gettop(L) - saved_top; if (n) &#123; dd(&quot;errors occurred during resolving or connecting&quot; &quot;or already connected&quot;); return n; &#125; /* still resolving */ u-&gt;conn_waiting = 1; u-&gt;write_prepare_retvals = ngx_http_lua_socket_resolve_retval_handler; dd(&quot;setting data to %p&quot;, u); if (ctx-&gt;entered_content_phase) &#123; r-&gt;write_event_handler = ngx_http_lua_content_wev_handler; &#125; else &#123; r-&gt;write_event_handler = ngx_http_core_run_phases; &#125; return lua_yield(L, 0);&#125; 四 UDP1. 指令12syntax: udpsock = ngx.socket.udp()context: rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua* 创建并返回一个 UDP 或数据包式 UNINX 域 socket 对象（aka cosocket），支持：setpeername, send, receive, close, settimeout 方法，这些方法都是非阻塞方法。","categories":[{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/categories/NGINX/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"Lua","slug":"Lua","permalink":"https://juzipeek.github.io/tags/Lua/"},{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/tags/NGINX/"},{"name":"OpenResty","slug":"OpenResty","permalink":"https://juzipeek.github.io/tags/OpenResty/"}]},{"title":"OpenResty Api - variable api","slug":"nginx-2019-09-14-openresty-api-variable-api","date":"2022-09-03T12:55:44.512Z","updated":"2022-09-03T12:55:44.513Z","comments":true,"path":"2022/09/03/nginx-2019-09-14-openresty-api-variable-api/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/nginx-2019-09-14-openresty-api-variable-api/","excerpt":"","text":"一 概述variable 接口可以读取、设置变量。在 lua-nginx 模块中使用 ngx.var 表的 __index 和 __newindex 元方法实现变量的读取、设置功能。 二 实现1.ngx.var.VARIABLENGINX 中变量不能动态创建，需要预定义变量。预定义的变量定义在 ngx_http_core_module 的 variables_hash 表中。在 __index 元方法中，除了查找 variables_hash 表，还会根据变量的前缀在请求头（http_）、应答头(sent_http_)、发向上游的头(upstream_http_)、请求 cookie(cookie_)、发向上游的 cookie(upstream_cookie_)以及请求 uri 参数(arg_)中查找变量。 对于 __newindex 元方法，只能更新预定义变量，无法更新请求头、请求参数等。","categories":[{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/categories/NGINX/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"Lua","slug":"Lua","permalink":"https://juzipeek.github.io/tags/Lua/"},{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/tags/NGINX/"},{"name":"OpenResty","slug":"OpenResty","permalink":"https://juzipeek.github.io/tags/OpenResty/"}]},{"title":"OpenResty Api - shdict api","slug":"nginx-2019-09-14-openresty-api-shdict-api","date":"2022-09-03T12:55:44.512Z","updated":"2022-09-03T12:55:44.512Z","comments":true,"path":"2022/09/03/nginx-2019-09-14-openresty-api-shdict-api/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/nginx-2019-09-14-openresty-api-shdict-api/","excerpt":"","text":"一 概述shdict api 实现了共享内存的操作接口，在 lua-nginx 模块中将所有的共享内存（shm_zone）存储在一个 Table 中，每个 shm_zone 使用红黑树存储操作的 key-value。刚才说所有的共享内存，准确的说应该是所有使用 lua_shared_dict 指令创建的共享内存。 lua-nginx 模块中每个 shm_zone 用 Table 表示，在表中使用 SHDICT_USERDATA_INDEX 索引每个共享内存的 zone。 123456789101112131415161718192021222324252627282930313233343536373839404142voidngx_http_lua_inject_shdict_api(ngx_http_lua_main_conf_t *lmcf, lua_State *L)&#123; ngx_http_lua_shdict_ctx_t *ctx; ngx_uint_t i; ngx_shm_zone_t **zone; if (lmcf-&gt;shm_zones != NULL) &#123; // 共享内存 shared 元表 lua_createtable(L, 0, lmcf-&gt;shm_zones-&gt;nelts /* nrec */); /* ngx.shared */ // 共享内存（每块 shm_zone）操作元表 lua_createtable(L, 0 /* narr */, 18 /* nrec */); /* shared mt */ // ... 省略元方法定义 lua_pushvalue(L, -1); /* shared mt mt */ lua_setfield(L, -2, &quot;__index&quot;); /* shared mt */ // 遍历所有的 shm_zone，设置其元表，并将其保存在 shared 表中 zone = lmcf-&gt;shm_zones-&gt;elts; for (i = 0; i &lt; lmcf-&gt;shm_zones-&gt;nelts; i++) &#123; ctx = zone[i]-&gt;data; lua_pushlstring(L, (char *) ctx-&gt;name.data, ctx-&gt;name.len);/* shared mt key */ lua_createtable(L, 1 /* narr */, 0 /* nrec */); /* table of zone[i] */ lua_pushlightuserdata(L, zone[i]); /* shared mt key ud */ lua_rawseti(L, -2, SHDICT_USERDATA_INDEX); /* &#123;zone[i]&#125; */ lua_pushvalue(L, -3); /* shared mt key ud mt */ lua_setmetatable(L, -2); /* shared mt key ud */ lua_rawset(L, -4); /* shared mt */ &#125; lua_pop(L, 1); /* shared */ &#125; else &#123; lua_newtable(L); /* ngx.shared */ &#125; lua_setfield(L, -2, &quot;shared&quot;);&#125; 二 接口1. get|get_stale12value, flags = ngx.shared.DICT:get(key)value, flags, stale = ngx.shared.DICT:get_stale(key) get 函数用来从共享内存中获得 key 对应的值，如果 key 不存在或者已经过期则返回 nil。出错时返回 nil 以及错误描述字符串。 get_stale 函数与 get 相同，唯一不同点在于使用 get_stale 函数访问过期的 key-value 时返回其原始值，而非 nil。同时，返回值中 stale 标识 key 是否已经过期。 **key 必须为字符串类型，value 可以为字符串、数值、布尔或者 NIL**。 get、get_stale 函数最终都是有 ngx_http_lua_shdict_get_helper 实现，只是 get 调用时 get_stale 为 0，get_stale 调用时值为 1。ngx_http_lua_shdict_get_helper 函数实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143static intngx_http_lua_shdict_get_helper(lua_State *L, int get_stale)&#123; // ... omit other code // 参数判断 n = lua_gettop(L); if (n != 2) &#123; return luaL_error(L, &quot;expecting exactly two arguments, &quot; &quot;but only seen %d&quot;, n); &#125; // shm_zone if (lua_type(L, 1) != LUA_TTABLE) &#123; return luaL_error(L, &quot;bad \\&quot;zone\\&quot; argument&quot;); &#125; zone = ngx_http_lua_shdict_get_zone(L, 1); if (zone == NULL) &#123; return luaL_error(L, &quot;bad \\&quot;zone\\&quot; argument&quot;); &#125; ctx = zone-&gt;data; name = ctx-&gt;name; // key if (lua_isnil(L, 2)) &#123; lua_pushnil(L); lua_pushliteral(L, &quot;nil key&quot;); return 2; &#125; key.data = (u_char *) luaL_checklstring(L, 2, &amp;key.len); if (key.len == 0) &#123; lua_pushnil(L); lua_pushliteral(L, &quot;empty key&quot;); return 2; &#125; // key 长度判断 if (key.len &gt; 65535) &#123; lua_pushnil(L); lua_pushliteral(L, &quot;key too long&quot;); return 2; &#125; hash = ngx_crc32_short(key.data, key.len); // 上锁 ngx_shmtx_lock(&amp;ctx-&gt;shpool-&gt;mutex);#if 1 if (!get_stale) &#123; // 过期 key 处理 // n == 1 会尝试删除一个或两个过期 key // n == 0 删除一个最久未被访问的 key ngx_http_lua_shdict_expire(ctx, 1); &#125;#endif // 查找 key 节点 rc = ngx_http_lua_shdict_lookup(zone, hash, key.data, key.len, &amp;sd); dd(&quot;shdict lookup returns %d&quot;, (int) rc); if (rc == NGX_DECLINED || (rc == NGX_DONE &amp;&amp; !get_stale)) &#123; ngx_shmtx_unlock(&amp;ctx-&gt;shpool-&gt;mutex); lua_pushnil(L); return 1; &#125; /* rc == NGX_OK || (rc == NGX_DONE &amp;&amp; get_stale) */ value_type = sd-&gt;value_type; dd(&quot;data: %p&quot;, sd-&gt;data); dd(&quot;key len: %d&quot;, (int) sd-&gt;key_len); value.data = sd-&gt;data + sd-&gt;key_len; value.len = (size_t) sd-&gt;value_len; switch (value_type) &#123; case SHDICT_TSTRING: lua_pushlstring(L, (char *) value.data, value.len); break; case SHDICT_TNUMBER: if (value.len != sizeof(double)) &#123; ngx_shmtx_unlock(&amp;ctx-&gt;shpool-&gt;mutex); return luaL_error(L, &quot;bad lua number value size found for key %s &quot; &quot;in shared_dict %s: %lu&quot;, key.data, name.data, (unsigned long) value.len); &#125; ngx_memcpy(&amp;num, value.data, sizeof(double)); lua_pushnumber(L, num); break; case SHDICT_TBOOLEAN: if (value.len != sizeof(u_char)) &#123; ngx_shmtx_unlock(&amp;ctx-&gt;shpool-&gt;mutex); return luaL_error(L, &quot;bad lua boolean value size found for key %s &quot; &quot;in shared_dict %s: %lu&quot;, key.data, name.data, (unsigned long) value.len); &#125; c = *value.data; lua_pushboolean(L, c ? 1 : 0); break; case SHDICT_TLIST: ngx_shmtx_unlock(&amp;ctx-&gt;shpool-&gt;mutex); lua_pushnil(L); lua_pushliteral(L, &quot;value is a list&quot;); return 2; default: ngx_shmtx_unlock(&amp;ctx-&gt;shpool-&gt;mutex); return luaL_error(L, &quot;bad value type found for key %s in &quot; &quot;shared_dict %s: %d&quot;, key.data, name.data, value_type); &#125; user_flags = sd-&gt;user_flags; ngx_shmtx_unlock(&amp;ctx-&gt;shpool-&gt;mutex); if (get_stale) &#123; /* always return value, flags, stale */ if (user_flags) &#123; lua_pushinteger(L, (lua_Integer) user_flags); &#125; else &#123; lua_pushnil(L); &#125; lua_pushboolean(L, rc == NGX_DONE); return 3; &#125; if (user_flags) &#123; lua_pushinteger(L, (lua_Integer) user_flags); return 2; &#125; return 1;&#125; 2. set1success, err, forcible = ngx.shared.DICT:set(key, value, exptime?, flags?) 无条件的向共享内存中添加一条 key-value。返回值 success 用以标明添加是否成功，err 为错误描述字符串，布尔类型的 forcible 用来标明为了保存本条记录是否将其他合法的 key-value 删除。 参数 key、value 是要保存的 key-value，可选的数值参数 exptime 指定 key 的过期时间，单位为秒但是可以使用小数精确到毫秒级别。exptime 默认为 0，不过期。可选的参数 flag 为 key 的“用户”表示，在使用 get|get_stale 获取 key 时会返回 flag。flag 是 32 为的整数。 在调用 set 时，如果共享内存已经无可用空间，会使用 LRU 策略，从 lru_queue 中删除 key-value（仍然有可能无法满足 set 调用使用的空间）。set 实现函数为 ngx_http_lua_shdict_set_helper，实现函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280// flag 控制 set 的行为，以实现 set、safe_set 功能static intngx_http_lua_shdict_set_helper(lua_State *L, int flags)&#123; // ... omit other code // 参数 n = lua_gettop(L); if (n != 3 &amp;&amp; n != 4 &amp;&amp; n != 5) &#123; return luaL_error(L, &quot;expecting 3, 4 or 5 arguments, but only seen %d&quot;, n); &#125; // shm_zone table if (lua_type(L, 1) != LUA_TTABLE) &#123; return luaL_error(L, &quot;bad \\&quot;zone\\&quot; argument&quot;); &#125; zone = ngx_http_lua_shdict_get_zone(L, 1); if (zone == NULL) &#123; return luaL_error(L, &quot;bad \\&quot;zone\\&quot; argument&quot;); &#125; ctx = zone-&gt;data; // key if (lua_isnil(L, 2)) &#123; lua_pushnil(L); lua_pushliteral(L, &quot;nil key&quot;); return 2; &#125; key.data = (u_char *) luaL_checklstring(L, 2, &amp;key.len); // ... key 长度判断，省略其他代码 hash = ngx_crc32_short(key.data, key.len); // value value_type = lua_type(L, 3); switch (value_type) &#123; case SHDICT_TSTRING: value.data = (u_char *) lua_tolstring(L, 3, &amp;value.len); break; case SHDICT_TNUMBER: value.len = sizeof(double); num = lua_tonumber(L, 3); value.data = (u_char *) &amp;num; break; case SHDICT_TBOOLEAN: value.len = sizeof(u_char); c = lua_toboolean(L, 3) ? 1 : 0; value.data = &amp;c; break; case LUA_TNIL: if (flags &amp; (NGX_HTTP_LUA_SHDICT_ADD|NGX_HTTP_LUA_SHDICT_REPLACE)) &#123; lua_pushnil(L); lua_pushliteral(L, &quot;attempt to add or replace nil values&quot;); return 2; &#125; ngx_str_null(&amp;value); break; default: lua_pushnil(L); lua_pushliteral(L, &quot;bad value type&quot;); return 2; &#125; // 超时时间 if (n &gt;= 4) &#123; exptime = luaL_checknumber(L, 4); if (exptime &lt; 0) &#123; return luaL_error(L, &quot;bad \\&quot;exptime\\&quot; argument&quot;); &#125; &#125; // 用户标识 if (n == 5) &#123; user_flags = (uint32_t) luaL_checkinteger(L, 5); &#125; ngx_shmtx_lock(&amp;ctx-&gt;shpool-&gt;mutex);#if 1 // 尝试删除一个或两个过期 key-value ngx_http_lua_shdict_expire(ctx, 1);#endif rc = ngx_http_lua_shdict_lookup(zone, hash, key.data, key.len, &amp;sd); dd(&quot;shdict lookup returned %d&quot;, (int) rc); if (flags &amp; NGX_HTTP_LUA_SHDICT_REPLACE) &#123; if (rc == NGX_DECLINED || rc == NGX_DONE) &#123; ngx_shmtx_unlock(&amp;ctx-&gt;shpool-&gt;mutex); lua_pushboolean(L, 0); lua_pushliteral(L, &quot;not found&quot;); lua_pushboolean(L, forcible); return 3; &#125; /* rc == NGX_OK */ goto replace; &#125; if (flags &amp; NGX_HTTP_LUA_SHDICT_ADD) &#123; // 已经存在 if (rc == NGX_OK) &#123; ngx_shmtx_unlock(&amp;ctx-&gt;shpool-&gt;mutex); lua_pushboolean(L, 0); lua_pushliteral(L, &quot;exists&quot;); lua_pushboolean(L, forcible); return 3; &#125; if (rc == NGX_DONE) &#123; /* exists but expired */ dd(&quot;go to replace&quot;); goto replace; &#125; /* rc == NGX_DECLINED */ dd(&quot;go to insert&quot;); goto insert; &#125; if (rc == NGX_OK || rc == NGX_DONE) &#123; if (value_type == LUA_TNIL) &#123; goto remove; &#125;replace: if (value.data &amp;&amp; value.len == (size_t) sd-&gt;value_len &amp;&amp; sd-&gt;value_type != SHDICT_TLIST) &#123; ngx_log_debug0(NGX_LOG_DEBUG_HTTP, ctx-&gt;log, 0, &quot;lua shared dict set: found old entry and value &quot; &quot;size matched, reusing it&quot;); // 插入 lru_queue 队首 ngx_queue_remove(&amp;sd-&gt;queue); ngx_queue_insert_head(&amp;ctx-&gt;sh-&gt;lru_queue, &amp;sd-&gt;queue); sd-&gt;key_len = (u_short) key.len; if (exptime &gt; 0) &#123; tp = ngx_timeofday(); sd-&gt;expires = (uint64_t) tp-&gt;sec * 1000 + tp-&gt;msec + (uint64_t) (exptime * 1000); &#125; else &#123; sd-&gt;expires = 0; &#125; sd-&gt;user_flags = user_flags; sd-&gt;value_len = (uint32_t) value.len; dd(&quot;setting value type to %d&quot;, value_type); sd-&gt;value_type = (uint8_t) value_type; p = ngx_copy(sd-&gt;data, key.data, key.len); ngx_memcpy(p, value.data, value.len); ngx_shmtx_unlock(&amp;ctx-&gt;shpool-&gt;mutex); lua_pushboolean(L, 1); lua_pushnil(L); lua_pushboolean(L, forcible); return 3; &#125; ngx_log_debug0(NGX_LOG_DEBUG_HTTP, ctx-&gt;log, 0, &quot;lua shared dict set: found old entry but value size &quot; &quot;NOT matched, removing it first&quot;);remove: if (sd-&gt;value_type == SHDICT_TLIST) &#123; queue = ngx_http_lua_shdict_get_list_head(sd, key.len); for (q = ngx_queue_head(queue); q != ngx_queue_sentinel(queue); q = ngx_queue_next(q)) &#123; p = (u_char *) ngx_queue_data(q, ngx_http_lua_shdict_list_node_t, queue); ngx_slab_free_locked(ctx-&gt;shpool, p); &#125; &#125; ngx_queue_remove(&amp;sd-&gt;queue); node = (ngx_rbtree_node_t *) ((u_char *) sd - offsetof(ngx_rbtree_node_t, color)); ngx_rbtree_delete(&amp;ctx-&gt;sh-&gt;rbtree, node); ngx_slab_free_locked(ctx-&gt;shpool, node); &#125;insert: /* rc == NGX_DECLINED or value size unmatch */ if (value.data == NULL) &#123; ngx_shmtx_unlock(&amp;ctx-&gt;shpool-&gt;mutex); lua_pushboolean(L, 1); lua_pushnil(L); lua_pushboolean(L, 0); return 3; &#125; ngx_log_debug0(NGX_LOG_DEBUG_HTTP, ctx-&gt;log, 0, &quot;lua shared dict set: creating a new entry&quot;); n = offsetof(ngx_rbtree_node_t, color) + offsetof(ngx_http_lua_shdict_node_t, data) + key.len + value.len; node = ngx_slab_alloc_locked(ctx-&gt;shpool, n); if (node == NULL) &#123; if (flags &amp; NGX_HTTP_LUA_SHDICT_SAFE_STORE) &#123; ngx_shmtx_unlock(&amp;ctx-&gt;shpool-&gt;mutex); lua_pushboolean(L, 0); lua_pushliteral(L, &quot;no memory&quot;); return 2; &#125; ngx_log_debug1(NGX_LOG_DEBUG_HTTP, ctx-&gt;log, 0, &quot;lua shared dict set: overriding non-expired items &quot; &quot;due to memory shortage for entry \\&quot;%V\\&quot;&quot;, &amp;key); // 尝试强制删除访问时间最远的 30 个 key-value 以满足 新增 key-value for (i = 0; i &lt; 30; i++) &#123; if (ngx_http_lua_shdict_expire(ctx, 0) == 0) &#123; break; &#125; forcible = 1; node = ngx_slab_alloc_locked(ctx-&gt;shpool, n); if (node != NULL) &#123; goto allocated; &#125; &#125; ngx_shmtx_unlock(&amp;ctx-&gt;shpool-&gt;mutex); lua_pushboolean(L, 0); lua_pushliteral(L, &quot;no memory&quot;); lua_pushboolean(L, forcible); return 3; &#125;allocated: sd = (ngx_http_lua_shdict_node_t *) &amp;node-&gt;color; node-&gt;key = hash; sd-&gt;key_len = (u_short) key.len; if (exptime &gt; 0) &#123; tp = ngx_timeofday(); sd-&gt;expires = (uint64_t) tp-&gt;sec * 1000 + tp-&gt;msec + (uint64_t) (exptime * 1000); &#125; else &#123; sd-&gt;expires = 0; &#125; sd-&gt;user_flags = user_flags; sd-&gt;value_len = (uint32_t) value.len; dd(&quot;setting value type to %d&quot;, value_type); sd-&gt;value_type = (uint8_t) value_type; p = ngx_copy(sd-&gt;data, key.data, key.len); ngx_memcpy(p, value.data, value.len); ngx_rbtree_insert(&amp;ctx-&gt;sh-&gt;rbtree, node); // 插入 lru_queue 队首 ngx_queue_insert_head(&amp;ctx-&gt;sh-&gt;lru_queue, &amp;sd-&gt;queue); ngx_shmtx_unlock(&amp;ctx-&gt;shpool-&gt;mutex); lua_pushboolean(L, 1); lua_pushnil(L); lua_pushboolean(L, forcible); return 3;&#125; ngx_http_lua_shdict_set_helper 函数实现了新增、更新、删除功能，逻辑非常复杂。 3. safe_set1ok, err = ngx.shared.DICT:safe_set(key, value, exptime?, flags?) 与 set 方法相同，只不过不会删除未过期 key-value 以满足保存操作。 4. add1success, err, forcible = ngx.shared.DICT:add(key, value, exptime?, flags?) 与 set 方法相似，不过只会在共享内存中不存在 key 时才会保存设置的 key-value。如果 key 已经在共享内存中，success 为 false，err 为 exists。有可能会删除未过期 key-value，以满足存储需求。 5. safe_add1ok, err = ngx.shared.DICT:safe_add(key, value, exptime?, flags?) 与 add 方法类似，不过不会删除未过期的 key-value 以满足存储需求。 6. replace1success, err, forcible = ngx.shared.DICT:replace(key, value, exptime?, flags?) 与 set 方法类似，不过仅当 key 已经存在于共享内存时才会进行保存操作。如果 key 不存在时会返回 not found 错误描述字符串。 7. incr1newval, err, forcible? = ngx.shared.DICT:incr(key, value, init?, init_ttl?) 将 key 指定的数值类型值增加 value 步长，返回增加后的 value。如果 key 在共享内存中未找到，init 可选参数影响其行为： init 为 nil，函数返回 nil，并且错误描述为 not found。 init 为数值参数，函数返回 init + value。 与 add 函数类似，如果存储空间不足，会删除未过期 key-value。 可选参数 init_ttl 控制 key 的超时时间（仅在初始化时参数有效），以秒为单位，支持浮点数可以精确到毫秒。 8. delete1ngx.shared.DICT:delete(key) 无条件的删除 key 指定的 key-value，等价于调用 set(key, nil) 函数。 9. lpush1length, err = ngx.shared.DICT:lpush(key, value) 将指定的数值或字符串 value 插入基于共享内存的列表头，返回 list 中的元素数量。如果 key 不存在，则在执行当前函后会创建一个新的列表，当 key 已经存在但是非列表类型，错误提示为 value not a list。 **lpush 不会删除未过期 key-value**。 10. rpush1length, err = ngx.shared.DICT:rpush(key, value) 与 lpush 相似，只不过 rpush 在队列尾插入值。 11. lpop1val, err = ngx.shared.DICT:lpop(key) 从 list 中返回并删除首个元素，如果 key 不存在返回 nil，如果 key 相应的 value 非 list 类型，返回 value not a list。 12. rpop1val, err = ngx.shared.DICT:rpop(key) 从 list 中返回并删除末尾元素，如果 key 不存在返回 nil，如果 key 相应的 value 非 list 类型，返回 value not a list。 13. llen1len, err = ngx.shared.DICT:llen(key) 计算 list 中元素数量，如果 key 不存在代表是空列表，返回 0。如果 key 的值非列表类型，返回 nil 以及相应错误描述。 14. ttl1ttl, err = ngx.shared.DICT:ttl(key) 返回 key 剩余的 TTL 时间，以秒为单位，精确到毫秒。失败返回 nil 以及错误描述字符串。如果返回 ttl 为零，说明未设置超时时间。 15. expire1success, err = ngx.shared.DICT:expire(key, exptime) 更新 key 的超时时间，返回布尔类型状态信息以及错误描述。参数 exptime 以秒为单位精确到毫秒。 16. flush_all|flush_expired12ngx.shared.DICT:flush_all()flushed = ngx.shared.DICT:flush_expired(max_count?) 删除所有的 key-value 或者过期的 key-value。flush_expired 函数接受一个可选的 max_count 参数，用来控制删除过期 key 数量。默认为 0，会删除所有的过期 key。同时，flush_expired 函数会返回删除的 key 数量。 17. get_keys1keys = ngx.shared.DICT:get_keys(max_count?) 返回一个包含共享内存（shm_zone）所有 keys 的 Array Table。可选数值参数 max_count 可以控制返回的 key 数量，默认为 1024 个。","categories":[{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/categories/NGINX/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"Lua","slug":"Lua","permalink":"https://juzipeek.github.io/tags/Lua/"},{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/tags/NGINX/"},{"name":"OpenResty","slug":"OpenResty","permalink":"https://juzipeek.github.io/tags/OpenResty/"}]},{"title":"OpenResty Api - resp_header api","slug":"nginx-2019-09-14-openresty-api-resp-header-api","date":"2022-09-03T12:55:44.511Z","updated":"2022-09-03T12:55:44.511Z","comments":true,"path":"2022/09/03/nginx-2019-09-14-openresty-api-resp-header-api/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/nginx-2019-09-14-openresty-api-resp-header-api/","excerpt":"","text":"一 概述resp_header api 主要用来读取、设置应答头。 二 接口1. ngx.header通过 ngx.header.HEADER_NAME 可以获取或设置应答 HEADER_NAME 的值，lua-nginx 模块对 ngx.header 表的 __index 和 __newindex 方法做了修改实现了应答头的获取和设置功能。在将头设置为 nil 时可以实现删除应答头的功能。**HEADER_NAME 是大小写无关的，同时默认会将下划线（_）替换为中划线（-）**。 __index 元方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151static intngx_http_lua_ngx_header_get(lua_State *L)&#123; // ... omit other code r = ngx_http_lua_get_req(L); if (r == NULL) &#123; return luaL_error(L, &quot;no request object found&quot;); &#125; ngx_http_lua_check_fake_request(L, r); /* we skip the first argument that is the table */ p = (u_char *) luaL_checklstring(L, 2, &amp;len); dd(&quot;key: %.*s, len %d&quot;, (int) len, p, (int) len); // 将应答头名中 &quot;_&quot; 替换为 &quot;-&quot; llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module); if (llcf-&gt;transform_underscores_in_resp_headers &amp;&amp; memchr(p, &#x27;_&#x27;, len) != NULL) &#123; key.data = (u_char *) lua_newuserdata(L, len); if (key.data == NULL) &#123; return luaL_error(L, &quot;no memory&quot;); &#125; /* replace &quot;_&quot; with &quot;-&quot; */ for (i = 0; i &lt; len; i++) &#123; c = p[i]; if (c == &#x27;_&#x27;) &#123; c = &#x27;-&#x27;; &#125; key.data[i] = c; &#125; &#125; else &#123; key.data = p; &#125; key.len = len; return ngx_http_lua_get_output_header(L, r, &amp;key);&#125;// 获取应答头intngx_http_lua_get_output_header(lua_State *L, ngx_http_request_t *r, ngx_str_t *key)&#123; // ... omit other code dd(&quot;looking for response header \\&quot;%.*s\\&quot;&quot;, (int) key-&gt;len, key-&gt;data); // 判断是否是内建 header switch (key-&gt;len) &#123; case 14: if (r-&gt;headers_out.content_length == NULL &amp;&amp; r-&gt;headers_out.content_length_n &gt;= 0 &amp;&amp; ngx_strncasecmp(key-&gt;data, (u_char *) &quot;Content-Length&quot;, 14) == 0) &#123; lua_pushinteger(L, (lua_Integer) r-&gt;headers_out.content_length_n); return 1; &#125; break; case 12: if (r-&gt;headers_out.content_type.len &amp;&amp; ngx_strncasecmp(key-&gt;data, (u_char *) &quot;Content-Type&quot;, 12) == 0) &#123; lua_pushlstring(L, (char *) r-&gt;headers_out.content_type.data, r-&gt;headers_out.content_type.len); return 1; &#125; break; default: break; &#125; dd(&quot;not a built-in output header&quot;); found = 0;#if 1 if (r-&gt;headers_out.location &amp;&amp; r-&gt;headers_out.location-&gt;value.len &amp;&amp; r-&gt;headers_out.location-&gt;value.data[0] == &#x27;/&#x27;) &#123; /* XXX ngx_http_core_find_config_phase, for example, * may not initialize the &quot;key&quot; and &quot;hash&quot; fields * for a nasty optimization purpose, and * we have to work-around it here */ r-&gt;headers_out.location-&gt;hash = ngx_http_lua_location_hash; ngx_str_set(&amp;r-&gt;headers_out.location-&gt;key, &quot;Location&quot;); &#125;#endif // 遍历 list part = &amp;r-&gt;headers_out.headers.part; h = part-&gt;elts; for (i = 0; /* void */; i++) &#123; if (i &gt;= part-&gt;nelts) &#123; if (part-&gt;next == NULL) &#123; break; &#125; part = part-&gt;next; h = part-&gt;elts; i = 0; &#125; if (h[i].hash == 0) &#123; continue; &#125; // 匹配时进行大小写无关 if (h[i].hash != 0 &amp;&amp; h[i].key.len == key-&gt;len &amp;&amp; ngx_strncasecmp(key-&gt;data, h[i].key.data, h[i].key.len) == 0) &#123; if (!found) &#123; found = 1; lua_pushlstring(L, (char *) h[i].value.data, h[i].value.len); continue; &#125; if (found == 1) &#123; lua_createtable(L, 4 /* narr */, 0); lua_insert(L, -2); lua_rawseti(L, -2, found); &#125; found++; lua_pushlstring(L, (char *) h[i].value.data, h[i].value.len); lua_rawseti(L, -2, found); &#125; &#125; if (found) &#123; return 1; &#125; lua_pushnil(L); return 1;&#125; __newindex 元方法更复杂些，HEADER_NAME 处理简单，只需要获取栈上的参数即可。HEADER_VALUE 处理复杂些，需要判断类型，支持 String、NIL、String Array Table。ngx_http_lua_set_output_header 是应答头更新函数，在其中将应答头的更新抽象为回调函数并存储在数组中。内建的头有独立的回调函数，通用头使用通用头回调函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179// __newindex 入口static intngx_http_lua_ngx_header_set(lua_State *L)&#123; // ... omit other code r = ngx_http_lua_get_req(L); if (r == NULL) &#123; return luaL_error(L, &quot;no request object found&quot;); &#125; ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module); if (ctx == NULL) &#123; return luaL_error(L, &quot;no ctx&quot;); &#125; ngx_http_lua_check_fake_request(L, r); // 头已经发送出去 if (r-&gt;header_sent || ctx-&gt;header_sent) &#123; ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0, &quot;attempt to &quot; &quot;set ngx.header.HEADER after sending out &quot; &quot;response headers&quot;); return 0; &#125; // header name /* we skip the first argument that is the table */ p = (u_char *) luaL_checklstring(L, 2, &amp;len); dd(&quot;key: %.*s, len %d&quot;, (int) len, p, (int) len); key.data = ngx_palloc(r-&gt;pool, len + 1); if (key.data == NULL) &#123; return luaL_error(L, &quot;no memory&quot;); &#125; ngx_memcpy(key.data, p, len); key.data[len] = &#x27;\\0&#x27;; key.len = len; // 下划线到中划线转换配置 llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module); if (llcf-&gt;transform_underscores_in_resp_headers) &#123; /* replace &quot;_&quot; with &quot;-&quot; */ p = key.data; for (i = 0; i &lt; len; i++) &#123; if (p[i] == &#x27;_&#x27;) &#123; p[i] = &#x27;-&#x27;; &#125; &#125; &#125; if (!ctx-&gt;headers_set) &#123; rc = ngx_http_lua_set_content_type(r); if (rc != NGX_OK) &#123; return luaL_error(L, &quot;failed to set default content type: %d&quot;, (int) rc); &#125; ctx-&gt;headers_set = 1; &#125; // header value if (lua_type(L, 3) == LUA_TNIL) &#123; ngx_str_null(&amp;value); &#125; else if (lua_type(L, 3) == LUA_TTABLE) &#123; n = luaL_getn(L, 3); if (n == 0) &#123; ngx_str_null(&amp;value); &#125; else &#123; for (i = 1; i &lt;= n; i++) &#123; dd(&quot;header value table index %d&quot;, (int) i); lua_rawgeti(L, 3, i); p = (u_char *) luaL_checklstring(L, -1, &amp;len); value.data = ngx_palloc(r-&gt;pool, len); if (value.data == NULL) &#123; return luaL_error(L, &quot;no memory&quot;); &#125; ngx_memcpy(value.data, p, len); value.len = len; // i == 1 非常重要 // 如果一直为 true 那么 multi header 表只会有最后一个 值被设置 rc = ngx_http_lua_set_output_header(r, key, value, i == 1 /* override */); if (rc == NGX_ERROR) &#123; return luaL_error(L, &quot;failed to set header %s (error: %d)&quot;, key.data, (int) rc); &#125; &#125; return 0; &#125; &#125; else &#123; p = (u_char *) luaL_checklstring(L, 3, &amp;len); value.data = ngx_palloc(r-&gt;pool, len); if (value.data == NULL) &#123; return luaL_error(L, &quot;no memory&quot;); &#125; ngx_memcpy(value.data, p, len); value.len = len; &#125; dd(&quot;key: %.*s, value: %.*s&quot;, (int) key.len, key.data, (int) value.len, value.data); rc = ngx_http_lua_set_output_header(r, key, value, 1 /* override */); if (rc == NGX_ERROR) &#123; return luaL_error(L, &quot;failed to set header %s (error: %d)&quot;, key.data, (int) rc); &#125; return 0;&#125;static ngx_http_lua_set_header_t ngx_http_lua_set_handlers[] = &#123; &#123; ngx_string(&quot;Server&quot;), offsetof(ngx_http_headers_out_t, server), ngx_http_set_builtin_header &#125;, // ... omit other code &#123; ngx_null_string, 0, ngx_http_set_header &#125;&#125;;ngx_int_tngx_http_lua_set_output_header(ngx_http_request_t *r, ngx_str_t key, ngx_str_t value, unsigned override)&#123; // ... omit other code // header 操作表 ngx_http_lua_set_header_t *handlers = ngx_http_lua_set_handlers; dd(&quot;set header value: %.*s&quot;, (int) value.len, value.data); hv.hash = ngx_hash_key_lc(key.data, key.len); hv.key = key; hv.offset = 0; hv.no_override = !override; hv.handler = NULL; // 大小写无关匹配 for (i = 0; handlers[i].name.len; i++) &#123; if (hv.key.len != handlers[i].name.len || ngx_strncasecmp(hv.key.data, handlers[i].name.data, handlers[i].name.len) != 0) &#123; dd(&quot;hv key comparison: %s &lt;&gt; %s&quot;, handlers[i].name.data, hv.key.data); continue; &#125; dd(&quot;Matched handler: %s %s&quot;, handlers[i].name.data, hv.key.data); hv.offset = handlers[i].offset; hv.handler = handlers[i].handler; break; &#125; if (handlers[i].name.len == 0 &amp;&amp; handlers[i].handler) &#123; hv.offset = handlers[i].offset; hv.handler = handlers[i].handler; &#125;#if 1 if (hv.handler == NULL) &#123; return NGX_ERROR; &#125;#endif return hv.handler(r, &amp;hv, &amp;value);&#125; 2. ngx.resp1headers, err = ngx.resp.get_headers(max_headers?, raw?) 返回一个包含当前请求所有应答头的 Table。可选数值参数 max_header 用来控制返回 header 的数量，默认为 100,布尔类型参数 raw 用来控制返回的 Table 是否有 __index 元方法（HEADER_NAME 大小写无关，并且将下划线转为中划线）。","categories":[{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/categories/NGINX/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"Lua","slug":"Lua","permalink":"https://juzipeek.github.io/tags/Lua/"},{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/tags/NGINX/"},{"name":"OpenResty","slug":"OpenResty","permalink":"https://juzipeek.github.io/tags/OpenResty/"}]},{"title":"OpenResty Api - req api","slug":"nginx-2019-09-08-openresty-api-req-api","date":"2022-09-03T12:55:44.510Z","updated":"2022-09-03T12:55:44.511Z","comments":true,"path":"2022/09/03/nginx-2019-09-08-openresty-api-req-api/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/nginx-2019-09-08-openresty-api-req-api/","excerpt":"","text":"一 概述ngx.req 主要围绕对请求头、请求 uri、请求参数、请求包体、请求连接 socket、请求方法等进行操作。 二 请求头相关包含 ngx.req.http_version、 ngx.req.raw_header、 ngx.req.clear_header、 ngx.req.set_header、 ngx.req.get_headers 操作函数。 1. ngx.req.http_version功能：获得请求使用的 HTTP 协议版本号，返回数值类型（0.9、1.0、1.1、2.0），客户端发起请求时会将协议版本号放在请求行中。出错会返回 nil。 2. ngx.req.raw_header1str = ngx.req.raw_header(no_request_line?) 功能：用来获取 NGINX 收到的原始请求头，返回字符串。可选布尔类型参数 no_request_line 用来控制是否返回请求行。 介入阶段: set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua 示例： 1ngx.print(ngx.req.raw_header()) 输出如下： 1234GET /t HTTP/1.1Host: localhostConnection: closeFoo: bar 如果 no_request_line 为 true 时输出如下： 123Host: localhostConnection: closeFoo: bar 3. ngx.req.clear_header1ngx.req.clear_header(header_name) 清除请求头中名为 header_name 的头。clear_header 的实现与 set_header 方法实现相同，只不过 clear_header 设置的值为 nil。clear_header 实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113static intngx_http_lua_ngx_req_header_clear(lua_State *L)&#123; // 参数检查，只有一个参数（header_name） if (lua_gettop(L) != 1) &#123; return luaL_error(L, &quot;expecting one arguments, but seen %d&quot;, lua_gettop(L)); &#125; // 向栈中压入 nil lua_pushnil(L); return ngx_http_lua_ngx_req_header_set_helper(L);&#125;// 函数主要功能是将 header 的 key、value 获取出来，再调用最终保存函数static intngx_http_lua_ngx_req_header_set_helper(lua_State *L)&#123; // ... 参数检查 // http 0.9 无 header if (r-&gt;http_version &lt; NGX_HTTP_VERSION_10) &#123; return 0; &#125; // 获得 header 名 p = (u_char *) luaL_checklstring(L, 1, &amp;len); key.data = ngx_palloc(r-&gt;pool, len + 1); if (key.data == NULL) &#123; return luaL_error(L, &quot;no memory&quot;); &#125; ngx_memcpy(key.data, p, len); key.data[len] = &#x27;\\0&#x27;; key.len = len; // 获得 header 值 if (lua_type(L, 2) == LUA_TNIL) &#123; ngx_str_null(&amp;value); &#125; else if (lua_type(L, 2) == LUA_TTABLE) &#123; n = luaL_getn(L, 2); if (n == 0) &#123; ngx_str_null(&amp;value); &#125; else &#123; // 使用数组设置 header for (i = 1; i &lt;= n; i++) &#123; dd(&quot;header value table index %d, top: %d&quot;, (int) i, lua_gettop(L)); // 取出数组中的元素放在栈顶 lua_rawgeti(L, 2, i); // 从栈顶取 header 值 p = (u_char *) luaL_checklstring(L, -1, &amp;len); /* * we also copy the trailling &#x27;\\0&#x27; char here because nginx * header values must be null-terminated * */ value.data = ngx_palloc(r-&gt;pool, len + 1); if (value.data == NULL) &#123; return luaL_error(L, &quot;no memory&quot;); &#125; ngx_memcpy(value.data, p, len + 1); value.len = len; rc = ngx_http_lua_set_input_header(r, key, value, i == 1 /* override */); if (rc == NGX_ERROR) &#123; return luaL_error(L, &quot;failed to set header %s (error: %d)&quot;, key.data, (int) rc); &#125; &#125; return 0; &#125; &#125; else &#123; /* * we also copy the trailling &#x27;\\0&#x27; char here because nginx * header values must be null-terminated * */ p = (u_char *) luaL_checklstring(L, 2, &amp;len); value.data = ngx_palloc(r-&gt;pool, len + 1); if (value.data == NULL) &#123; return luaL_error(L, &quot;no memory&quot;); &#125; ngx_memcpy(value.data, p, len + 1); value.len = len; &#125; dd(&quot;key: %.*s, value: %.*s&quot;, (int) key.len, key.data, (int) value.len, value.data); // 保存 header 到请求中 rc = ngx_http_lua_set_input_header(r, key, value, 1 /* override */); if (rc == NGX_ERROR) &#123; return luaL_error(L, &quot;failed to set header %s (error: %d)&quot;, key.data, (int) rc); &#125; return 0;&#125; 上面两个函数做了 header 保存的准备工作，将 header 的 key、value 提取出来，调用 ngx_http_lua_set_input_header 对 header 进行操作。lua-nginx 模块对常见或特殊 header 有特殊操作（因为这些 header 保存位置或者同时需要更新其他信息），将其保存在一张操作表中（ngx_http_lua_set_handlers），表中最后一个元素是通用的 header 处理。实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960static ngx_http_lua_set_header_t ngx_http_lua_set_handlers[] = &#123; &#123; ngx_string(&quot;Host&quot;), offsetof(ngx_http_headers_in_t, host), ngx_http_set_host_header &#125;, // ... 省略其他常见或特殊 header &#123; ngx_null_string, 0, ngx_http_set_header &#125;&#125;;ngx_int_tngx_http_lua_set_input_header(ngx_http_request_t *r, ngx_str_t key, ngx_str_t value, unsigned override)&#123; ngx_http_lua_header_val_t hv; ngx_http_lua_set_header_t *handlers = ngx_http_lua_set_handlers; ngx_uint_t i; dd(&quot;set header value: %.*s&quot;, (int) value.len, value.data); hv.hash = ngx_hash_key_lc(key.data, key.len); hv.key = key; hv.offset = 0; hv.no_override = !override; hv.handler = NULL; // 遍历 ngx_http_lua_set_handlers 数组，查找是否是设置预定义 header for (i = 0; handlers[i].name.len; i++) &#123; if (hv.key.len != handlers[i].name.len || ngx_strncasecmp(hv.key.data, handlers[i].name.data, handlers[i].name.len) != 0) &#123; dd(&quot;hv key comparison: %s &lt;&gt; %s&quot;, handlers[i].name.data, hv.key.data); continue; &#125; dd(&quot;Matched handler: %s %s&quot;, handlers[i].name.data, hv.key.data); hv.offset = handlers[i].offset; hv.handler = handlers[i].handler; break; &#125; // 未找到，使用 ngx_http_lua_set_handlers 数组末尾元素进行存储调用 if (handlers[i].name.len == 0 &amp;&amp; handlers[i].handler) &#123; hv.offset = handlers[i].offset; // 0 hv.handler = handlers[i].handler; // ngx_http_set_header &#125;#if 1 if (hv.handler == NULL) &#123; return NGX_ERROR; &#125;#endif return hv.handler(r, &amp;hv, &amp;value);&#125; 4. ngx.req.set_headr1ngx.req.set_header(header_name, header_value) 将当前请求中名为 header_name 的头设置为 header_value，如果 header_name 已经存在则覆盖原有值。如果 header_value 为 nil 功能与 clear_header 相同。header_value 可以为 array table。 set_header 的实现与 clear_header 相似，只是其检查函数不同。 5. ngx.req.get_headers1headers, err = ngx.req.get_headers(max_headers?, raw?) 返回一个包含所有 header 的 table，可选数值参数 max_headers 用来控制获取的 header 数量（其实是 header_value 的数量，因为在请求中每个 header_value 是一 header），默认 100。可选布尔类型参数 raw 用来控制返回 table 是否有元方法，默认 false。 实现函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293static intngx_http_lua_ngx_req_get_headers(lua_State *L)&#123; // ... 忽略参数定义 // 获得调用参数梳理 n = lua_gettop(L); // 取调用参数 max、raw if (n &gt;= 1) &#123; if (lua_isnil(L, 1)) &#123; max = NGX_HTTP_LUA_MAX_HEADERS; &#125; else &#123; max = luaL_checkinteger(L, 1); &#125; if (n &gt;= 2) &#123; raw = lua_toboolean(L, 2); &#125; &#125; else &#123; max = NGX_HTTP_LUA_MAX_HEADERS; &#125; r = ngx_http_lua_get_req(L); if (r == NULL) &#123; return luaL_error(L, &quot;no request object found&quot;); &#125; ngx_http_lua_check_fake_request(L, r); // 计算 header 总数 part = &amp;r-&gt;headers_in.headers.part; count = part-&gt;nelts; while (part-&gt;next) &#123; part = part-&gt;next; count += part-&gt;nelts; &#125; if (max &gt; 0 &amp;&amp; count &gt; max) &#123; count = max; ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, &quot;lua exceeding request header limit %d&quot;, max); &#125; // 创建返回 table，根据 raw 参数设置 table 的元表（有 index 元方法） lua_createtable(L, 0, count); if (!raw) &#123; lua_pushlightuserdata(L, &amp;ngx_http_lua_headers_metatable_key); lua_rawget(L, LUA_REGISTRYINDEX); lua_setmetatable(L, -2); &#125; // 遍历 header，将其保存到新创建的 table 中 part = &amp;r-&gt;headers_in.headers.part; header = part-&gt;elts; for (i = 0; /* void */; i++) &#123; dd(&quot;stack top: %d&quot;, lua_gettop(L)); if (i &gt;= part-&gt;nelts) &#123; if (part-&gt;next == NULL) &#123; break; &#125; part = part-&gt;next; header = part-&gt;elts; i = 0; &#125; if (raw) &#123; lua_pushlstring(L, (char *) header[i].key.data, header[i].key.len); &#125; else &#123; lua_pushlstring(L, (char *) header[i].lowcase_key, header[i].key.len); &#125; /* stack: table key */ lua_pushlstring(L, (char *) header[i].value.data, header[i].value.len); /* stack: table key value */ ngx_http_lua_set_multi_value_table(L, -3); ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, &quot;lua request header: \\&quot;%V: %V\\&quot;&quot;, &amp;header[i].key, &amp;header[i].value); if (--count == 0) &#123; return 1; &#125; &#125; return 1;&#125; 三 请求 uri1. ngx.req.set_uri1ngx.req.set_uri(uri, jump?) 使用字符串参数 uri 重写请求的 uri，uri 如果非字符串或者字符串长度为零会触发错误。可选布尔参数 jump 控制是否进行内部跳转（重新在当前 server&#123;&#125; 内进行 location 查找）。**set_uri 无法修改 uri 参数，需要使用 ngx.req.set_uri_args 修改参数**。 函数 ngx_http_lua_ngx_req_set_uri 是 set_uri 的实现函数，在其中修改了请求的 uri 以及 uri_changed 状态变量，实际的跳转功能是在协程处理循环中实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657static intngx_http_lua_ngx_req_set_uri(lua_State *L)&#123; // ... 省略无关代码 // 参数数量获取 n = lua_gettop(L); if (n != 1 &amp;&amp; n != 2) &#123; return luaL_error(L, &quot;expecting 1 or 2 arguments but seen %d&quot;, n); &#125; // 获取 uri p = (u_char *) luaL_checklstring(L, 1, &amp;len); if (len == 0) &#123; return luaL_error(L, &quot;attempt to use zero-length uri&quot;); &#125; // 是否跳转标识 if (n == 2) &#123; luaL_checktype(L, 2, LUA_TBOOLEAN); jump = lua_toboolean(L, 2); if (jump) &#123; ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module); if (ctx == NULL) &#123; return luaL_error(L, &quot;no ctx found&quot;); &#125; // 阶段检查 ngx_http_lua_check_context(L, ctx, NGX_HTTP_LUA_CONTEXT_REWRITE); ngx_http_lua_check_if_abortable(L, ctx); &#125; &#125; // uri 更新 r-&gt;uri.data = ngx_palloc(r-&gt;pool, len); if (r-&gt;uri.data == NULL) &#123; return luaL_error(L, &quot;no memory&quot;); &#125; ngx_memcpy(r-&gt;uri.data, p, len); r-&gt;uri.len = len; r-&gt;internal = 1; r-&gt;valid_unparsed_uri = 0; ngx_http_set_exten(r); // 跳转标识，在协程处理循环中会使用 if (jump) &#123; r-&gt;uri_changed = 1; return lua_yield(L, 0); &#125; r-&gt;valid_location = 0; r-&gt;uri_changed = 0; return 0;&#125; 四 请求参数1. ngx.req.set_uri_args1ngx.req.set_uri_args(args) 使用 args 参数重写当前请求的 uri 查询参数，args 可以是字符串也可以是 table。如果使用 table 会将参数进行 uri_encode（其实是调用 ngx.encode_args 将 args 编码为字符串）。set_uri_args 实现函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455static intngx_http_lua_ngx_req_set_uri_args(lua_State *L)&#123; // ... 省略其他代码 // 参数检查 if (lua_gettop(L) != 1) &#123; return luaL_error(L, &quot;expecting 1 argument but seen %d&quot;, lua_gettop(L)); &#125; r = ngx_http_lua_get_req(L); if (r == NULL) &#123; return luaL_error(L, &quot;no request object found&quot;); &#125; ngx_http_lua_check_fake_request(L, r); // 获取 args switch (lua_type(L, 1)) &#123; case LUA_TNUMBER: case LUA_TSTRING: p = (u_char *) lua_tolstring(L, 1, &amp;len); args.data = ngx_palloc(r-&gt;pool, len); if (args.data == NULL) &#123; return luaL_error(L, &quot;no memory&quot;); &#125; ngx_memcpy(args.data, p, len); args.len = len; break; case LUA_TTABLE: ngx_http_lua_process_args_option(r, L, 1, &amp;args); dd(&quot;args: %.*s&quot;, (int) args.len, args.data); break; default: msg = lua_pushfstring(L, &quot;string, number, or table expected, &quot; &quot;but got %s&quot;, luaL_typename(L, 2)); return luaL_argerror(L, 1, msg); &#125; dd(&quot;args: %.*s&quot;, (int) args.len, args.data); // 更新 args r-&gt;args.data = args.data; r-&gt;args.len = args.len; r-&gt;valid_unparsed_uri = 0; return 0;&#125; 2. ngx.req.get_uri_args1args, err = ngx.req.get_uri_args(max_args?) 返回一个包含当前请求 URL 参数的 table。可选数值参数 max_args 用来控制返回参数个数，默认为 100，修改为 0 则无限制。 当请求行为 GET /test?foo=bar&amp;bar=baz&amp;bar=blah 时，获得的 table 为： 1&#123;foo=&quot;bar&quot;, bar=&#123;&quot;baz&quot;, &quot;blah&quot;&#125;&#125; 当请求行为 GET /test?foo&amp;bar 时，获得的 table 为： 1&#123;foo=true, bar=true&#125; 当请求行为 GET /test?foo=&amp;bar= 时，获得的 table 为： 1&#123;foo=&quot;&quot;, bar=&quot;&quot;&#125; 实现函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849static intngx_http_lua_ngx_req_get_uri_args(lua_State *L)&#123; // ... 省略无关代码 // 获得调用参数数量 n = lua_gettop(L); if (n != 0 &amp;&amp; n != 1) &#123; return luaL_error(L, &quot;expecting 0 or 1 arguments but seen %d&quot;, n); &#125; if (n == 1) &#123; max = luaL_checkinteger(L, 1); lua_pop(L, 1); &#125; else &#123; max = NGX_HTTP_LUA_MAX_ARGS; &#125; r = ngx_http_lua_get_req(L); if (r == NULL) &#123; return luaL_error(L, &quot;no request object found&quot;); &#125; ngx_http_lua_check_fake_request(L, r); if (r-&gt;args.len == 0) &#123; lua_createtable(L, 0, 0); return 1; &#125; /* we copy r-&gt;args over to buf to simplify * unescaping query arg keys and values */ // 获得请求参数 buf = ngx_palloc(r-&gt;pool, r-&gt;args.len); if (buf == NULL) &#123; return luaL_error(L, &quot;no memory&quot;); &#125; // 保存 args 的 table lua_createtable(L, 0, 4); ngx_memcpy(buf, r-&gt;args.data, r-&gt;args.len); last = buf + r-&gt;args.len; // 将请求参数进行解析并保存到 table 中 // 会对参数名和参数值进行 url decode retval = ngx_http_lua_parse_args(L, buf, last, max); ngx_pfree(r-&gt;pool, buf); return retval;&#125; 3. ngx.req.get_post_args1args, err = ngx.req.get_post_args(max_args?) 返回包含当前请求 POST 查询参数的 table，调用前需要调用 ngx.req.read_body 函数或者通过 lua_need_request_body 读取请求包体。可选数值参数 max_args 用来控制返回参数个数，默认为 100，修改为 0 则无限制。实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980static intngx_http_lua_ngx_req_get_post_args(lua_State *L)&#123; // ... 忽略无关代码 // 获得调用参数个数 n = lua_gettop(L); if (n != 0 &amp;&amp; n != 1) &#123; return luaL_error(L, &quot;expecting 0 or 1 arguments but seen %d&quot;, n); &#125; // 参数检查 if (n == 1) &#123; max = luaL_checkinteger(L, 1); lua_pop(L, 1); &#125; else &#123; max = NGX_HTTP_LUA_MAX_ARGS; &#125; r = ngx_http_lua_get_req(L); if (r == NULL) &#123; return luaL_error(L, &quot;no request object found&quot;); &#125; ngx_http_lua_check_fake_request(L, r); // 已经丢弃请求包体 if (r-&gt;discard_body) &#123; lua_createtable(L, 0, 0); return 1; &#125; if (r-&gt;request_body == NULL) &#123; return luaL_error(L, &quot;no request body found; &quot; &quot;maybe you should turn on lua_need_request_body?&quot;); &#125; // 请求包体存储在临时文件中，不能使用 get_post_args if (r-&gt;request_body-&gt;temp_file) &#123; lua_pushnil(L); lua_pushliteral(L, &quot;requesty body in temp file not supported&quot;); return 2; &#125; if (r-&gt;request_body-&gt;bufs == NULL) &#123; lua_createtable(L, 0, 0); return 1; &#125; /* we copy r-&gt;request_body-&gt;bufs over to buf to simplify * unescaping query arg keys and values */ // 读取请求包体 len = 0; for (cl = r-&gt;request_body-&gt;bufs; cl; cl = cl-&gt;next) &#123; len += cl-&gt;buf-&gt;last - cl-&gt;buf-&gt;pos; &#125; if (len == 0) &#123; lua_createtable(L, 0, 0); return 1; &#125; buf = ngx_palloc(r-&gt;pool, len); if (buf == NULL) &#123; return luaL_error(L, &quot;no memory&quot;); &#125; lua_createtable(L, 0, 4); p = buf; for (cl = r-&gt;request_body-&gt;bufs; cl; cl = cl-&gt;next) &#123; p = ngx_copy(p, cl-&gt;buf-&gt;pos, cl-&gt;buf-&gt;last - cl-&gt;buf-&gt;pos); &#125; dd(&quot;post body: %.*s&quot;, (int) len, buf); last = buf + len; // 解析请求包体 retval = ngx_http_lua_parse_args(L, buf, last, max); ngx_pfree(r-&gt;pool, buf); return retval;&#125; 如果在 NGINX 配置中将请求包体保存在临时文件中，不能使用 get_post_args 函数。同时，get_post_args 会对参数名、参数值进行 url 解码处理。 五 请求体1. ngx.req.read_body1ngx.req.read_body() 同步非阻塞的读取请求体，同步的意思是请求头读取完毕后返回，非阻塞的意思是不会将整个处理进程 hang 住，当无可读数据时会处理其他协程。实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687static intngx_http_lua_ngx_req_read_body(lua_State *L)&#123; // ... 忽略无关代码 // 参数检查 n = lua_gettop(L); if (n != 0) &#123; return luaL_error(L, &quot;expecting 0 arguments but seen %d&quot;, n); &#125; r = ngx_http_lua_get_req(L); if (r == NULL) &#123; return luaL_error(L, &quot;request object not found&quot;); &#125; r-&gt;request_body_in_single_buf = 1; r-&gt;request_body_in_persistent_file = 1; r-&gt;request_body_in_clean_file = 1;#if 1 if (r-&gt;request_body_in_file_only) &#123; r-&gt;request_body_file_log_level = 0; &#125;#endif ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module); if (ctx == NULL) &#123; return luaL_error(L, &quot;no ctx found&quot;); &#125; ngx_http_lua_check_context(L, ctx, NGX_HTTP_LUA_CONTEXT_REWRITE | NGX_HTTP_LUA_CONTEXT_ACCESS | NGX_HTTP_LUA_CONTEXT_CONTENT); coctx = ctx-&gt;cur_co_ctx; if (coctx == NULL) &#123; return luaL_error(L, &quot;no co ctx found&quot;); &#125; ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, &quot;lua start to read buffered request body&quot;); // 读请求包体 rc = ngx_http_read_client_request_body(r, ngx_http_lua_req_body_post_read);#if (nginx_version &lt; 1002006) || \\ (nginx_version &gt;= 1003000 &amp;&amp; nginx_version &lt; 1003009) r-&gt;main-&gt;count--;#endif if (rc &gt;= NGX_HTTP_SPECIAL_RESPONSE) &#123; ctx-&gt;exit_code = rc; ctx-&gt;exited = 1; ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, &quot;http read client request body returned error code %i, &quot; &quot;exitting now&quot;, rc); return lua_yield(L, 0); &#125;#if (nginx_version &gt;= 1002006 &amp;&amp; nginx_version &lt; 1003000) || \\ nginx_version &gt;= 1003009 r-&gt;main-&gt;count--; dd(&quot;decrement r-&gt;main-&gt;count: %d&quot;, (int) r-&gt;main-&gt;count);#endif if (rc == NGX_AGAIN) &#123; ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, &quot;lua read buffered request body requires I/O &quot; &quot;interruptions&quot;); ctx-&gt;waiting_more_body = 1; ctx-&gt;downstream = coctx; ngx_http_lua_cleanup_pending_operation(coctx); coctx-&gt;cleanup = ngx_http_lua_req_body_cleanup; coctx-&gt;data = r; return lua_yield(L, 0); &#125; /* rc == NGX_OK */ ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, &quot;lua has read buffered request body in a single run&quot;); return 0;&#125; 2. ngx.req.discard_body1ngx.req.discard_body() 丢弃请求包体，读取连接上的请求数据，并立即丢弃。函数是异步调用，立即返回。如果已经读取请求包体，函数无影响立即返回。实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788static intngx_http_lua_ngx_req_discard_body(lua_State *L)&#123; // ... 忽略无关代码 // 参数判断 n = lua_gettop(L); if (n != 0) &#123; return luaL_error(L, &quot;expecting 0 arguments but seen %d&quot;, n); &#125; r = ngx_http_lua_get_req(L); if (r == NULL) &#123; return luaL_error(L, &quot;request object not found&quot;); &#125; ngx_http_lua_check_fake_request(L, r); // 丢弃处理 rc = ngx_http_discard_request_body(r); if (rc == NGX_ERROR || rc &gt;= NGX_HTTP_SPECIAL_RESPONSE) &#123; return luaL_error(L, &quot;failed to discard request body&quot;); &#125; return 0;&#125;ngx_int_tngx_http_discard_request_body(ngx_http_request_t *r)&#123; // ... 忽略无关代码#if (NGX_HTTP_V2) if (r-&gt;stream) &#123; r-&gt;stream-&gt;skip_data = 1; return NGX_OK; &#125;#endif if (ngx_http_test_expect(r) != NGX_OK) &#123; return NGX_HTTP_INTERNAL_SERVER_ERROR; &#125; rev = r-&gt;connection-&gt;read; ngx_log_debug0(NGX_LOG_DEBUG_HTTP, rev-&gt;log, 0, &quot;http set discard body&quot;); if (rev-&gt;timer_set) &#123; ngx_del_timer(rev); &#125; if (r-&gt;headers_in.content_length_n &lt;= 0 &amp;&amp; !r-&gt;headers_in.chunked) &#123; return NGX_OK; &#125; size = r-&gt;header_in-&gt;last - r-&gt;header_in-&gt;pos; if (size || r-&gt;headers_in.chunked) &#123; rc = ngx_http_discard_request_body_filter(r, r-&gt;header_in); if (rc != NGX_OK) &#123; return rc; &#125; if (r-&gt;headers_in.content_length_n == 0) &#123; return NGX_OK; &#125; &#125; rc = ngx_http_read_discarded_request_body(r); if (rc == NGX_OK) &#123; r-&gt;lingering_close = 0; return NGX_OK; &#125; if (rc &gt;= NGX_HTTP_SPECIAL_RESPONSE) &#123; return rc; &#125; /* rc == NGX_AGAIN */ // 设置处理函数为丢弃请求数据 r-&gt;read_event_handler = ngx_http_discarded_request_body_handler; if (ngx_handle_read_event(rev, 0) != NGX_OK) &#123; return NGX_HTTP_INTERNAL_SERVER_ERROR; &#125; r-&gt;count++; r-&gt;discard_body = 1; return NGX_OK;&#125; 3. ngx.req.get_body_data1data = ngx.req.get_body_data() 获取存储在内存中的请求体数据，返回字符串。为了正确使用函数的功能，需要保证调用前已经使用 ngx.req.read_body 或者通过配置 lua_need_request_body 读取请求包体；同时，请求包体使用内存存储而非存储在临时文件中（通过配置实现）。 在 NGINX 配置指令中，client_body_buffer_size 配置指令用来控制接收包体内存缓冲区的大小，client_max_body_size 用来控制可以接收的最大包体限制。如果两者相同，接收的请求包体必定在内存中，使用 ngx.req.get_body_data 可以将请求数据读取出来。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960static intngx_http_lua_ngx_req_get_body_data(lua_State *L)&#123; // ... 忽略无关代码 // 参数判断 n = lua_gettop(L); if (n != 0) &#123; return luaL_error(L, &quot;expecting 0 arguments but seen %d&quot;, n); &#125; r = ngx_http_lua_get_req(L); if (r == NULL) &#123; return luaL_error(L, &quot;request object not found&quot;); &#125; ngx_http_lua_check_fake_request(L, r); // 无请求包体、请求包体存储在临时文件中，返回 nil if (r-&gt;request_body == NULL || r-&gt;request_body-&gt;temp_file || r-&gt;request_body-&gt;bufs == NULL) &#123; lua_pushnil(L); return 1; &#125; // 请求包体在一个 buf 中存储，直接使用 buf 生成 lua string cl = r-&gt;request_body-&gt;bufs; if (cl-&gt;next == NULL) &#123; len = cl-&gt;buf-&gt;last - cl-&gt;buf-&gt;pos; if (len == 0) &#123; lua_pushnil(L); return 1; &#125; lua_pushlstring(L, (char *) cl-&gt;buf-&gt;pos, len); return 1; &#125; /* found multi-buffer body */ // 需要遍历 chain，计算长度、并分配缓冲区，将所有的 buf 拷贝在一起，返回 string len = 0; for (; cl; cl = cl-&gt;next) &#123; dd(&quot;body chunk len: %d&quot;, (int) ngx_buf_size(cl-&gt;buf)); len += cl-&gt;buf-&gt;last - cl-&gt;buf-&gt;pos; &#125; if (len == 0) &#123; lua_pushnil(L); return 1; &#125; buf = (u_char *) lua_newuserdata(L, len); p = buf; for (cl = r-&gt;request_body-&gt;bufs; cl; cl = cl-&gt;next) &#123; p = ngx_copy(p, cl-&gt;buf-&gt;pos, cl-&gt;buf-&gt;last - cl-&gt;buf-&gt;pos); &#125; lua_pushlstring(L, (char *) buf, len); return 1;&#125; 4. ngx.req.get_body_file1file_name = ngx.req.get_body_file() 获得使用临时文件存储请求体的文件名。与 ngx.req.get_body_data 函数相似，需要使用 ngx.req.read_body 或 lua_need_request_body 配置读取包体。 使用 NGINX 配置指令 client_body_in_file_only 可以将请求包体保存在临时文件中。 123456789101112131415161718192021222324static intngx_http_lua_ngx_req_get_body_file(lua_State *L)&#123; // 参数判断 n = lua_gettop(L); if (n != 0) &#123; return luaL_error(L, &quot;expecting 0 arguments but seen %d&quot;, n); &#125; r = ngx_http_lua_get_req(L); if (r == NULL) &#123; return luaL_error(L, &quot;request object not found&quot;); &#125; ngx_http_lua_check_fake_request(L, r); if (r-&gt;request_body == NULL || r-&gt;request_body-&gt;temp_file == NULL) &#123; lua_pushnil(L); return 1; &#125; // 返回文件名 lua_pushlstring(L, (char *) r-&gt;request_body-&gt;temp_file-&gt;file.name.data, r-&gt;request_body-&gt;temp_file-&gt;file.name.len); return 1;&#125; 5. ngx.req.set_body_data1ngx.set_body_data(data) 使用 data 参数指定当前请求的请求体。函数调用前需要读取请求包体（包体存储在内存或者文件无所谓），函数会将原始请求清理（释放内存、请求临时文件设置清理回调函数）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154static intngx_http_lua_ngx_req_set_body_data(lua_State *L)&#123; // 参数判断 n = lua_gettop(L); if (n != 1) &#123; return luaL_error(L, &quot;expecting 1 arguments but seen %d&quot;, n); &#125; // 要设置的包体 body.data = (u_char *) luaL_checklstring(L, 1, &amp;body.len); r = ngx_http_lua_get_req(L); if (r == NULL) &#123; return luaL_error(L, &quot;request object not found&quot;); &#125; ngx_http_lua_check_fake_request(L, r); // 已经执行 discard_body if (r-&gt;discard_body) &#123; return luaL_error(L, &quot;request body already discarded asynchronously&quot;); &#125; // 未读入请求体 if (r-&gt;request_body == NULL) &#123; return luaL_error(L, &quot;request body not read yet&quot;); &#125; rb = r-&gt;request_body; tag = (ngx_buf_tag_t) &amp;ngx_http_lua_module; // 临时文件清理函数 tf = rb-&gt;temp_file; if (tf) &#123; if (tf-&gt;file.fd != NGX_INVALID_FILE) &#123; dd(&quot;cleaning temp file %.*s&quot;, (int) tf-&gt;file.name.len, tf-&gt;file.name.data); ngx_http_lua_pool_cleanup_file(r-&gt;pool, tf-&gt;file.fd); tf-&gt;file.fd = NGX_INVALID_FILE; dd(&quot;temp file cleaned: %.*s&quot;, (int) tf-&gt;file.name.len, tf-&gt;file.name.data); &#125; rb-&gt;temp_file = NULL; &#125; if (body.len == 0) &#123; // 释放原始 buf 缓冲区 if (rb-&gt;bufs) &#123; for (cl = rb-&gt;bufs; cl; cl = cl-&gt;next) &#123; if (cl-&gt;buf-&gt;tag == tag &amp;&amp; cl-&gt;buf-&gt;temporary) &#123; dd(&quot;free old request body buffer: size:%d&quot;, (int) ngx_buf_size(cl-&gt;buf)); ngx_pfree(r-&gt;pool, cl-&gt;buf-&gt;start); cl-&gt;buf-&gt;tag = (ngx_buf_tag_t) NULL; cl-&gt;buf-&gt;temporary = 0; &#125; &#125; &#125; rb-&gt;bufs = NULL; rb-&gt;buf = NULL; dd(&quot;request body is set to empty string&quot;); goto set_header; &#125; if (rb-&gt;bufs) &#123; // 释放原始缓冲区 for (cl = rb-&gt;bufs; cl; cl = cl-&gt;next) &#123; if (cl-&gt;buf-&gt;tag == tag &amp;&amp; cl-&gt;buf-&gt;temporary) &#123; dd(&quot;free old request body buffer: size:%d&quot;, (int) ngx_buf_size(cl-&gt;buf)); ngx_pfree(r-&gt;pool, cl-&gt;buf-&gt;start); cl-&gt;buf-&gt;tag = (ngx_buf_tag_t) NULL; cl-&gt;buf-&gt;temporary = 0; &#125; &#125; // 创建一块新的缓冲区，用来存储新设置的包体 rb-&gt;bufs-&gt;next = NULL; b = rb-&gt;bufs-&gt;buf; ngx_memzero(b, sizeof(ngx_buf_t)); b-&gt;temporary = 1; b-&gt;tag = tag; b-&gt;start = ngx_palloc(r-&gt;pool, body.len); if (b-&gt;start == NULL) &#123; return luaL_error(L, &quot;no memory&quot;); &#125; b-&gt;end = b-&gt;start + body.len; b-&gt;pos = b-&gt;start; b-&gt;last = ngx_copy(b-&gt;pos, body.data, body.len); &#125; else &#123; // 创建缓冲区存储新设置的包体 rb-&gt;bufs = ngx_alloc_chain_link(r-&gt;pool); if (rb-&gt;bufs == NULL) &#123; return luaL_error(L, &quot;no memory&quot;); &#125; rb-&gt;bufs-&gt;next = NULL; b = ngx_create_temp_buf(r-&gt;pool, body.len); if (b == NULL) &#123; return luaL_error(L, &quot;no memory&quot;); &#125; b-&gt;tag = tag; b-&gt;last = ngx_copy(b-&gt;pos, body.data, body.len); rb-&gt;bufs-&gt;buf = b; rb-&gt;buf = b; &#125;set_header: // 更新 content-length 头 /* override input header Content-Length (value must be null terminated) */ value.data = ngx_palloc(r-&gt;pool, NGX_SIZE_T_LEN + 1); if (value.data == NULL) &#123; return luaL_error(L, &quot;no memory&quot;); &#125; value.len = ngx_sprintf(value.data, &quot;%uz&quot;, body.len) - value.data; value.data[value.len] = &#x27;\\0&#x27;; dd(&quot;setting request Content-Length to %.*s (%d)&quot;, (int) value.len, value.data, (int) body.len); r-&gt;headers_in.content_length_n = body.len; if (r-&gt;headers_in.content_length) &#123; r-&gt;headers_in.content_length-&gt;value.data = value.data; r-&gt;headers_in.content_length-&gt;value.len = value.len; &#125; else &#123; ngx_str_set(&amp;key, &quot;Content-Length&quot;); rc = ngx_http_lua_set_input_header(r, key, value, 1 /* override */); if (rc != NGX_OK) &#123; return luaL_error(L, &quot;failed to reset the Content-Length &quot; &quot;input header&quot;); &#125; &#125; return 0;&#125; 6. ngx.req.set_body_file1ngx.req.set_body_file(file_name, auto_clean?) 使用 file_name 参数指定的文件作为请求体，可选布尔类型参数 auto_clean 用来控制释放需要自动清理文件（默认为 false）。函数调用前需要读取请求包体（包体存储在内存或者文件无所谓），函数会将原始请求清理（释放内存、请求临时文件设置清理回调函数）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234static intngx_http_lua_ngx_req_set_body_file(lua_State *L)&#123; // ... 省略无关代码 // 参数检查 n = lua_gettop(L); if (n != 1 &amp;&amp; n != 2) &#123; return luaL_error(L, &quot;expecting 1 or 2 arguments but seen %d&quot;, n); &#125; // 文件名 p = (u_char *) luaL_checklstring(L, 1, &amp;name.len); r = ngx_http_lua_get_req(L); if (r == NULL) &#123; return luaL_error(L, &quot;no request found&quot;); &#125; ngx_http_lua_check_fake_request(L, r); // 是否丢弃了请求体 if (r-&gt;discard_body) &#123; return luaL_error(L, &quot;request body already discarded asynchronously&quot;); &#125; // 是否未读取请求体 if (r-&gt;request_body == NULL) &#123; return luaL_error(L, &quot;request body not read yet&quot;); &#125; // 文件名 name.data = ngx_palloc(r-&gt;pool, name.len + 1); if (name.data == NULL) &#123; return luaL_error(L, &quot;no memory&quot;); &#125; ngx_memcpy(name.data, p, name.len); name.data[name.len] = &#x27;\\0&#x27;; // 自动清理 if (n == 2) &#123; luaL_checktype(L, 2, LUA_TBOOLEAN); clean = lua_toboolean(L, 2); &#125; else &#123; clean = 0; &#125; dd(&quot;clean: %d&quot;, (int) clean); rb = r-&gt;request_body; /* clean up existing r-&gt;request_body-&gt;bufs (if any) */ tag = (ngx_buf_tag_t) &amp;ngx_http_lua_module; if (rb-&gt;bufs) &#123; dd(&quot;XXX reusing buf&quot;); // 释放缓冲区 for (cl = rb-&gt;bufs; cl; cl = cl-&gt;next) &#123; if (cl-&gt;buf-&gt;tag == tag &amp;&amp; cl-&gt;buf-&gt;temporary) &#123; dd(&quot;free old request body buffer: size:%d&quot;, (int) ngx_buf_size(cl-&gt;buf)); ngx_pfree(r-&gt;pool, cl-&gt;buf-&gt;start); cl-&gt;buf-&gt;tag = (ngx_buf_tag_t) NULL; cl-&gt;buf-&gt;temporary = 0; &#125; &#125; rb-&gt;bufs-&gt;next = NULL; b = rb-&gt;bufs-&gt;buf; ngx_memzero(b, sizeof(ngx_buf_t)); b-&gt;tag = tag; rb-&gt;buf = NULL; &#125; else &#123; dd(&quot;XXX creating new buf&quot;); rb-&gt;bufs = ngx_alloc_chain_link(r-&gt;pool); if (rb-&gt;bufs == NULL) &#123; return luaL_error(L, &quot;no memory&quot;); &#125; rb-&gt;bufs-&gt;next = NULL; b = ngx_calloc_buf(r-&gt;pool); if (b == NULL) &#123; return luaL_error(L, &quot;no memory&quot;); &#125; b-&gt;tag = tag; rb-&gt;bufs-&gt;buf = b; rb-&gt;buf = NULL; &#125; b-&gt;last_in_chain = 1; /* just make r-&gt;request_body-&gt;temp_file a bare stub */ tf = rb-&gt;temp_file; if (tf) &#123; // 原始的临时文件清理 if (tf-&gt;file.fd != NGX_INVALID_FILE) &#123; dd(&quot;cleaning temp file %.*s&quot;, (int) tf-&gt;file.name.len, tf-&gt;file.name.data); ngx_http_lua_pool_cleanup_file(r-&gt;pool, tf-&gt;file.fd); ngx_memzero(tf, sizeof(ngx_temp_file_t)); tf-&gt;file.fd = NGX_INVALID_FILE; dd(&quot;temp file cleaned: %.*s&quot;, (int) tf-&gt;file.name.len, tf-&gt;file.name.data); &#125; &#125; else &#123; tf = ngx_pcalloc(r-&gt;pool, sizeof(ngx_temp_file_t)); if (tf == NULL) &#123; return luaL_error(L, &quot;no memory&quot;); &#125; tf-&gt;file.fd = NGX_INVALID_FILE; rb-&gt;temp_file = tf; &#125; /* read the file info and construct an in-file buf */ // 打开新的文件 ngx_memzero(&amp;of, sizeof(ngx_open_file_info_t)); of.directio = NGX_OPEN_FILE_DIRECTIO_OFF; if (ngx_http_lua_open_and_stat_file(name.data, &amp;of, r-&gt;connection-&gt;log) != NGX_OK) &#123; return luaL_error(L, &quot;%s \\&quot;%s\\&quot; failed&quot;, of.failed, name.data); &#125; dd(&quot;XXX new body file fd: %d&quot;, of.fd); tf-&gt;file.fd = of.fd; tf-&gt;file.name = name; tf-&gt;file.log = r-&gt;connection-&gt;log; tf-&gt;file.directio = 0; if (of.size == 0) &#123; // 设置自动清理，在此处已经删除了文件， // 只不过进程持有文件描述符，文件的 inode 被删除，但是文件内容还在。 if (clean) &#123; if (ngx_delete_file(name.data) == NGX_FILE_ERROR) &#123; err = ngx_errno; if (err != NGX_ENOENT) &#123; ngx_log_error(NGX_LOG_CRIT, r-&gt;connection-&gt;log, err, ngx_delete_file_n &quot; \\&quot;%s\\&quot; failed&quot;, name.data); &#125; &#125; &#125; if (ngx_close_file(of.fd) == NGX_FILE_ERROR) &#123; ngx_log_error(NGX_LOG_ALERT, r-&gt;connection-&gt;log, ngx_errno, ngx_close_file_n &quot; \\&quot;%s\\&quot; failed&quot;, name.data); &#125; r-&gt;request_body-&gt;bufs = NULL; r-&gt;request_body-&gt;buf = NULL; goto set_header; &#125; /* register file cleanup hook */ cln = ngx_pool_cleanup_add(r-&gt;pool, sizeof(ngx_pool_cleanup_file_t)); if (cln == NULL) &#123; return luaL_error(L, &quot;no memory&quot;); &#125; cln-&gt;handler = clean ? ngx_pool_delete_file : ngx_pool_cleanup_file; clnf = cln-&gt;data; clnf-&gt;fd = of.fd; clnf-&gt;name = name.data; clnf-&gt;log = r-&gt;pool-&gt;log; b-&gt;file = &amp;tf-&gt;file; if (b-&gt;file == NULL) &#123; return NGX_HTTP_INTERNAL_SERVER_ERROR; &#125; dd(&quot;XXX file size: %d&quot;, (int) of.size); b-&gt;file_pos = 0; b-&gt;file_last = of.size; b-&gt;in_file = 1; dd(&quot;buf file: %p, f:%u&quot;, b-&gt;file, b-&gt;in_file);set_header: /* override input header Content-Length (value must be null terminated) */ // 设置 content-length 头 value.data = ngx_palloc(r-&gt;pool, NGX_OFF_T_LEN + 1); if (value.data == NULL) &#123; return luaL_error(L, &quot;no memory&quot;); &#125; value.len = ngx_sprintf(value.data, &quot;%O&quot;, of.size) - value.data; value.data[value.len] = &#x27;\\0&#x27;; r-&gt;headers_in.content_length_n = of.size; if (r-&gt;headers_in.content_length) &#123; r-&gt;headers_in.content_length-&gt;value.data = value.data; r-&gt;headers_in.content_length-&gt;value.len = value.len; &#125; else &#123; ngx_str_set(&amp;key, &quot;Content-Length&quot;); rc = ngx_http_lua_set_input_header(r, key, value, 1 /* override */); if (rc != NGX_OK) &#123; return luaL_error(L, &quot;failed to reset the Content-Length &quot; &quot;input header&quot;); &#125; &#125; return 0;&#125; 7. ngx.req.init_body1ngx.req.init_body(buffer_size?) 为当前请求创建一个新的空白请求体，后续可以通过 ngx.req.append_body、 ngx.req.finish_body 向缓冲区写数据。可选参数 buffer_size 用来控制初始化缓冲区的大小，其默认值为 client_body_buffer_size 指令设置的大小。 在使用 ngx.req.append_body 写请求数据上，如果缓冲区超过了 buffer_size 大小，会将请求数据完整的写到临时文件中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192static intngx_http_lua_ngx_req_init_body(lua_State *L)&#123; // check arg number n = lua_gettop(L); if (n != 1 &amp;&amp; n != 0) &#123; return luaL_error(L, &quot;expecting 0 or 1 argument but seen %d&quot;, n); &#125; r = ngx_http_lua_get_req(L); if (r == NULL) &#123; return luaL_error(L, &quot;no request found&quot;); &#125; ngx_http_lua_check_fake_request(L, r); // should not discard body if (r-&gt;discard_body) &#123; return luaL_error(L, &quot;request body already discarded asynchronously&quot;); &#125; // should read in body data if (r-&gt;request_body == NULL) &#123; return luaL_error(L, &quot;request body not read yet&quot;); &#125; // has buffer_size param if (n == 1) &#123; num = luaL_checkinteger(L, 1); if (num &lt; 0) &#123; return luaL_error(L, &quot;bad size argument: %d&quot;, (int) num); &#125; size = (size_t) num; &#125; else &#123; // get location&#x27;s client_body_buffer_size conf size clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module); size = clcf-&gt;client_body_buffer_size; &#125; // save request data in temp file if (size == 0) &#123; r-&gt;request_body_in_file_only = 1; &#125; rb = r-&gt;request_body;#if 1 tf = rb-&gt;temp_file; if (tf) &#123; // add indenpent clean up handler original request body temp file if (tf-&gt;file.fd != NGX_INVALID_FILE) &#123; dd(&quot;cleaning temp file %.*s&quot;, (int) tf-&gt;file.name.len, tf-&gt;file.name.data); ngx_http_lua_pool_cleanup_file(r-&gt;pool, tf-&gt;file.fd); ngx_memzero(tf, sizeof(ngx_temp_file_t)); tf-&gt;file.fd = NGX_INVALID_FILE; dd(&quot;temp file cleaned: %.*s&quot;, (int) tf-&gt;file.name.len, tf-&gt;file.name.data); &#125; rb-&gt;temp_file = NULL; &#125;#endif r-&gt;request_body_in_clean_file = 1; r-&gt;headers_in.content_length_n = 0; // alloc new body data buf size rb-&gt;buf = ngx_create_temp_buf(r-&gt;pool, size); if (rb-&gt;buf == NULL) &#123; return luaL_error(L, &quot;no memory&quot;); &#125; rb-&gt;bufs = ngx_alloc_chain_link(r-&gt;pool); if (rb-&gt;bufs == NULL) &#123; return luaL_error(L, &quot;no memory&quot;); &#125; rb-&gt;bufs-&gt;buf = rb-&gt;buf; rb-&gt;bufs-&gt;next = NULL; return 0;&#125; 8. ngx.req.append_body1ngx.req.append_body(data_chunk) 将 data_chunk 参数指定的新数据块添加到当前请求的请求包体中，请求包体必须要由 ngx.req.init_body 创建（使用 ngx.req.get_body_data 虽然获取了请求包体，但是包体缓冲区链表最后指向的是 NULL 无法直接使用）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687static intngx_http_lua_ngx_req_append_body(lua_State *L)&#123; ngx_http_request_t *r; int n; ngx_http_request_body_t *rb; ngx_str_t body; size_t size, rest; size_t offset = 0; ngx_chain_t chain; ngx_buf_t buf; // check arg number n = lua_gettop(L); if (n != 1) &#123; return luaL_error(L, &quot;expecting 1 arguments but seen %d&quot;, n); &#125; // data chunk param body.data = (u_char *) luaL_checklstring(L, 1, &amp;body.len); r = ngx_http_lua_get_req(L); if (r == NULL) &#123; return luaL_error(L, &quot;no request found&quot;); &#125; ngx_http_lua_check_fake_request(L, r); // must have request_body // and requst_body_buf has buf if (r-&gt;request_body == NULL || r-&gt;request_body-&gt;buf == NULL || r-&gt;request_body-&gt;bufs == NULL) &#123; return luaL_error(L, &quot;request_body not initialized&quot;); &#125; // write into temp file if (r-&gt;request_body_in_file_only) &#123; buf.start = body.data; buf.pos = buf.start; buf.last = buf.start + body.len; buf.end = buf.last; buf.temporary = 1; chain.buf = &amp;buf; chain.next = NULL; if (ngx_http_lua_write_request_body(r, &amp;chain) != NGX_OK) &#123; return luaL_error(L, &quot;fail to write file&quot;); &#125; r-&gt;headers_in.content_length_n += body.len; return 0; &#125; // write into memory buf rb = r-&gt;request_body; rest = body.len; while (rest &gt; 0) &#123; if (rb-&gt;buf-&gt;last == rb-&gt;buf-&gt;end) &#123; if (ngx_http_lua_write_request_body(r, rb-&gt;bufs) != NGX_OK) &#123; return luaL_error(L, &quot;fail to write file&quot;); &#125; rb-&gt;buf-&gt;last = rb-&gt;buf-&gt;start; &#125; size = rb-&gt;buf-&gt;end - rb-&gt;buf-&gt;last; if (size &gt; rest) &#123; size = rest; &#125; ngx_memcpy(rb-&gt;buf-&gt;last, body.data + offset, size); rb-&gt;buf-&gt;last += size; rest -= size; offset += size; r-&gt;headers_in.content_length_n += size; &#125; return 0;&#125; 9. ngx.req.finish_body1ngx.req.finish_body() 构建请求包体完成操作，如果使用临时文件存储请求数据，将缓冲区中数据写入临时文件，更新 content-length 头。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879static intngx_http_lua_ngx_req_body_finish(lua_State *L)&#123; // ... omit n = lua_gettop(L); if (n != 0) &#123; return luaL_error(L, &quot;expecting 0 argument but seen %d&quot;, n); &#125; r = ngx_http_lua_get_req(L); if (r == NULL) &#123; return luaL_error(L, &quot;no request found&quot;); &#125; ngx_http_lua_check_fake_request(L, r); if (r-&gt;request_body == NULL || r-&gt;request_body-&gt;buf == NULL || r-&gt;request_body-&gt;bufs == NULL) &#123; return luaL_error(L, &quot;request_body not initialized&quot;); &#125; rb = r-&gt;request_body; if (rb-&gt;temp_file) &#123; /* save the last part */ if (ngx_http_lua_write_request_body(r, rb-&gt;bufs) != NGX_OK) &#123; return luaL_error(L, &quot;fail to write file&quot;); &#125; b = ngx_calloc_buf(r-&gt;pool); if (b == NULL) &#123; return luaL_error(L, &quot;no memory&quot;); &#125; b-&gt;in_file = 1; b-&gt;file_pos = 0; b-&gt;file_last = rb-&gt;temp_file-&gt;file.offset; b-&gt;file = &amp;rb-&gt;temp_file-&gt;file; if (rb-&gt;bufs-&gt;next) &#123; rb-&gt;bufs-&gt;next-&gt;buf = b; &#125; else &#123; rb-&gt;bufs-&gt;buf = b; &#125; &#125; /* override input header Content-Length (value must be null terminated) */ // update content-length header value.data = ngx_palloc(r-&gt;pool, NGX_SIZE_T_LEN + 1); if (value.data == NULL) &#123; return luaL_error(L, &quot;no memory&quot;); &#125; size = (size_t) r-&gt;headers_in.content_length_n; value.len = ngx_sprintf(value.data, &quot;%uz&quot;, size) - value.data; value.data[value.len] = &#x27;\\0&#x27;; dd(&quot;setting request Content-Length to %.*s (%d)&quot;, (int) value.len, value.data, (int) size); if (r-&gt;headers_in.content_length) &#123; r-&gt;headers_in.content_length-&gt;value.data = value.data; r-&gt;headers_in.content_length-&gt;value.len = value.len; &#125; else &#123; ngx_str_set(&amp;key, &quot;Content-Length&quot;); rc = ngx_http_lua_set_input_header(r, key, value, 1 /* override */); if (rc != NGX_OK) &#123; return luaL_error(L, &quot;failed to reset the Content-Length &quot; &quot;input header&quot;); &#125; &#125; return 0;&#125; 六 请求套接字1. ngx.req.socket1tcpsock, err = ngx.req.socket(raw) 返回与客户端之间只读的 cosocket，只支持 receive 和 receiveuntil 函数。出错返回 nil，以及错误描述字符串。 使用 cosocket 可以使用流方式读取请求包体，不过不能与 ngx.req.read_body、ngx.req.discard_body 混用（lua_need_request_body 指令同样不能使用）。不支持 chunked 传输编码。 可选布尔参数 raw 用来控制是否返回原始套接字，如果为 true 将返回全双工的套接字，支持 receive、receiveuntil、send 函数。全双工的套接字需要保证无输出缓存数据（由 ngx.say、ngx.print 产生），可以在调用 ngx.req.socket 前调用 ngx.flush(true) 刷出待输出数据。 不支持 HTTP2、SPDY 协议。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220static intngx_http_lua_req_socket(lua_State *L)&#123; // ... omit other code n = lua_gettop(L); if (n == 0) &#123; raw = 0; &#125; else if (n == 1) &#123; raw = lua_toboolean(L, 1); lua_pop(L, 1); &#125; else &#123; return luaL_error(L, &quot;expecting zero arguments, but got %d&quot;, lua_gettop(L)); &#125; r = ngx_http_lua_get_req(L); if (r != r-&gt;main) &#123; return luaL_error(L, &quot;attempt to read the request body in a &quot; &quot;subrequest&quot;); &#125;#if nginx_version &gt;= 1003009 if (!raw &amp;&amp; r-&gt;headers_in.chunked) &#123; lua_pushnil(L); lua_pushliteral(L, &quot;chunked request bodies not supported yet&quot;); return 2; &#125;#endif ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module); if (ctx == NULL) &#123; return luaL_error(L, &quot;no ctx found&quot;); &#125; ngx_http_lua_check_context(L, ctx, NGX_HTTP_LUA_CONTEXT_REWRITE | NGX_HTTP_LUA_CONTEXT_ACCESS | NGX_HTTP_LUA_CONTEXT_CONTENT); c = r-&gt;connection; if (raw) &#123;#if !defined(nginx_version) || nginx_version &lt; 1003013 lua_pushnil(L); lua_pushliteral(L, &quot;nginx version too old&quot;); return 2;#else if (r-&gt;request_body) &#123; if (r-&gt;request_body-&gt;rest &gt; 0) &#123; lua_pushnil(L); lua_pushliteral(L, &quot;pending request body reading in some &quot; &quot;other thread&quot;); return 2; &#125; &#125; else &#123; rb = ngx_pcalloc(r-&gt;pool, sizeof(ngx_http_request_body_t)); if (rb == NULL) &#123; return luaL_error(L, &quot;no memory&quot;); &#125; r-&gt;request_body = rb; &#125; if (c-&gt;buffered &amp; NGX_HTTP_LOWLEVEL_BUFFERED) &#123; lua_pushnil(L); lua_pushliteral(L, &quot;pending data to write&quot;); return 2; &#125; if (ctx-&gt;buffering) &#123; lua_pushnil(L); lua_pushliteral(L, &quot;http 1.0 buffering&quot;); return 2; &#125; if (!r-&gt;header_sent) &#123; /* prevent other parts of nginx from sending out * the response header */ r-&gt;header_sent = 1; &#125; ctx-&gt;header_sent = 1; dd(&quot;ctx acquired raw req socket: %d&quot;, ctx-&gt;acquired_raw_req_socket); if (ctx-&gt;acquired_raw_req_socket) &#123; lua_pushnil(L); lua_pushliteral(L, &quot;duplicate call&quot;); return 2; &#125; ctx-&gt;acquired_raw_req_socket = 1; r-&gt;keepalive = 0; r-&gt;lingering_close = 1;#endif &#125; else &#123; /* request body reader */ if (r-&gt;request_body) &#123; lua_pushnil(L); lua_pushliteral(L, &quot;request body already exists&quot;); return 2; &#125; if (r-&gt;discard_body) &#123; lua_pushnil(L); lua_pushliteral(L, &quot;request body discarded&quot;); return 2; &#125; dd(&quot;req content length: %d&quot;, (int) r-&gt;headers_in.content_length_n); if (r-&gt;headers_in.content_length_n &lt;= 0) &#123; lua_pushnil(L); lua_pushliteral(L, &quot;no body&quot;); return 2; &#125; // 对 except 请求头处理 if (ngx_http_lua_test_expect(r) != NGX_OK) &#123; lua_pushnil(L); lua_pushliteral(L, &quot;test expect failed&quot;); return 2; &#125; /* prevent other request body reader from running */ rb = ngx_pcalloc(r-&gt;pool, sizeof(ngx_http_request_body_t)); if (rb == NULL) &#123; return luaL_error(L, &quot;no memory&quot;); &#125; rb-&gt;rest = r-&gt;headers_in.content_length_n; r-&gt;request_body = rb; &#125; // 元表: receive、receiveuntil、send、send 元表 lua_createtable(L, 3 /* narr */, 1 /* nrec */); /* the object */ if (raw) &#123; lua_pushlightuserdata(L, &amp;ngx_http_lua_raw_req_socket_metatable_key); &#125; else &#123; lua_pushlightuserdata(L, &amp;ngx_http_lua_req_socket_metatable_key); &#125; lua_rawget(L, LUA_REGISTRYINDEX); lua_setmetatable(L, -2); // 创建 cosocket u = lua_newuserdata(L, sizeof(ngx_http_lua_socket_tcp_upstream_t)); if (u == NULL) &#123; return luaL_error(L, &quot;no memory&quot;); &#125;#if 1 lua_pushlightuserdata(L, &amp;ngx_http_lua_downstream_udata_metatable_key); lua_rawget(L, LUA_REGISTRYINDEX); lua_setmetatable(L, -2);#endif lua_rawseti(L, 1, SOCKET_CTX_INDEX); ngx_memzero(u, sizeof(ngx_http_lua_socket_tcp_upstream_t)); if (raw) &#123; u-&gt;raw_downstream = 1; &#125; else &#123; u-&gt;body_downstream = 1; &#125; coctx = ctx-&gt;cur_co_ctx; u-&gt;request = r; llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module); u-&gt;conf = llcf; // 超时时间 u-&gt;read_timeout = u-&gt;conf-&gt;read_timeout; u-&gt;connect_timeout = u-&gt;conf-&gt;connect_timeout; u-&gt;send_timeout = u-&gt;conf-&gt;send_timeout; // 清理函数 cln = ngx_http_lua_cleanup_add(r, 0); if (cln == NULL) &#123; u-&gt;ft_type |= NGX_HTTP_LUA_SOCKET_FT_ERROR; lua_pushnil(L); lua_pushliteral(L, &quot;no memory&quot;); return 2; &#125; cln-&gt;handler = ngx_http_lua_socket_tcp_cleanup; cln-&gt;data = u; u-&gt;cleanup = &amp;cln-&gt;handler; // 与客户端的网络连接 pc = &amp;u-&gt;peer; pc-&gt;log = c-&gt;log; pc-&gt;log_error = NGX_ERROR_ERR; pc-&gt;connection = c; dd(&quot;setting data to %p&quot;, u); coctx-&gt;data = u; ctx-&gt;downstream = u; // 删除读超时定时器 if (c-&gt;read-&gt;timer_set) &#123; ngx_del_timer(c-&gt;read); &#125; if (raw) &#123; if (c-&gt;write-&gt;timer_set) &#123; // 删除写超时定时器 ngx_del_timer(c-&gt;write); &#125; &#125; lua_settop(L, 1); return 1;&#125; 七 请求方法1. ngx.req.get_method1method_name = ngx.req.get_method() 获得当前请求的请求方法，返回值为字符串类型，子请求会返回相应子请求的方法。 2. ngx.req.set_method1ngx.req.set_method(method_id) 设置当前请求的请求方法，参数为数值类型。可选参数： 123456789101112131415ngx.HTTP_GETngx.HTTP_HEADngx.HTTP_PUTngx.HTTP_POSTngx.HTTP_DELETEngx.HTTP_OPTIONS (added in the v0.5.0rc24 release)ngx.HTTP_MKCOL (added in the v0.8.2 release)ngx.HTTP_COPY (added in the v0.8.2 release)ngx.HTTP_MOVE (added in the v0.8.2 release)ngx.HTTP_PROPFIND (added in the v0.8.2 release)ngx.HTTP_PROPPATCH (added in the v0.8.2 release)ngx.HTTP_LOCK (added in the v0.8.2 release)ngx.HTTP_UNLOCK (added in the v0.8.2 release)ngx.HTTP_PATCH (added in the v0.8.2 release)ngx.HTTP_TRACE (added in the v0.8.2 release) 八 请求时间1. ngx.req.start_time1secs = ngx.req.start_time() 返回当前请求创建的时间戳，浮点类型数值，精确到毫秒级。 九 内部请求判断1. ngx.req.is_internal1is_internal = ngx.req.is_internal() 判断当前请求是否是内部请求。","categories":[{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/categories/NGINX/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"Lua","slug":"Lua","permalink":"https://juzipeek.github.io/tags/Lua/"},{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/tags/NGINX/"},{"name":"OpenResty","slug":"OpenResty","permalink":"https://juzipeek.github.io/tags/OpenResty/"}]},{"title":"OpenResty Api - arg api","slug":"nginx-2019-09-08-openresty-api-arg-api","date":"2022-09-03T12:55:44.509Z","updated":"2022-09-03T12:55:44.509Z","comments":true,"path":"2022/09/03/nginx-2019-09-08-openresty-api-arg-api/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/nginx-2019-09-08-openresty-api-arg-api/","excerpt":"","text":"一 ngx.argarg api 只包含一个接口 ngx.arg，ngx.arg 可以在两个阶段使用：set_by_lua 和 body_filter_by_lua。 1. 在 set_by_lua 中使用在 set_by_lua 阶段 ngx.arg 是一个只读表，保存指令的输入参数。 1234567891011location /foo &#123; set $a 1; set $b 2; set $c 3; set_by_lua $sum &#x27;return tonumber(ngx.arg[1]) + tonumber(ngx.arg[2]) + tonumber(ngx.arg[3])&#x27; $a $b $c; echo $sum;&#125; 这是 lua-nginx-module 中的一段示例，在 set_by_lua 指令中通过 ngx.arg[1] 获得 $a 变量，ngx.arg[2] 获得 $b 变量，ngx.arg[3] 获得 $c 变量。 2. 在 body_filter_by_lua 中使用当在 body_filter_by_lua 阶段使用 ngx.arg 表时，ngx.arg[1] 持有调用 lua-nginx 模块 body_filter 函数传入的数据块，ngx.arg[2] 用来标记整个输出流是否结束（布尔类型）。在 body_filter_by_lua 阶段，ngx.arg 是可以修改的，ngx.arg[1] 设置为 nil 或者 &quot;&quot; 后续的 body_filter 将不会收的数据块。同时还可以修改 ngx.arg[2] 控制下游 body_filter 是否已经发送完毕。在 body_filter_by_lua 中只能使用 1 和 2 两个索引。 二 实现ngx.arg 是 table 类型数据，在 lua-nginx 中通过设置其 __index 和 __newindex 方法来实现获得参数、包体、设置包体和 eof 状态的功能。注册 ngx.arg 函数： 1234567891011121314151617181920static voidngx_http_lua_inject_arg_api(lua_State *L)&#123; lua_pushliteral(L, &quot;arg&quot;); lua_newtable(L); /* .arg table aka &#123;&#125; */ lua_createtable(L, 0 /* narr */, 2 /* nrec */); /* the metatable */ lua_pushcfunction(L, ngx_http_lua_param_get); lua_setfield(L, -2, &quot;__index&quot;); lua_pushcfunction(L, ngx_http_lua_param_set); lua_setfield(L, -2, &quot;__newindex&quot;); lua_setmetatable(L, -2); /* tie the metatable to param table */ dd(&quot;top: %d, type -1: %s&quot;, lua_gettop(L), luaL_typename(L, -1)); lua_rawset(L, -3); /* set ngx.arg table */&#125; __index 方法同时支持 set_by_lua 和 body_filter_by_lua 功能，用来获取参数、应答包体、应答包体 eof 状态。__newindex 方法仅支持 body_filter_by_lua 阶段，用来设置应答包体、应答包体 eof 状态。 1. set_by_lua 参数获取在 set_by_lua 中参数的获取最终实现函数是 ngx_http_lua_setby_param_get。在使用 ngx.arg[idx] 进行获取参数时所有参数以及保存在数组中，通过 ngx_http_lua_args_key 伪索引获得数组。因为在 C 中索引从 0 开始，因此传入的索引 idx 需要进行减一操作。 1234567891011121314151617181920212223242526272829intngx_http_lua_setby_param_get(lua_State *L)&#123; int idx; int n; ngx_http_variable_value_t *v; idx = luaL_checkint(L, 2); idx--; /* get number of args from globals */ lua_getglobal(L, ngx_http_lua_nargs_key); n = (int) lua_tointeger(L, -1); // 取出参数数组 v, v 中保存所有的参数，索引从零开始，所以一开始 idx 进行减一操作 /* get args from globals */ lua_getglobal(L, ngx_http_lua_args_key); v = lua_touserdata(L, -1); if (idx &lt; 0 || idx &gt; n - 1) &#123; lua_pushnil(L); &#125; else &#123; // 取出相应索引的值，放在栈顶 lua_pushlstring(L, (const char *) (v[idx].data), v[idx].len); &#125; return 1;&#125; 2. body_filter_by_lua 获取数据在 body_filter_by_lua 中获取应答包体、应答 eof 状态的实现函数是 ngx_http_lua_body_filter_param_get。函数仅允许使用 1 或 2 作为索引，当索引为 2 时仅需要判断输出链 ngx_chain_t 类型数据是否为空即可返还布尔类型应答值以标识应答是否结束；当索引为 1 时需要遍历输出链，计算长度，并将其拷贝到缓冲区进行返回。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// body filter 阶段获取待输出数据// ngx.arg[1] ngx.arg[2]intngx_http_lua_body_filter_param_get(lua_State *L)&#123; u_char *data, *p; size_t size; ngx_chain_t *cl; ngx_buf_t *b; int idx; ngx_chain_t *in; idx = luaL_checkint(L, 2); dd(&quot;index: %d&quot;, idx); // 仅允许使用 ngx.arg[1] ngx.arg[2] if (idx != 1 &amp;&amp; idx != 2) &#123; lua_pushnil(L); return 1; &#125; // 取出输出链 lua_getglobal(L, ngx_http_lua_chain_key); in = lua_touserdata(L, -1); // 判断是否已经结束（eof） if (idx == 2) &#123; /* asking for the eof argument */ for (cl = in; cl; cl = cl-&gt;next) &#123; if (cl-&gt;buf-&gt;last_buf || cl-&gt;buf-&gt;last_in_chain) &#123; lua_pushboolean(L, 1); return 1; &#125; &#125; lua_pushboolean(L, 0); return 1; &#125; // 访问数据 /* idx == 1 */ size = 0; if (in == NULL) &#123; /* being a cleared chain on the Lua land */ lua_pushliteral(L, &quot;&quot;); return 1; &#125; if (in-&gt;next == NULL) &#123; dd(&quot;seen only single buffer&quot;); b = in-&gt;buf; lua_pushlstring(L, (char *) b-&gt;pos, b-&gt;last - b-&gt;pos); return 1; &#125; dd(&quot;seen multiple buffers&quot;); for (cl = in; cl; cl = cl-&gt;next) &#123; b = cl-&gt;buf; size += b-&gt;last - b-&gt;pos; if (b-&gt;last_buf || b-&gt;last_in_chain) &#123; break; &#125; &#125; data = (u_char *) lua_newuserdata(L, size); for (p = data, cl = in; cl; cl = cl-&gt;next) &#123; b = cl-&gt;buf; p = ngx_copy(p, b-&gt;pos, b-&gt;last - b-&gt;pos); if (b-&gt;last_buf || b-&gt;last_in_chain) &#123; break; &#125; &#125; lua_pushlstring(L, (char *) data, size); return 1;&#125; 3. body_filter_by_lua 设置数据在 body_filter_by_lua 中设置应答包体、应答 eof 状态的实现函数是 ngx_http_lua_body_filter_param_set。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208intngx_http_lua_body_filter_param_set(lua_State *L, ngx_http_request_t *r, ngx_http_lua_ctx_t *ctx)&#123; int type; int idx; int found; u_char *data; size_t size; unsigned last; unsigned flush = 0; ngx_buf_t *b; ngx_chain_t *cl; ngx_chain_t *in; idx = luaL_checkint(L, 2); dd(&quot;index: %d&quot;, idx); if (idx != 1 &amp;&amp; idx != 2) &#123; return luaL_error(L, &quot;bad index: %d&quot;, idx); &#125; // 设置 eof 状态 if (idx == 2) &#123; /* overwriting the eof flag */ last = lua_toboolean(L, 3); lua_getglobal(L, ngx_http_lua_chain_key); in = lua_touserdata(L, -1); lua_pop(L, 1); // 需要设置 eof == true，标记应答结束 if (last) &#123; ctx-&gt;seen_last_in_filter = 1; /* the &quot;in&quot; chain cannot be NULL and we set the &quot;last_buf&quot; or * &quot;last_in_chain&quot; flag in the last buf of &quot;in&quot; */ for (cl = in; cl; cl = cl-&gt;next) &#123; if (cl-&gt;next == NULL) &#123; if (r == r-&gt;main) &#123; cl-&gt;buf-&gt;last_buf = 1; &#125; else &#123; cl-&gt;buf-&gt;last_in_chain = 1; &#125; break; &#125; &#125; &#125; else &#123; // 需要设置 eof == false，去除应答结束标记 /* last == 0 */ found = 0; for (cl = in; cl; cl = cl-&gt;next) &#123; b = cl-&gt;buf; if (b-&gt;last_buf) &#123; b-&gt;last_buf = 0; found = 1; &#125; if (b-&gt;last_in_chain) &#123; b-&gt;last_in_chain = 0; found = 1; &#125; if (found &amp;&amp; b-&gt;last == b-&gt;pos &amp;&amp; !ngx_buf_in_memory(b)) &#123; /* make it a special sync buf to make * ngx_http_write_filter_module happy. */ b-&gt;sync = 1; &#125; &#125; ctx-&gt;seen_last_in_filter = 0; &#125; return 0; &#125; // 应答包体处理 /* idx == 1, overwriting the chunk data */ type = lua_type(L, 3); switch (type) &#123; case LUA_TSTRING: case LUA_TNUMBER: data = (u_char *) lua_tolstring(L, 3, &amp;size); break; case LUA_TNIL: /* discard the buffers */ // 从 _G 中获取 __ngx_cl 到栈顶 lua_getglobal(L, ngx_http_lua_chain_key); /* key val */ in = lua_touserdata(L, -1); lua_pop(L, 1); last = 0; for (cl = in; cl; cl = cl-&gt;next) &#123; b = cl-&gt;buf; if (b-&gt;flush) &#123; flush = 1; &#125; if (b-&gt;last_in_chain || b-&gt;last_buf) &#123; last = 1; &#125; dd(&quot;mark the buf as consumed: %d&quot;, (int) ngx_buf_size(b)); b-&gt;pos = b-&gt;last; &#125; /* cl == NULL */ goto done; case LUA_TTABLE: size = ngx_http_lua_calc_strlen_in_table(L, 3 /* index */, 3 /* arg */, 1 /* strict */); data = NULL; break; default: return luaL_error(L, &quot;bad chunk data type: %s&quot;, lua_typename(L, type)); &#125; lua_getglobal(L, ngx_http_lua_chain_key); in = lua_touserdata(L, -1); lua_pop(L, 1); last = 0; for (cl = in; cl; cl = cl-&gt;next) &#123; b = cl-&gt;buf; if (b-&gt;flush) &#123; flush = 1; &#125; if (b-&gt;last_buf || b-&gt;last_in_chain) &#123; last = 1; &#125; dd(&quot;mark the buf as consumed: %d&quot;, (int) ngx_buf_size(cl-&gt;buf)); cl-&gt;buf-&gt;pos = cl-&gt;buf-&gt;last; &#125; /* cl == NULL */ if (size == 0) &#123; goto done; &#125; cl = ngx_http_lua_chain_get_free_buf(r-&gt;connection-&gt;log, r-&gt;pool, &amp;ctx-&gt;free_bufs, size); if (cl == NULL) &#123; return luaL_error(L, &quot;no memory&quot;); &#125; // 拷贝应答内容到发送缓冲区 if (type == LUA_TTABLE) &#123; cl-&gt;buf-&gt;last = ngx_http_lua_copy_str_in_table(L, 3, cl-&gt;buf-&gt;last); &#125; else &#123; cl-&gt;buf-&gt;last = ngx_copy(cl-&gt;buf-&gt;pos, data, size); &#125;done:// 更新 last_buf 标记 if (last || flush) &#123; if (cl == NULL) &#123; cl = ngx_http_lua_chain_get_free_buf(r-&gt;connection-&gt;log, r-&gt;pool, &amp;ctx-&gt;free_bufs, 0); if (cl == NULL) &#123; return luaL_error(L, &quot;no memory&quot;); &#125; &#125; if (last) &#123; ctx-&gt;seen_last_in_filter = 1; if (r == r-&gt;main) &#123; cl-&gt;buf-&gt;last_buf = 1; &#125; else &#123; cl-&gt;buf-&gt;last_in_chain = 1; &#125; &#125; if (flush) &#123; cl-&gt;buf-&gt;flush = 1; &#125; &#125; // 更新 _G 中 __ngx_cl 值为最新值 lua_pushlightuserdata(L, cl); lua_setglobal(L, ngx_http_lua_chain_key); return 0;&#125; 在 body_filter_by_lua 中通过 ngx.arg[1] 设置应答包体时可以使用 table 作为值，但是 table 必须是数组类型，非哈希表。","categories":[{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/categories/NGINX/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"Lua","slug":"Lua","permalink":"https://juzipeek.github.io/tags/Lua/"},{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/tags/NGINX/"},{"name":"OpenResty","slug":"OpenResty","permalink":"https://juzipeek.github.io/tags/OpenResty/"}]},{"title":"ngx_http_dyups_module 模块","slug":"nginx-2019-08-12-ngx-http-dyups-module","date":"2022-09-03T12:55:44.508Z","updated":"2022-09-03T12:55:44.508Z","comments":true,"path":"2022/09/03/nginx-2019-08-12-ngx-http-dyups-module/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/nginx-2019-08-12-ngx-http-dyups-module/","excerpt":"","text":"一 功能ngx_http_dyups_module 模块能够在不进行 reload 的情况下动态更新 upstream 配置。 二 指令1. dyups_interface123Syntax: dyups_interfaceDefault: `none`Context: `loc` 使用当前 location 处理 upstream&#123;&#125; 的查看、添加、删除操作。 2. dyups_read_msg_timeout123Syntax: dyups_read_msg_timeout `time`Default: `1s`Context: `main` worker 进程读取共享内存中操作指令的间隔时间。dyups 模块中每个 worker 收到外部指令后需要将指令同步到共享内存，其他 worker 将指令处理一遍，同步各个 worker 间的状态。 3. dyups_shm_zone_size123Syntax: dyups_shm_zone_size `size`Default: `2MB`Context: `main` dyups 模块使用共享内存保存指令，dyups_shm_zone_size 指令设置共享内存大小。 4. dyups_trylock123Syntax: dyups_trylock `on | off`Default: `off`Context: `main` 5. dyups_read_msg_log123Syntax: dyups_read_msg_log `on | off`Default: `off`Context: `main` 控制 dyups 模块执行指令是否输出日志。 三 调用接口当使用 dyups_interface 配置 location 处理指令后，当前 location 可以处理 restful 类型的指令。 GET 请求1. 查看主机详细信息路径：/detail输出所有的 upstream&#123;&#125; 以及其中的 server。 2. 查看所有 upstrem&#123;&#125;路径： /list输出所有的 upstream&#123;&#125;。 3. 查看单个 upstream 信息路径：/upstream/name根据 upstream&#123;&#125; 的名字查找其配置，输出其中的所有 server。 POST 请求1. 更新 upstream 中 server 列表路径：/upstream/name更新 name 指定的 upstream&#123;&#125; 中的 server 列表。会创建一个新的 upstream&#123;&#125; 配置，使用 body 中指定的 server。body 内数据格式为： 1server ip:port; DELETE1. 删除某个 upstream路径：/upstream/name删除由 name 指定的 upstream&#123;&#125;。会将 upstream&#123;&#125; 的 dyups 配置标记为 deleting，待引用计数为零时标记为 deleted，之后就可以重用共享内存。 四 安装测试1. 安装1234567cd nginx-1.17.2./configure \\--add-module=/opt/src/tengine-2.3.1/modules/ngx_http_upstream_dyups_modulemakemake install 2. 配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# vi $NGINX_PATH/conf/dyups/dyups.conf#user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;; access_log logs/access.log main; dyups_upstream_conf dyups_upstream.conf; include dyups_upstream.conf; server &#123; listen 8080; # location 会根据 host 变量做代理，默认 host 变量会从请求域名、从请求头 host 中取值 location / &#123; proxy_pass http://$host; &#125; &#125; server &#123; listen 8088; location / &#123; return 200 &quot;8088&quot;; &#125; &#125; server &#123; listen 8089; location / &#123; return 200 &quot;8089&quot;; &#125; &#125; server &#123; listen 8081; # dyups 操作接口 location / &#123; dyups_interface; &#125; &#125;&#125; 12345678# vi $NGINX_PATH/conf/dyup/dyup_upstream.confupstream host1 &#123; server 127.0.0.1:8088;&#125;upstream host2 &#123; server 127.0.0.1:8089;&#125; 3. 测试命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051sudo /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/dyups/dyups.conf# 设置 host 头为 host1 或 host2，使用 host 变量做反向代理$curl -H &quot;host: host1&quot; 127.0.0.1:80808088$curl -H &quot;host: host2&quot; 127.0.0.1:80808089# 查看所有 upstream&#123;&#125; 的详细信息$curl 127.0.0.1:8081/detailhost1server 127.0.0.1:8088 weight=1 max_conns=0 max_fails=1 fail_timeout=10 backup=0 down=0host2server 127.0.0.1:8089 weight=1 max_conns=0 max_fails=1 fail_timeout=10 backup=0 down=0# 动态添加 upstream&#123;&#125;# 添加 dyhost upstream 块，里面有两个 servercurl -d &quot;server 127.0.0.1:8089;server 127.0.0.1:8088;&quot; 127.0.0.1:8081/upstream/dyhost# 再次查看所有 upstream&#123;&#125; 的详细信息$curl 127.0.0.1:8081/detailhost1server 127.0.0.1:8088 weight=1 max_conns=0 max_fails=1 fail_timeout=10 backup=0 down=0host2server 127.0.0.1:8089 weight=1 max_conns=0 max_fails=1 fail_timeout=10 backup=0 down=0dyhostserver 127.0.0.1:8089 weight=1 max_conns=0 max_fails=1 fail_timeout=10 backup=0 down=0server 127.0.0.1:8088 weight=1 max_conns=0 max_fails=1 fail_timeout=10 backup=0 down=0# 访问 dyhost 后端$curl -H &quot;host: dyhost&quot; 127.0.0.1:80808089$curl -H &quot;host: dyhost&quot; 127.0.0.1:80808088# 更新 dyhost upstream&#123;&#125;$curl -d &quot;server 127.0.0.1:8089;&quot; 127.0.0.1:8081/upstream/dyhost# 再次查看所有 upstream&#123;&#125; 的详细信息$curl 127.0.0.1:8081/detailhost1server 127.0.0.1:8088 weight=1 max_conns=0 max_fails=1 fail_timeout=10 backup=0 down=0host2server 127.0.0.1:8089 weight=1 max_conns=0 max_fails=1 fail_timeout=10 backup=0 down=0dyhostserver 127.0.0.1:8089 weight=1 max_conns=0 max_fails=1 fail_timeout=10 backup=0 down=0 五 实现dyups 模块提供 dyups_interface 指令将 location 做为 dyups 对外接口，提供对 upstream 的查看、新增、删除管理功能。在 dyups 内部，使用定时器、基于共享内存的消息队列实现 upstream 的同步。 全局变量 ngx_http_dyups_api_enable 用来标识当前进程是否启用 dyups 功能。ngx_http_dyups_deleted_upstream 是 postconfig 阶段创建的冗余配置，在执行删除指令时会将 upstream 的配置更新为 ngx_http_dyups_deleted_upstream，非共享内存。ngx_http_dyups_shm_generation 用来作为 dyups 的代，在共享初始化时使用。每次进行 reload 操作，ngx_http_dyups_shm_generation 会进行累加，reload 创建的进程会使用当前“代”的共享内存进行处理。ngx_dyups_global_ctx 作为全局配置用来存储 slab、共享内存配置、消息处理定时器，在共享内存初始化、进程初始化时进行初始化。 1. 共享内存在 dyups 代中并没有对某个”代”共享内存的清理工作（reload 时会释放内存），其实观察共享内存的初始化回调可以发现 dyups 并没有在共享内存上创建附加的管理信息， ngx_dyups_global_ctx 是进程中的变量，通过 shpool 使用共享内存。在共享内存中除了 sh 之外，只有消息队列中的消息。在消息被销毁是会将内存归还共享内存。 12345678910111213141516171819202122232425262728293031323334353637383940414243// 共享内存初始化函数static ngx_int_tngx_http_dyups_init_shm_zone(ngx_shm_zone_t *shm_zone, void *data)&#123; ngx_slab_pool_t *shpool; ngx_dyups_shctx_t *sh; // 直接引用共享内存作为 slab shpool = (ngx_slab_pool_t *) shm_zone-&gt;shm.addr; // 进程状态数组 sh = ngx_slab_alloc(shpool, sizeof(ngx_dyups_shctx_t)); if (sh == NULL) &#123; return NGX_ERROR; &#125; ngx_dyups_global_ctx.sh = sh; ngx_dyups_global_ctx.shpool = shpool; ngx_queue_init(&amp;sh-&gt;msg_queue); sh-&gt;version = 0; sh-&gt;status = NULL; return NGX_OK;&#125;// 消息销毁static voidngx_dyups_destroy_msg(ngx_slab_pool_t *shpool, ngx_dyups_msg_t *msg)&#123; if (msg-&gt;pid) &#123; ngx_slab_free_locked(shpool, msg-&gt;pid); &#125; if (msg-&gt;name.data) &#123; ngx_slab_free_locked(shpool, msg-&gt;name.data); &#125; if (msg-&gt;content.data) &#123; ngx_slab_free_locked(shpool, msg-&gt;content.data); &#125; ngx_slab_free_locked(shpool, msg);&#125; 2. list/detail/upstream 请求处理list/detail/upstram 用来查看 dyups 中 upstream、server 的信息。在调用指令时先进行消息处理，待状态同步后才进行请求处理。 3. 删除 upstream 请求处理删除操作通过 ngx_dyups_delete_upstream 函数实现，函数流程： 1234567891011121314151617181920212223---------------| shpool 加锁 |--------------- | V-------------------| 处理消息队列中消息 |------------------- | V-------------------| 执行 delete 操作 |------------------- | V---------------------------| 发送 delete 指令到消息队列 |--------------------------- | V------------------| 处理结束 |------------------ 删除操作只是将当前 upstream 的配置（ngx_http_upstream_srv_conf_t）设置为一个无存活 server 的配置。如果开启健康检查，会调用健康检查模块的函数，将原先配置中的 server 从健康检查中删除。在发送消息时，消息发送方会将消息的进程数组中第一个槽标记为当前进程 pid，可以通过此值寻找消息发送方。 在执行删除 upstream 指令时并未立即删除 upstream 的内存配置，只是将其标记为 NGX_DYUPS_DELETING 状态。这是因为当前内存可能被请求使用，只有在当前内存的引用计数为零时才会删除。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// upstream 查找static ngx_http_dyups_srv_conf_t *ngx_dyups_find_upstream(ngx_str_t *name, ngx_int_t *idx)&#123; ngx_uint_t i; ngx_http_dyups_srv_conf_t *duscfs, *duscf, *duscf_del; ngx_http_dyups_main_conf_t *dumcf; ngx_http_upstream_srv_conf_t *uscf; dumcf = ngx_http_cycle_get_module_main_conf(ngx_cycle, ngx_http_dyups_module); *idx = -1; duscf_del = NULL; ngx_log_debug0(NGX_LOG_DEBUG_HTTP, ngx_cycle-&gt;log, 0, &quot;[dyups] find dynamic upstream&quot;); duscfs = dumcf-&gt;dy_upstreams.elts; for (i = 0; i &lt; dumcf-&gt;dy_upstreams.nelts; i++) &#123; duscf = &amp;duscfs[i]; if (!duscf-&gt;dynamic) &#123; continue; &#125; // 对 NGX_DYUPS_DELETING 状态的 upstream 进行处理 if (duscf-&gt;deleted == NGX_DYUPS_DELETING) &#123; ngx_log_error(NGX_LOG_DEBUG, ngx_cycle-&gt;log, 0, &quot;[dyups] find upstream idx: %ui ref: %ui &quot; &quot;on %V deleting&quot;, i, *(duscf-&gt;ref), &amp;duscf-&gt;upstream-&gt;host); // 如果引用计数变为零，则标记为 NGX_DYUPS_DELETED 状态 if (*(duscf-&gt;ref) == 0) &#123; ngx_log_error(NGX_LOG_INFO, ngx_cycle-&gt;log, 0, &quot;[dyups] free dynamic upstream in find upstream&quot; &quot; %ui&quot;, duscf-&gt;idx); duscf-&gt;deleted = NGX_DYUPS_DELETED; // 释放内存 if (duscf-&gt;pool) &#123; ngx_destroy_pool(duscf-&gt;pool); duscf-&gt;pool = NULL; &#125; &#125; &#125; // NGX_DYUPS_DELETING 状态的不应该再使用 if (duscf-&gt;deleted == NGX_DYUPS_DELETING) &#123; continue; &#125; // 如果找不到则使用 NGX_DYUPS_DELETED 状态的配置 if (duscf-&gt;deleted == NGX_DYUPS_DELETED) &#123; *idx = i; duscf_del = duscf; continue; &#125; uscf = duscf-&gt;upstream; // 不相同，继续 if (uscf-&gt;host.len != name-&gt;len || ngx_strncasecmp(uscf-&gt;host.data, name-&gt;data, uscf-&gt;host.len) != 0) &#123; continue; &#125; *idx = i; return duscf; &#125; return duscf_del;&#125; 4. 更新 upstream 请求处理更新操作通过 ngx_http_dyups_body_handler 函数实现，因为更新操作需要根据包体中的信息进行更新，因此首先要将请求包体信息读出。函数流程： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859---------------| 读取请求包体 |--------------- | V---------------| 执行更新操作 |--------------- | V---------------| shpool 加锁 |--------------- | V-------------------| 处理消息队列中消息 |------------------- | V---------------------------------------------------| 使用假的 upstream 名进行更新操作，验证请求数据是否正确 |--------------------------------------------------- | V--------------| 执行更新操作 |-------------- | V---------------------------| 删除旧的 upstream 配置 |--------------------------- | V---------------------------| 创建新的 upstream 配置 |--------------------------- | V---------------------------| 包体中 server 配置创建 |--------------------------- | V----------------------------------------------| 对新创建的 upstream 进行初始化 || 遍历所有的 HTTP 模块调用 create_srv_conf 函数 |---------------------------------------------- | V---------------------------| 发送 ADD 指令到消息队列 |--------------------------- | V------------------| 处理结束 |------------------ 5. 消息队列基于共享内存的消息队列在共享内存初始化回调中创建，此时消息队列为空，在处理删除、新增指令时会向消息队列新增消息，消息被 worker 处理过之后会增加处理次数，如果次数达到 worker_process 数，则消息会被删除。消息处理锁：shpool-&gt;mutex。 在 worker 中，当消息处理定时器触发时会遍历消息队列，对其中的消息进行处理。每个 worker 会处理当前”代”中的所有消息，如果消息已经被所有 worker 处理过，会删除消息。 在进程退出时销毁所有动态配置的 pool（基于内存，非共享内存），共享内存并未清理。这是因为创建的 timer 是不可取消事件，在 worker 退出时会阻止进程退出。在消息处理定时器触发，消息处理函数在将所有消息处理完毕后会添加定时器时，此时会判断当前进程的状态，如果进程为退出状态则不添加定时器，此时进程才会退出，保证了正常状况下共享内存能够被释放。 6. upstream 引用计数为了保证 upstream 内存能够正确回收同时又不会影响现有请求，dyups 模块使用引用计数机制在使用 upstream 时增加 upstream 的引用计数，在连接上注册清理函数，当连接关闭时引用计数减少。 dyups 模块在向 upstream 添加 server 时会对 peer.init 函数进行封装，每次成功建立连接后增加 upstream 的引用计数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// 向 upstream 增加 serverstatic ngx_int_tngx_dyups_add_server(ngx_http_dyups_srv_conf_t *duscf, ngx_buf_t *buf)&#123; ngx_conf_t cf; ngx_http_upstream_init_pt init; ngx_http_upstream_srv_conf_t *uscf; ngx_http_dyups_upstream_srv_conf_t *dscf; uscf = duscf-&gt;upstream; if (uscf-&gt;servers == NULL) &#123; uscf-&gt;servers = ngx_array_create(duscf-&gt;pool, 4, sizeof(ngx_http_upstream_server_t)); if (uscf-&gt;servers == NULL) &#123; return NGX_ERROR; &#125; &#125; ngx_memzero(&amp;cf, sizeof(ngx_conf_t)); cf.name = &quot;dyups_init_module_conf&quot;; cf.pool = duscf-&gt;pool; cf.cycle = (ngx_cycle_t *) ngx_cycle; cf.module_type = NGX_HTTP_MODULE; cf.cmd_type = NGX_HTTP_UPS_CONF; cf.log = ngx_cycle-&gt;log; cf.ctx = duscf-&gt;ctx; cf.args = ngx_array_create(duscf-&gt;pool, 10, sizeof(ngx_str_t)); if (cf.args == NULL) &#123; return NGX_ERROR; &#125; if (ngx_dyups_parse_upstream(&amp;cf, buf) != NGX_CONF_OK) &#123; return NGX_ERROR; &#125; ngx_memzero(&amp;cf, sizeof(ngx_conf_t)); cf.name = &quot;dyups_init_upstream&quot;; cf.cycle = (ngx_cycle_t *) ngx_cycle; cf.pool = duscf-&gt;pool; cf.module_type = NGX_HTTP_MODULE; cf.cmd_type = NGX_HTTP_MAIN_CONF; cf.log = ngx_cycle-&gt;log; cf.ctx = duscf-&gt;ctx; // 对新创建的 upstream&#123;&#125; 进行 init 操作 init = uscf-&gt;peer.init_upstream ? uscf-&gt;peer.init_upstream: ngx_http_upstream_init_round_robin; if (init(&amp;cf, uscf) != NGX_OK) &#123; return NGX_ERROR; &#125;#if (T_NGX_HTTP_UPSTREAM_RANDOM) &#123; ngx_http_upstream_rr_peers_t *peers, *backup; /* add init_number initialization */ peers = uscf-&gt;peer.data; peers-&gt;init_number = ngx_random() % peers-&gt;number; backup = peers-&gt;next; if (backup) &#123; backup-&gt;init_number = ngx_random() % backup-&gt;number; &#125; &#125;#endif dscf = uscf-&gt;srv_conf[ngx_http_dyups_module.ctx_index]; // 保存原始的 peer.init 回调 dscf-&gt;init = uscf-&gt;peer.init; // 对 peer.init 阶段进行封装，连接建立时增加 upstream 引用计数 uscf-&gt;peer.init = ngx_http_dyups_init_peer; return NGX_OK;&#125; 引用计数增加操作： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 对原始 upstream 操作封装static ngx_int_tngx_http_dyups_init_peer(ngx_http_request_t *r, ngx_http_upstream_srv_conf_t *us)&#123; ngx_int_t rc; ngx_pool_cleanup_t *cln; ngx_http_dyups_ctx_t *ctx; ngx_http_dyups_upstream_srv_conf_t *dscf; dscf = us-&gt;srv_conf[ngx_http_dyups_module.ctx_index]; rc = dscf-&gt;init(r, us); ngx_log_debug1(NGX_LOG_DEBUG_HTTP, ngx_cycle-&gt;log, 0, &quot;[dyups] dynamic upstream init peer: %i&quot;, rc); if (rc != NGX_OK) &#123; return rc; &#125; ctx = ngx_pcalloc(r-&gt;pool, sizeof(ngx_http_dyups_ctx_t)); if (ctx == NULL) &#123; return NGX_ERROR; &#125; ctx-&gt;scf = dscf; ctx-&gt;data = r-&gt;upstream-&gt;peer.data; ctx-&gt;get = r-&gt;upstream-&gt;peer.get; ctx-&gt;free = r-&gt;upstream-&gt;peer.free; r-&gt;upstream-&gt;peer.data = ctx; // 修改连接的 peer.get peer.free 回调 // get 操作并无特殊处理，但是 free 操作需要考虑连接池功能 r-&gt;upstream-&gt;peer.get = ngx_http_dyups_get_peer; r-&gt;upstream-&gt;peer.free = ngx_http_dyups_free_peer;#if (NGX_HTTP_SSL) r-&gt;upstream-&gt;peer.set_session = ngx_http_dyups_set_peer_session; r-&gt;upstream-&gt;peer.save_session = ngx_http_dyups_save_peer_session;#endif cln = ngx_pool_cleanup_add(r-&gt;pool, 0); if (cln == NULL) &#123; return NGX_ERROR; &#125; // 增加 upstream 引用计数 dscf-&gt;ref++; // 注册连接关闭的清理函数：减少 upstream 引用计数 cln-&gt;handler = ngx_http_dyups_clean_request; cln-&gt;data = &amp;dscf-&gt;ref; return NGX_OK;&#125;","categories":[{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/categories/NGINX/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/tags/NGINX/"}]},{"title":"OpenResty Api - output api","slug":"nginx-2019-09-01-openresty-api-output-api","date":"2022-09-03T12:55:44.508Z","updated":"2022-09-03T12:55:44.509Z","comments":true,"path":"2022/09/03/nginx-2019-09-01-openresty-api-output-api/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/nginx-2019-09-01-openresty-api-output-api/","excerpt":"","text":"一 概述output api 主要用于向客户端发送应答数据，或者对应答进行控制。输出函数：ngx.send_headers、ngx.print、ngx.say ；响应控制函数：ngx.flush、ngx.eof。 二 输出函数1. ngx.send_headers函数原型： 1ok, err = ngx.send_headers() 允许介入的阶段：rewrite_by_lua_*、access_by_lua_*、content_by_lua_*。 向客户端发送应答头。在发送响应时需要对 content type、content length 进行特别关注，如果这两者错误会直接导致客户端解析异常。lua_nginx_module 会调用 ngx_http_lua_set_content_type 函数对 content type 进行特殊处理。在对 conten_type 进行特殊处理时最终会调用 ngx_http_set_content_type 函数，首先根据请求文件扩展名获得对于的 content type，如果失败则使用默认 content type 设置。其实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758ngx_int_tngx_http_set_content_type(ngx_http_request_t *r)&#123; u_char c, *exten; ngx_str_t *type; ngx_uint_t i, hash; ngx_http_core_loc_conf_t *clcf; if (r-&gt;headers_out.content_type.len) &#123; return NGX_OK; &#125; clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module); // 请求文件的扩展名，例如请求行：GET /index.html HTTP/1.1，扩展名为 html if (r-&gt;exten.len) &#123; hash = 0; // 将扩展名转换为小写计算 hash key for (i = 0; i &lt; r-&gt;exten.len; i++) &#123; c = r-&gt;exten.data[i]; if (c &gt;= &#x27;A&#x27; &amp;&amp; c &lt;= &#x27;Z&#x27;) &#123; exten = ngx_pnalloc(r-&gt;pool, r-&gt;exten.len); if (exten == NULL) &#123; return NGX_ERROR; &#125; hash = ngx_hash_strlow(exten, r-&gt;exten.data, r-&gt;exten.len); r-&gt;exten.data = exten; break; &#125; // ngx_hash 会累加 hash 值 hash = ngx_hash(hash, c); &#125; // 根据 mime 表查找 conten type type = ngx_hash_find(&amp;clcf-&gt;types_hash, hash, r-&gt;exten.data, r-&gt;exten.len); if (type) &#123; r-&gt;headers_out.content_type_len = type-&gt;len; r-&gt;headers_out.content_type = *type; return NGX_OK; &#125; &#125; // 设置默认 content type r-&gt;headers_out.content_type_len = clcf-&gt;default_type.len; r-&gt;headers_out.content_type = clcf-&gt;default_type; return NGX_OK;&#125; 对于 content_length 头，如果未设置过应答 header（调用 ngx.resp.header[&#39;new_header&#39;] = &#39;value&#39; 函数），需要将 content_length 头清除，使用 chrunked 编码方式传输。 **调用 ngx.send_headers 后会进入 header filter 阶段，此函数的实际输出是调用 ngx_http_top_header_filter**。 2. ngx.print函数原型： 1ok, err = ngx.print(...) 允许介入阶段：rewrite_by_lua_*、access_by_lua_*、content_by_lua_*。 ngx.print 会调用 ngx_http_lua_ngx_echo 函数进行应答 ngx_http_top_body_filter 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214static intngx_http_lua_ngx_echo(lua_State *L, unsigned newline)&#123; ngx_http_request_t *r; ngx_http_lua_ctx_t *ctx; const char *p; size_t len; size_t size; ngx_buf_t *b; ngx_chain_t *cl; ngx_int_t rc; int i; int nargs; int type; const char *msg; r = ngx_http_lua_get_req(L); if (r == NULL) &#123; return luaL_error(L, &quot;no request object found&quot;); &#125; ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module); if (ctx == NULL) &#123; return luaL_error(L, &quot;no request ctx found&quot;); &#125; // 当前阶段检测，判断是否在 rewrite、access、content 阶段 // NGX_HTTP_LUA_CONTEXT_REWRITE 等几个宏是 lua-nginx 模块定义 ngx_http_lua_check_context(L, ctx, NGX_HTTP_LUA_CONTEXT_REWRITE | NGX_HTTP_LUA_CONTEXT_ACCESS | NGX_HTTP_LUA_CONTEXT_CONTENT); if (ctx-&gt;acquired_raw_req_socket) &#123; lua_pushnil(L); // 状态标识 lua_pushliteral(L, &quot;raw request socket acquired&quot;); // 错误信息字符串 return 2; // 栈中元素数，返回给 lua return value 数量 &#125; if (r-&gt;header_only) &#123; lua_pushnil(L); // 状态标识 lua_pushliteral(L, &quot;header only&quot;); // 错误信息字符串 return 2; // 栈中元素数，返回给 lua return value 数量 &#125; if (ctx-&gt;eof) &#123; lua_pushnil(L); // 状态标识 lua_pushliteral(L, &quot;seen eof&quot;); // 错误信息 return 2; &#125; nargs = lua_gettop(L); size = 0; // 计算 ngx.print 或 ngx.say 的参数长度 for (i = 1; i &lt;= nargs; i++) &#123; type = lua_type(L, i); switch (type) &#123; case LUA_TNUMBER: case LUA_TSTRING: lua_tolstring(L, i, &amp;len); size += len; break; case LUA_TNIL: size += sizeof(&quot;nil&quot;) - 1; break; case LUA_TBOOLEAN: if (lua_toboolean(L, i)) &#123; size += sizeof(&quot;true&quot;) - 1; &#125; else &#123; size += sizeof(&quot;false&quot;) - 1; &#125; break; case LUA_TTABLE: size += ngx_http_lua_calc_strlen_in_table(L, i, i, 0 /* strict */); break; case LUA_TLIGHTUSERDATA: dd(&quot;userdata: %p&quot;, lua_touserdata(L, i)); if (lua_touserdata(L, i) == NULL) &#123; size += sizeof(&quot;null&quot;) - 1; break; &#125; continue; default: msg = lua_pushfstring(L, &quot;string, number, boolean, nil, &quot; &quot;ngx.null, or array table expected, &quot; &quot;but got %s&quot;, lua_typename(L, type)); return luaL_argerror(L, i, msg); &#125; &#125; // ngx.say newline 为 1；ngx.print newline 为 0 if (newline) &#123; size += sizeof(&quot;\\n&quot;) - 1; &#125; // 无 body，仅发送 header if (size == 0) &#123; rc = ngx_http_lua_send_header_if_needed(r, ctx); if (rc == NGX_ERROR || rc &gt; NGX_OK) &#123; lua_pushnil(L); lua_pushliteral(L, &quot;nginx output filter error&quot;); return 2; &#125; lua_pushinteger(L, 1); return 1; &#125; ctx-&gt;seen_body_data = 1; // 创建 size 大小的 ngx_chain_t 对象 cl = ngx_http_lua_chain_get_free_buf(r-&gt;connection-&gt;log, r-&gt;pool, &amp;ctx-&gt;free_bufs, size); if (cl == NULL) &#123; return luaL_error(L, &quot;no memory&quot;); &#125; b = cl-&gt;buf; // 将调用参数进行转换，并拷贝的 output_chain for (i = 1; i &lt;= nargs; i++) &#123; type = lua_type(L, i); switch (type) &#123; case LUA_TNUMBER: case LUA_TSTRING: p = lua_tolstring(L, i, &amp;len); b-&gt;last = ngx_copy(b-&gt;last, (u_char *) p, len); break; case LUA_TNIL: *b-&gt;last++ = &#x27;n&#x27;; *b-&gt;last++ = &#x27;i&#x27;; *b-&gt;last++ = &#x27;l&#x27;; break; case LUA_TBOOLEAN: if (lua_toboolean(L, i)) &#123; *b-&gt;last++ = &#x27;t&#x27;; *b-&gt;last++ = &#x27;r&#x27;; *b-&gt;last++ = &#x27;u&#x27;; *b-&gt;last++ = &#x27;e&#x27;; &#125; else &#123; *b-&gt;last++ = &#x27;f&#x27;; *b-&gt;last++ = &#x27;a&#x27;; *b-&gt;last++ = &#x27;l&#x27;; *b-&gt;last++ = &#x27;s&#x27;; *b-&gt;last++ = &#x27;e&#x27;; &#125; break; case LUA_TTABLE: b-&gt;last = ngx_http_lua_copy_str_in_table(L, i, b-&gt;last); break; case LUA_TLIGHTUSERDATA: *b-&gt;last++ = &#x27;n&#x27;; *b-&gt;last++ = &#x27;u&#x27;; *b-&gt;last++ = &#x27;l&#x27;; *b-&gt;last++ = &#x27;l&#x27;; break; default: return luaL_error(L, &quot;impossible to reach here&quot;); &#125; &#125; if (newline) &#123; *b-&gt;last++ = &#x27;\\n&#x27;; &#125;#if 0 if (b-&gt;last != b-&gt;end) &#123; return luaL_error(L, &quot;buffer error: %p != %p&quot;, b-&gt;last, b-&gt;end); &#125;#endif ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, newline ? &quot;lua say response&quot; : &quot;lua print response&quot;); // 最终会调用 ngx_http_top_body_filter 进行响应 rc = ngx_http_lua_send_chain_link(r, ctx, cl); if (rc == NGX_ERROR || rc &gt;= NGX_HTTP_SPECIAL_RESPONSE) &#123; lua_pushnil(L); lua_pushliteral(L, &quot;nginx output filter error&quot;); return 2; &#125; dd(&quot;downstream write: %d, buf len: %d&quot;, (int) rc, (int) (b-&gt;last - b-&gt;pos)); lua_pushinteger(L, 1); return 1;&#125; 3. ngx.say函数原型： 1ok, err = ngx.say(...) 与 ngx.print 功能相同，最终会调用 ngx_http_lua_ngx_echo 函数，只不过 ngx.say 调用时 newline 参数为 1。 4. ngx.flush函数原型： 1ok, err = ngx.flush(wait?) 允许介入阶段：rewrite_by_lua_*、access_by_lua_*、content_by_lua_*。 如果存在可选 wait 参数，并且值为 true 函数调用会等待发送结束或超时才返回（HTTP/1.0 buffing 未在此情况），否则立即返回。ngx.flush 实现函数 ngx_http_lua_ngx_flush 主要实现两个功能：body filter 链对应答数据进行处理、将应答数据发送出去，函数实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156static intngx_http_lua_ngx_flush(lua_State *L)&#123; ngx_http_request_t *r; ngx_http_lua_ctx_t *ctx; ngx_chain_t *cl; ngx_int_t rc; int n; unsigned wait = 0; ngx_event_t *wev; ngx_http_core_loc_conf_t *clcf; ngx_http_lua_co_ctx_t *coctx; n = lua_gettop(L); if (n &gt; 1) &#123; return luaL_error(L, &quot;attempt to pass %d arguments, but accepted 0 &quot; &quot;or 1&quot;, n); &#125; r = ngx_http_lua_get_req(L); if (n == 1 &amp;&amp; r == r-&gt;main) &#123; luaL_checktype(L, 1, LUA_TBOOLEAN); wait = lua_toboolean(L, 1); &#125; ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module); if (ctx == NULL) &#123; return luaL_error(L, &quot;no request ctx found&quot;); &#125; ngx_http_lua_check_context(L, ctx, NGX_HTTP_LUA_CONTEXT_REWRITE | NGX_HTTP_LUA_CONTEXT_ACCESS | NGX_HTTP_LUA_CONTEXT_CONTENT); // if (ctx-&gt;acquired_raw_req_socket) &#123; lua_pushnil(L); lua_pushliteral(L, &quot;raw request socket acquired&quot;); return 2; &#125; coctx = ctx-&gt;cur_co_ctx; if (coctx == NULL) &#123; return luaL_error(L, &quot;no co ctx found&quot;); &#125; if (r-&gt;header_only) &#123; lua_pushnil(L); lua_pushliteral(L, &quot;header only&quot;); return 2; &#125; // 请求已经关闭 if (ctx-&gt;eof) &#123; lua_pushnil(L); lua_pushliteral(L, &quot;seen eof&quot;); return 2; &#125; // 如果是 buffing 则 flush 无效 if (ctx-&gt;buffering) &#123; ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, &quot;lua http 1.0 buffering makes ngx.flush() a no-op&quot;); lua_pushnil(L); lua_pushliteral(L, &quot;buffering&quot;); return 2; &#125;#if 1 // header 已经发出、无待发送包体 if ((!r-&gt;header_sent &amp;&amp; !ctx-&gt;header_sent) || (!ctx-&gt;seen_body_data &amp;&amp; !wait)) &#123; lua_pushnil(L); lua_pushliteral(L, &quot;nothing to flush&quot;); return 2; &#125;#endif // 使用空闲或新建 chain，并设置 flush 标记位；其中无待发送数据 cl = ngx_http_lua_get_flush_chain(r, ctx); if (cl == NULL) &#123; return luaL_error(L, &quot;no memory&quot;); &#125; // 发送应答动作，经过 body filter 处理 // 此时数据并未发送到客户端，仍然在 nginx 中，保存在 cl 中 rc = ngx_http_lua_send_chain_link(r, ctx, cl); dd(&quot;send chain: %d&quot;, (int) rc); if (rc == NGX_ERROR || rc &gt;= NGX_HTTP_SPECIAL_RESPONSE) &#123; lua_pushnil(L); lua_pushliteral(L, &quot;nginx output filter error&quot;); return 2; &#125; dd(&quot;wait:%d, rc:%d, buffered:0x%x&quot;, wait, (int) rc, r-&gt;connection-&gt;buffered); wev = r-&gt;connection-&gt;write; // 同步写操作 // 等待所有的数据写到客户端后才返回，并不会阻塞请求 if (wait &amp;&amp; (r-&gt;connection-&gt;buffered &amp; NGX_HTTP_LOWLEVEL_BUFFERED || wev-&gt;delayed)) &#123; ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, &quot;lua flush requires waiting: buffered 0x%uxd, &quot; &quot;delayed:%d&quot;, (unsigned) r-&gt;connection-&gt;buffered, wev-&gt;delayed); coctx-&gt;flushing = 1; ctx-&gt;flushing_coros++; if (ctx-&gt;entered_content_phase) &#123; /* mimic ngx_http_set_write_handler */ r-&gt;write_event_handler = ngx_http_lua_content_wev_handler; &#125; else &#123; r-&gt;write_event_handler = ngx_http_core_run_phases; &#125; clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module); if (!wev-&gt;delayed) &#123; ngx_add_timer(wev, clcf-&gt;send_timeout); &#125; if (ngx_handle_write_event(wev, clcf-&gt;send_lowat) != NGX_OK) &#123; if (wev-&gt;timer_set) &#123; wev-&gt;delayed = 0; ngx_del_timer(wev); &#125; lua_pushnil(L); lua_pushliteral(L, &quot;connection broken&quot;); return 2; &#125; ngx_http_lua_cleanup_pending_operation(ctx-&gt;cur_co_ctx); coctx-&gt;cleanup = ngx_http_lua_flush_cleanup; coctx-&gt;data = r; return lua_yield(L, 0); &#125; ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, &quot;lua flush asynchronously&quot;); // 异步发送，不等待发送结束，仅设置 chain 的 flush 标记位 lua_pushinteger(L, 1); return 1;&#125; 在 ngx.print、ngx.say、ngx.flush 函数实现中都会调用 ngx_http_lua_send_chain_link 函数，用于将应答数据经过 header filter、body filter 处理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121// 将应答数据经过 body filter 处理ngx_int_tngx_http_lua_send_chain_link(ngx_http_request_t *r, ngx_http_lua_ctx_t *ctx, ngx_chain_t *in)&#123; ngx_int_t rc; ngx_chain_t *cl; ngx_chain_t **ll; ngx_http_lua_loc_conf_t *llcf;#if 1 if (ctx-&gt;acquired_raw_req_socket || ctx-&gt;eof) &#123; dd(&quot;ctx-&gt;eof already set or raw req socket already acquired&quot;); return NGX_OK; &#125;#endif if ((r-&gt;method &amp; NGX_HTTP_HEAD) &amp;&amp; !r-&gt;header_only) &#123; r-&gt;header_only = 1; &#125; llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module); if (llcf-&gt;http10_buffering &amp;&amp; !ctx-&gt;buffering &amp;&amp; !r-&gt;header_sent &amp;&amp; !ctx-&gt;header_sent &amp;&amp; r-&gt;http_version &lt; NGX_HTTP_VERSION_11 &amp;&amp; r-&gt;headers_out.content_length_n &lt; 0) &#123; ctx-&gt;buffering = 1; &#125; rc = ngx_http_lua_send_header_if_needed(r, ctx); if (rc == NGX_ERROR || rc &gt; NGX_OK) &#123; return rc; &#125; // 仅需要发送 header，无 body if (r-&gt;header_only) &#123; ctx-&gt;eof = 1; if (ctx-&gt;buffering) &#123; return ngx_http_lua_send_http10_headers(r, ctx); &#125; return rc; &#125; if (in == NULL) &#123; dd(&quot;last buf to be sent&quot;);#if 1 if (!r-&gt;request_body &amp;&amp; r == r-&gt;main) &#123; if (ngx_http_discard_request_body(r) != NGX_OK) &#123; return NGX_ERROR; &#125; &#125;#endif if (ctx-&gt;buffering) &#123; rc = ngx_http_lua_send_http10_headers(r, ctx); if (rc == NGX_ERROR || rc &gt;= NGX_HTTP_SPECIAL_RESPONSE) &#123; return rc; &#125; if (ctx-&gt;out) &#123; rc = ngx_http_lua_output_filter(r, ctx-&gt;out); if (rc == NGX_ERROR || rc &gt;= NGX_HTTP_SPECIAL_RESPONSE) &#123; return rc; &#125; ctx-&gt;out = NULL; &#125; &#125;#if defined(nginx_version) &amp;&amp; nginx_version &lt;= 8004 /* earlier versions of nginx does not allow subrequests to send last_buf themselves */ if (r != r-&gt;main) &#123; return NGX_OK; &#125;#endif ctx-&gt;eof = 1; ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, &quot;lua sending last buf of the response body&quot;); rc = ngx_http_lua_send_special(r, NGX_HTTP_LAST); if (rc == NGX_ERROR || rc &gt;= NGX_HTTP_SPECIAL_RESPONSE) &#123; return rc; &#125; return NGX_OK; &#125; /* in != NULL */ // 存在 buffing 数据，将待发送数据放在最后 if (ctx-&gt;buffering) &#123; ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, &quot;lua buffering output bufs for the HTTP 1.0 request&quot;); // 将 ctx 中待发送数据保存到 ngx_chain_t 中 for (cl = ctx-&gt;out, ll = &amp;ctx-&gt;out; cl; cl = cl-&gt;next) &#123; ll = &amp;cl-&gt;next; &#125; *ll = in; return NGX_OK; &#125; // 调用 ngx_http_output_filter 进行 body filter 处理 return ngx_http_lua_output_filter(r, in);&#125; 5. ngx.eof函数原型： 1ok, err = ngx.eof() 允许介入阶段：rewrite_by_lua_*、access_by_lua_*、content_by_lua_*。 指示响应流结束，如果是 HTTP/1.1 版本 chunked 编码格式，将触发发送最后一个 chunk。如果未启用 HTTP/1.1 的 keep-alive 特性，调用 ngx.eof 后客户端应该关闭连接。**ngx.eof 不会关闭连接，只会调用 header filter、body filter 进行应答处理**。 在 ngx.eof 实现中同样会调用 ngx_http_lua_send_chain_link。 三 HTTP/1.0 buffingHTTP/1.0 不支持 chunked 编码，当响应 body 不为空时需要 content-length 头以便支持 HTTP/1.0 的 keep-alive 特性。因此当发起 HTTP/1.0 协议请求并且打开了 lua_http10_buffing 配置时，lua-nginx 模块会将 ngx.say、ngx.print 的输出内容缓存（同时会将应答 header 延时发送），直到收到所有的应答 body。此时，lua-nginx 模块就能计算出 content-length 并发送给客户端。如果在应答头中有 content-length 头，即使打开了 lua_http10_buffing 也不会缓存应答信息。 对于大的响应流，要注意关闭 lua_http10_buffing 指令，避免内存占用过高。 1. lua_http10_buffering 指令123syntax: lua_http10_buffering on|offdefault: lua_http10_buffering oncontext: http, server, location, location-if 为 HTTP/1.0 (或更老的)请求启用或禁用自动响应缓存，这种缓冲机制主要用于低于 HTTP/1.0 版本的 keep-alive 特性，它依赖于正确的 content-length 响应头。 如果 lua 代码在发送响应头（通过调用 ngx.send_headers、ngx.say、ngx.print 触发发送响应头）之前已经显示的设置 content-length 头，http10_buffering 特性将被关闭。","categories":[{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/categories/NGINX/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"Lua","slug":"Lua","permalink":"https://juzipeek.github.io/tags/Lua/"},{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/tags/NGINX/"},{"name":"OpenResty","slug":"OpenResty","permalink":"https://juzipeek.github.io/tags/OpenResty/"}]},{"title":"OpenResty Api - control api","slug":"nginx-2019-07-28-openresty-api-control-api","date":"2022-09-03T12:55:44.507Z","updated":"2022-09-03T12:55:44.507Z","comments":true,"path":"2022/09/03/nginx-2019-07-28-openresty-api-control-api/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/nginx-2019-07-28-openresty-api-control-api/","excerpt":"","text":"一 概述ngx.redirect ngx.exec ngx.throw_error ngx.exit ngx.on_abort 二 函数1. ngx.redirect1ngx.redirect(uri, status?) 可介入的阶段：rewrite_by_lua, access_by_lua, content_by_lua 发出重定向应答，跳转到 uri 参数指定的 uri， HTTP 状态码默认为 302，可以使用可选参数 status 指定状态码。status 可选值为：301、302、303、307、308。函数调用会终止请求处理。 函数实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109static intngx_http_lua_ngx_redirect(lua_State *L)&#123; ngx_http_lua_ctx_t *ctx; ngx_int_t rc; int n; u_char *p; u_char *uri; size_t len; ngx_table_elt_t *h; ngx_http_request_t *r; n = lua_gettop(L); if (n != 1 &amp;&amp; n != 2) &#123; return luaL_error(L, &quot;expecting one or two arguments&quot;); &#125; p = (u_char *) luaL_checklstring(L, 1, &amp;len); if (n == 2) &#123; rc = (ngx_int_t) luaL_checknumber(L, 2); if (rc != NGX_HTTP_MOVED_TEMPORARILY &amp;&amp; rc != NGX_HTTP_MOVED_PERMANENTLY &amp;&amp; rc != NGX_HTTP_SEE_OTHER &amp;&amp; rc != NGX_HTTP_PERMANENT_REDIRECT &amp;&amp; rc != NGX_HTTP_TEMPORARY_REDIRECT) &#123; return luaL_error(L, &quot;only ngx.HTTP_MOVED_TEMPORARILY, &quot; &quot;ngx.HTTP_MOVED_PERMANENTLY, &quot; &quot;ngx.HTTP_PERMANENT_REDIRECT, &quot; &quot;ngx.HTTP_SEE_OTHER, and &quot; &quot;ngx.HTTP_TEMPORARY_REDIRECT are allowed&quot;); &#125; &#125; else &#123; rc = NGX_HTTP_MOVED_TEMPORARILY; &#125; r = ngx_http_lua_get_req(L); if (r == NULL) &#123; return luaL_error(L, &quot;no request object found&quot;); &#125; ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module); if (ctx == NULL) &#123; return luaL_error(L, &quot;no request ctx found&quot;); &#125; // 阶段检查 ngx_http_lua_check_context(L, ctx, NGX_HTTP_LUA_CONTEXT_REWRITE | NGX_HTTP_LUA_CONTEXT_ACCESS | NGX_HTTP_LUA_CONTEXT_CONTENT); // 如果子请求未应答则不能调用 redirect 函数 ngx_http_lua_check_if_abortable(L, ctx); if (r-&gt;header_sent || ctx-&gt;header_sent) &#123; return luaL_error(L, &quot;attempt to call ngx.redirect after sending out &quot; &quot;the headers&quot;); &#125; uri = ngx_palloc(r-&gt;pool, len); if (uri == NULL) &#123; return luaL_error(L, &quot;no memory&quot;); &#125; ngx_memcpy(uri, p, len); // 添加 Location 头，值为 uri h = ngx_list_push(&amp;r-&gt;headers_out.headers); if (h == NULL) &#123; return luaL_error(L, &quot;no memory&quot;); &#125; h-&gt;hash = ngx_http_lua_location_hash;#if 0 dd(&quot;location hash: %lu == %lu&quot;, (unsigned long) h-&gt;hash, (unsigned long) ngx_hash_key_lc((u_char *) &quot;Location&quot;, sizeof(&quot;Location&quot;) - 1));#endif h-&gt;value.len = len; h-&gt;value.data = uri; ngx_str_set(&amp;h-&gt;key, &quot;Location&quot;); r-&gt;headers_out.status = rc; ctx-&gt;exit_code = rc; ctx-&gt;exited = 1; ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, &quot;lua redirect to \\&quot;%V\\&quot; with code %i&quot;, &amp;h-&gt;value, ctx-&gt;exit_code); if (len &amp;&amp; uri[0] != &#x27;/&#x27;) &#123; r-&gt;headers_out.location = h; &#125; /* * we do not set r-&gt;headers_out.location here to avoid the handling * the local redirects without a host name by ngx_http_header_filter() */ return lua_yield(L, 0);&#125; 2. ngx.exec1ngx.exec(uri, args?) 可介入的阶段：rewrite_by_lua, access_by_lua, content_by_lua 执行内部跳转功能，跳转到 uri，使用可选参数 args 可以传递 uri 参数，args 可以是 string 也可以说是 table 类型。支持使用命名 location 作为 uri 参数，但是 args 参数会被忽略。ngx.exec 函数功能由 ngx_http_lua_ngx_exec 函数实现，但是在 ngx_http_lua_ngx_exec 中处理成功后仅设置了 ctx[ngx_http_lua_module]-&gt;exec_uri、ctx[ngx_http_lua_module]-&gt;exec_args 变量，在 ngx_http_lua_run_thread 函数中检测 exec_uri 被设置会调用 ngx_http_lua_handle_exec 函数进行内部跳转。对于命名 location 跳转会直接跳转到 NGX_HTTP_POST_REWRITE_PHASE 阶段进行处理(设置的索引是 NGX_HTTP_REWRITE_PHASE ，会执行下个阶段的处理)，不会经过 NGX_HTTP_FIND_CONFIG_PHASE 阶段进行 location 查找，因此需要在 server&#123;&#125; 内查找好 location 并对请求进行更新。对于非命令 location 的内部跳转，会更新当前请求的 uri，跳转到 NGX_HTTP_FIND_CONFIG_PHASE 阶段进行处理。 3. ngx.exit1ngx.exit(status) 可介入的阶段：rewrite_by_lua*, access_by_lua*, content_by_lua*,header_filter_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua status &gt;= 200 会中断当前请求的执行，并将 status 作为应答状态码返回，会经过后续的 header_filter、body_filter 阶段。 status == 0 将只会跳过当前阶段的处理函数，继续执行后续阶段的处理函数。 status 取值范围是HTTP 常量状态码以及 ngx.OK、ngx.ERROR。 ngx_http_lua_ngx_exit 是 ngx.exit 的实现函数，在其中仅将 status 设置到 ctx-&gt;exit_code 中，同时设置 exited 标记。在 ngx_http_lua_run_thread 中检测到 exited 标记后会调用 ngx_http_lua_handle_exit 进行处理。 TODO：ngx_http_lua_handle_exit 、ngx_http_lua_run_thread 继续跟进 4. ngx.on_abort1ok, err = ngx.on_abort(callback) 可介入的阶段：rewrite_by_lua*、access_by_lua*、content_by_lua* 将函数 callback 注册为回调函数，当客户端过早关闭（下游）连接时，将自动调用该函数。调用成功返回值为 1 否则返回 nil。回调函数可以决定如何处理客户端的提前关闭事件，可以通过不执行任何操作来简单忽略该事件，并且当前的请求处理程序将继续执行而不会中断。回调函数可以调用 ngx.exit 来终止请求处理。 当 lua_check_client_abort 指令配置为 off 时调用 ngx.on_abort 会返回 lua_check_client_abort is off 错误提示。 在一个请求中，此函数只能注册一次。 在实现函数 ngx_http_lua_on_abort 中会创建 light thread： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051static intngx_http_lua_on_abort(lua_State *L)&#123; ngx_http_lua_ctx_t *ctx; ngx_http_lua_co_ctx_t *coctx = NULL; // ... 省略其他代码 ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module); if (ctx == NULL) &#123; return luaL_error(L, &quot;no request ctx found&quot;); &#125; ngx_http_lua_check_fake_request2(L, r, ctx); // 已经创建过协程 if (ctx-&gt;on_abort_co_ctx) &#123; lua_pushnil(L); lua_pushliteral(L, &quot;duplicate call&quot;); return 2; &#125; // 关闭 lua_check_client_abort 配置 llcf = ngx_http_get_module_loc_conf(r, ngx_http_lua_module); if (!llcf-&gt;check_client_abort) &#123; lua_pushnil(L); lua_pushliteral(L, &quot;lua_check_client_abort is off&quot;); return 2; &#125; // 使用回调函数创建协程 ngx_http_lua_coroutine_create_helper(L, r, ctx, &amp;coctx); lua_pushlightuserdata(L, &amp;ngx_http_lua_coroutines_key); lua_rawget(L, LUA_REGISTRYINDEX); lua_pushvalue(L, -2); dd(&quot;on_wait thread 1: %p&quot;, lua_tothread(L, -1)); coctx-&gt;co_ref = luaL_ref(L, -2); lua_pop(L, 1); coctx-&gt;is_uthread = 1; // 保存创建的协程 ctx-&gt;on_abort_co_ctx = coctx; dd(&quot;on_wait thread 2: %p&quot;, coctx-&gt;co); // 协程状态挂起 coctx-&gt;co_status = NGX_HTTP_LUA_CO_SUSPENDED; coctx-&gt;parent_co_ctx = ctx-&gt;cur_co_ctx; lua_pushinteger(L, 1); return 1;&#125; 在 NGINX 事件处理中，当检测到客户端连接关闭时会调用 ngx_http_lua_rd_check_broken_connection 函数，会将 on_abort 创建的协程设置为处理协程。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768voidngx_http_lua_rd_check_broken_connection(ngx_http_request_t *r)&#123; ngx_int_t rc; ngx_event_t *rev; ngx_http_lua_ctx_t *ctx; if (r-&gt;done) &#123; return; &#125; rc = ngx_http_lua_check_broken_connection(r, r-&gt;connection-&gt;read); if (rc == NGX_OK) &#123; return; &#125; /* rc == NGX_ERROR || rc &gt; NGX_OK */ ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module); if (ctx == NULL) &#123; return; &#125; // 未设置 on_abort 函数 if (ctx-&gt;on_abort_co_ctx == NULL) &#123; r-&gt;connection-&gt;error = 1; ngx_http_lua_request_cleanup(ctx, 0); ngx_http_lua_finalize_request(r, rc); return; &#125; // 协程状态必定是 SUSPENDED if (ctx-&gt;on_abort_co_ctx-&gt;co_status != NGX_HTTP_LUA_CO_SUSPENDED) &#123; /* on_abort already run for the current request handler */ rev = r-&gt;connection-&gt;read; if ((ngx_event_flags &amp; NGX_USE_LEVEL_EVENT) &amp;&amp; rev-&gt;active) &#123; if (ngx_del_event(rev, NGX_READ_EVENT, 0) != NGX_OK) &#123; ngx_http_lua_request_cleanup(ctx, 0); ngx_http_lua_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR); return; &#125; &#125; return; &#125; ctx-&gt;uthreads++; ctx-&gt;resume_handler = ngx_http_lua_on_abort_resume; ctx-&gt;on_abort_co_ctx-&gt;co_status = NGX_HTTP_LUA_CO_RUNNING; // 处理协程是 on_abort 协程 ctx-&gt;cur_co_ctx = ctx-&gt;on_abort_co_ctx; ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, &quot;lua waking up the on_abort callback thread&quot;); if (ctx-&gt;entered_content_phase) &#123; r-&gt;write_event_handler = ngx_http_lua_content_wev_handler; &#125; else &#123; r-&gt;write_event_handler = ngx_http_core_run_phases; &#125; // 触发写事件处理 r-&gt;write_event_handler(r);&#125;","categories":[{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/categories/NGINX/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"Lua","slug":"Lua","permalink":"https://juzipeek.github.io/tags/Lua/"},{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/tags/NGINX/"},{"name":"OpenResty","slug":"OpenResty","permalink":"https://juzipeek.github.io/tags/OpenResty/"}]},{"title":"OpenResty lib - lua-resty-lock","slug":"nginx-2019-08-05-openresty-lua-resty-lock","date":"2022-09-03T12:55:44.507Z","updated":"2022-09-03T12:55:44.507Z","comments":true,"path":"2022/09/03/nginx-2019-08-05-openresty-lua-resty-lock/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/nginx-2019-08-05-openresty-lua-resty-lock/","excerpt":"","text":"一 概述lua-resty-lock 使用共享内存构建的非阻塞锁，锁等待非阻塞是通过 ngx.sleep 函数实现的，当无法获取锁时会不断调用 ngx.sleep，直至成功获取锁或超时失败。ngx.sleep 是非阻塞的，会将当前协程放回事件循环中。 二 API 接口1. new12syntax: obj, err = lock:new(dict_name)syntax: obj, err = lock:new(dict_name, opts) 通过 dict_name 指定的共享内存名称创建锁对象实例。可选的 opts 是一个 table 类型参数，可以定义锁的行为： 参数 含义 备注 exptime 共享内存中锁过期时间；超过时间后锁会被删除 单位秒；默认 30s timeout 锁的 lock 方法最大等待事件；如果为零则不等待 单位秒；默认 5s step 指定等待锁时休眠的初始步长，它会按 ratio 逐步增大 单位秒；默认 0.001s ratio 指定步长递增比例，默认是 2，步长加倍 max_step 最大步长 单位秒；默认 0.5s 2. lock1syntax: elapsed, err = obj:lock(key) 尝试给 key 加锁，obj 是 new 函数返回的对象，不同的 key 代表不同的锁。成功时 elapsed 代表获取锁需要耗费时间；否则为 nil，err 为错误字符串。 elapsed 代表的并不是墙上时间，而是所有等待 step 的累加和。如果 elapsed 大于零，说明锁之前被其他人持有，但是 elapsed 为零并不代表没有其他人获取过锁。 常见错误信息： 错误提示 含义 “timeout” 等待超过了创建锁时指定的 timeout 时间 “locked” 当前 resty.lock 对象实例已经持有一个锁（不一定是同一个 key） 每个锁对象实例只能维护一个锁，如果需要操作锁需要多次调用 new 创建多个锁对象实例进行维护，不然会出现 locked 错误。错误示例： 1234567891011121314151617181920212223local resty_lock = require &quot;resty.lock&quot;local dict = &quot;my_locks&quot;local key1 = &quot;key1&quot;local key2 = &quot;key2&quot;local lock, err = resty_lock:new(dict)if not lock then ngx.log(ngx.ERR, &quot;failed to create lock: &quot;, err) returnendlocal elapsed, err = lock:lock(key1)if not elapsed then ngx.log(ngx.ERR, &quot;failed to acquire the lock: &quot;, err) returnend-- 此处调用会出现 err: lockedlocal elapsed, err = lock:lock(key2)if not elapsed then ngx.log(ngx.ERR, &quot;failed to acquire the lock: &quot;, err) returnend 3. unlock1syntax: ok, err = obj:unlock() 释放锁，obj 为 new 返回值。成功返回 1，否则返回 nil，err 标明错误信息。 4. expire1syntax: ok, err = obj:expire(timeout) 设置当前 resty.lock 对象实例持有的锁的 TTL，这将把锁实例的超时时间设置为 timeout 参数指定的值（秒）。expire 设置的超时时间与调用 new 指定的超时时间是独立的（不会覆盖 new 指定的超时时间），调用 expire(nil) 会使用 new 函数指定的超时时间。 成功返回 true； 否则返回 nil ，错误信息由 err 描述。 三 使用示例使用锁的常见场景是避免缓存雪崩：当缓存丢失时，限制对同一个 key 的并发后端查询。缓存锁的基本工作流程如下： 使用 key 从缓存查询，缓存未命中，跳到第 2 步执行； 实例化 resty.lock 对象，并使用 lock 函数给 key 加锁，成功则跳转到第 3 步； 再次使用 key 从缓存查询。如果命中则释放锁并返回 key 的命中值；否则进行第 4 步； 从后端进行查询，将查询结果放入缓存（如果未查询到应该存储一个未查询到特殊值），释放锁； 示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374local resty_lock = require &quot;resty.lock&quot;local cache = ngx.shared.my_cache-- step 1:local val, err = cache:get(key)if val then ngx.say(&quot;result: &quot;, val) returnendif err then return fail(&quot;failed to get key from shm: &quot;, err)end-- cache miss!-- step 2:local lock, err = resty_lock:new(&quot;my_locks&quot;)if not lock then return fail(&quot;failed to create lock: &quot;, err)endlocal elapsed, err = lock:lock(key)if not elapsed then return fail(&quot;failed to acquire the lock: &quot;, err)end-- lock successfully acquired!-- step 3:-- someone might have already put the value into the cache-- so we check it here again:val, err = cache:get(key)if val then local ok, err = lock:unlock() if not ok then return fail(&quot;failed to unlock: &quot;, err) end ngx.say(&quot;result: &quot;, val) returnend--- step 4:local val = fetch_redis(key)if not val then local ok, err = lock:unlock() if not ok then return fail(&quot;failed to unlock: &quot;, err) end -- FIXME: we should handle the backend miss more carefully -- here, like inserting a stub value into the cache. ngx.say(&quot;no value found&quot;) returnend-- update the shm cache with the newly fetched valuelocal ok, err = cache:set(key, val, 1)if not ok then local ok, err = lock:unlock() if not ok then return fail(&quot;failed to unlock: &quot;, err) end return fail(&quot;failed to update shm cache: &quot;, err)endlocal ok, err = lock:unlock()if not ok then return fail(&quot;failed to unlock: &quot;, err)endngx.say(&quot;result: &quot;, val) 四 使用限制因为 resty.lock 使用 ngx.sleep 不断进行轮询，ngx.sleep 会 yield 当前轻量级线程，所以在所有禁止 yield 操作的阶段（init/init_worker/header_filter/body_filter/balancer_by/log_by）不能使用 resty.lock 库。 五 库实现在 lua-resty-lock 库实现中锁存储在 shared dict 中，使用 shared dict 实现了跨 worker 间的锁。当 key 已经在 shared dict 中时会不断进行重试，尝试获得锁。 1. 创建锁实例123456789101112131415161718192021222324252627282930313233343536373839404142function _M.new(_, dict_name, opts) local dict = shared[dict_name] if not dict then return nil, &quot;dictionary not found&quot; end -- 创建 cdata 类型数据 -- 主要利用 cdata 的 _gc 元方法（在 ctype 定义中有设置） local cdata = ffi_new(ctype) cdata.key_id = 0 -- 将 cdata 存储在 memo 表中，并返回其索引 cdata.dict_id = ref_obj(dict) local timeout, exptime, step, ratio, max_step if opts then timeout = opts.timeout exptime = opts.exptime step = opts.step ratio = opts.ratio max_step = opts.max_step end if not exptime then exptime = 30 end if timeout and timeout &gt; exptime then timeout = exptime end local self = &#123; cdata = cdata, dict = dict, timeout = timeout or 5, exptime = exptime, step = step or 0.001, ratio = ratio or 2, max_step = max_step or 0.5, &#125; -- 设置元表 return setmetatable(self, mt)end ref_obj 与 unref_obj 使用类似 NGINX 中 connections 数组的方法进行操作。memo 表用来进行存储，当表中数据删除时，将其索引保存到 FREE_LIST_REF 变量中，下次进行 ref_obj 操作时直接使用，当通过 FREE_LIST_REF 索引获得的索引为 0 时，计算 memo 表的大小，取下一个索引存储数据。 123456789101112131415161718192021222324252627282930313233local FREE_LIST_REF = 0-- FIXME: we don&#x27;t need this when we have __gc metamethod support on Lua-- tables.local memo = &#123;&#125;if debug then _M.memo = memo endlocal function ref_obj(key) if key == nil then return -1 end local ref = memo[FREE_LIST_REF] if ref and ref ~= 0 then memo[FREE_LIST_REF] = memo[ref] else ref = #memo + 1 end memo[ref] = key -- print(&quot;ref key_id returned &quot;, ref) return refendif debug then _M.ref_obj = ref_obj endlocal function unref_obj(ref) if ref &gt;= 0 then memo[ref] = memo[FREE_LIST_REF] memo[FREE_LIST_REF] = ref endend 2. 加锁操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// 加锁操作function _M.lock(self, key) if not key then return nil, &quot;nil key&quot; end local dict = self.dict local cdata = self.cdata -- cdata 已经存在锁 if cdata.key_id &gt; 0 then return nil, &quot;locked&quot; end -- 在 shared dict 添加 key local exptime = self.exptime local ok, err = dict:add(key, true, exptime) if ok then -- 加锁成功，增加 key 的引用 -- 将 key 存储在 memo table 中，避免被 GC 掉 cdata.key_id = ref_obj(key) if not shdict_mt then shdict_mt = getmetatable(dict) end return 0 end -- 出错，直接返回 if err ~= &quot;exists&quot; then return nil, err end -- 不断重试，尝试获得锁 -- lock held by others local step = self.step local ratio = self.ratio local timeout = self.timeout local max_step = self.max_step local elapsed = 0 while timeout &gt; 0 do if step &gt; timeout then step = timeout end sleep(step) elapsed = elapsed + step timeout = timeout - step local ok, err = dict:add(key, true, exptime) if ok then cdata.key_id = ref_obj(key) if not shdict_mt then shdict_mt = getmetatable(dict) end return elapsed end if err ~= &quot;exists&quot; then return nil, err end if timeout &lt;= 0 then break end step = step * ratio if step &lt;= 0 then step = 0.001 end if step &gt; max_step then step = max_step end end return nil, &quot;timeout&quot;end 3. 去锁操作123456789101112131415161718192021function _M.unlock(self) local dict = self.dict local cdata = self.cdata local key_id = tonumber(cdata.key_id) if key_id &lt;= 0 then return nil, &quot;unlocked&quot; end -- 从 memo 表根据 key_id 获得 key 值 local key = memo[key_id] unref_obj(key_id) -- 解锁操作：从 shared dict 删除 key local ok, err = dict:delete(key) if not ok then return nil, err end cdata.key_id = 0 return 1end","categories":[{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/categories/NGINX/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"Lua","slug":"Lua","permalink":"https://juzipeek.github.io/tags/Lua/"},{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/tags/NGINX/"},{"name":"OpenResty","slug":"OpenResty","permalink":"https://juzipeek.github.io/tags/OpenResty/"}]},{"title":"lua-upstream-nginx-module 模块","slug":"nginx-2019-06-29-lua-upstream-nginx-module","date":"2022-09-03T12:55:44.506Z","updated":"2022-09-03T12:55:44.506Z","comments":true,"path":"2022/09/03/nginx-2019-06-29-lua-upstream-nginx-module/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/nginx-2019-06-29-lua-upstream-nginx-module/","excerpt":"","text":"一 概述lua-upstream 模块提供了对 upstrem 配置的查看，查看所有的 upstream、upstream 内所有的/启用的/备用的 server，当前使用的 upstream 名。虽然有 set_peer_down 指令，但是模块只修改单个 worker 内的 server 标记（处理 set_peer_down 请求的 worker），无法再生产环境使用。 二 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990worker_processes 1;error_log logs/error.log info;events &#123; worker_connections 1024;&#125;http &#123; lua_code_cache off; upstream backend &#123; server localhost:8081 down; server localhost:8082; &#125; server &#123; listen 8081; location / &#123; default_type text/plain; content_by_lua_block &#123; ngx.say(&quot;hello world&quot;) &#125; &#125; &#125; server &#123; listen 8082; location / &#123; default_type text/plain; content_by_lua_block &#123; ngx.say(&quot;hello world 8082&quot;) &#125; &#125; &#125; server &#123; listen 8080; ## 查看当前使用的 upstream location /call_upstream &#123; header_filter_by_lua_block &#123; local upstream = require &quot;ngx.upstream&quot; ngx.log(ngx.INFO,&quot;current upstream:&quot;, upstream.current_upstream_name()) &#125; proxy_pass http://backend; &#125; ## 查看所有 upstream location /status_upstream &#123; content_by_lua_block &#123; local upstream = require &quot;ngx.upstream&quot; local us = upstream.get_upstreams() for _, v in ipairs(us) do ngx.log(ngx.INFO, &quot;upstream name:&quot;, v) local servers, _ = upstream.get_servers(v) if not servers then ngx.log(ngx.ERR, &quot;no server in upstream&quot;) else for idx, s in ipairs (servers) do local msg = &quot;idx:&quot; .. idx for k, v in pairs (s) do msg = msg .. &quot; &quot; .. k .. &quot;:&quot; if type(v) == &quot;table&quot; then msg = msg .. table.concat(v, &quot;,&quot;) else msg = msg .. tostring(v) end end ngx.log(ngx.INFO, msg) end end end &#125; &#125; ## 将 backend 中第一个启用 server 设置为 down 状态 location /set_upstream &#123; content_by_lua_block &#123; local upstream = require &quot;ngx.upstream&quot; upstream.set_peer_down(&quot;backend&quot;, false, 0, false) &#125; &#125; &#125;&#125; 1. 示例运行在调用 status_upstream、set_upstream、status_upstream 调用顺序中，最终并无法看到 server 被标记为 down 状态。这是 set_peer_down 修改的是 round_robin 模块中 server 的标记，get_servers 读取的是配置结构体（ngx_http_upstream_server_t）中的内容。 2. get_servers 函数如果 server 未指定 down/backup 标记，在 get_servers 函数返回值中不会包含 down/backup 状态。 三 后记在 lua-upstream 模块的 TODO 中有提及动态添加、删除 server 的考虑，到时候应该会更好用。 四 链接 项目连接","categories":[{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/categories/NGINX/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"Lua","slug":"Lua","permalink":"https://juzipeek.github.io/tags/Lua/"},{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/tags/NGINX/"}]},{"title":"OpenResty Api - ngx.arg","slug":"nginx-2019-07-08-openresty-api-ngx-arg","date":"2022-09-03T12:55:44.506Z","updated":"2022-09-03T12:55:44.507Z","comments":true,"path":"2022/09/03/nginx-2019-07-08-openresty-api-ngx-arg/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/nginx-2019-07-08-openresty-api-ngx-arg/","excerpt":"","text":"一 概述本文主要介绍 OpenResty 中各 Api 功能，加深学习印象。 二 ngx.argngx.arg 在 body filter 阶段用来读取、更新应答数据。其中 ngx.arg[1] 是待发送的 body，ngx.arg[2] 指示后续是否还有待发送数据。 ngx.arg 变量是 table 类型，只支持 __index（获取）和 __newindex（更新）两个元方法。__index 方法由 ngx_http_lua_body_filter_param_get 函数最终实现，__newindex 方法由 ngx_http_lua_body_filter_param_set 函数最终实现。 1. 获取函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192intngx_http_lua_body_filter_param_get(lua_State *L)&#123; u_char *data, *p; size_t size; ngx_chain_t *cl; ngx_buf_t *b; int idx; ngx_chain_t *in; idx = luaL_checkint(L, 2); dd(&quot;index: %d&quot;, idx); if (idx != 1 &amp;&amp; idx != 2) &#123; lua_pushnil(L); return 1; &#125; // ngx_http_lua_chain_key： // 从全局获得值并压入栈 lua_getglobal(L, ngx_http_lua_chain_key); // 将栈顶元素出栈转换为 userdata（ngx_chain_t*）类型， // 此内容为 body 的 ngx_chain_t in = lua_touserdata(L, -1); // 如果调用 ngx.arg[2],使用来判断是否发送结束 if (idx == 2) &#123; /* asking for the eof argument */ for (cl = in; cl; cl = cl-&gt;next) &#123; // 最后的 buf，说明发送完毕 if (cl-&gt;buf-&gt;last_buf || cl-&gt;buf-&gt;last_in_chain) &#123; lua_pushboolean(L, 1); return 1; &#125; &#125; lua_pushboolean(L, 0); return 1; &#125; /* idx == 1 */ // ngx.arg[1] 用来取应答包体（ngx_chain_t）中内容 size = 0; if (in == NULL) &#123; /* being a cleared chain on the Lua land */ lua_pushliteral(L, &quot;&quot;); return 1; &#125; // 应答内容在一个 buf 中，直接压入栈顶，返回 if (in-&gt;next == NULL) &#123; dd(&quot;seen only single buffer&quot;); b = in-&gt;buf; lua_pushlstring(L, (char *) b-&gt;pos, b-&gt;last - b-&gt;pos); return 1; &#125; dd(&quot;seen multiple buffers&quot;); // 计算应答内容的大小 for (cl = in; cl; cl = cl-&gt;next) &#123; b = cl-&gt;buf; size += b-&gt;last - b-&gt;pos; if (b-&gt;last_buf || b-&gt;last_in_chain) &#123; break; &#125; &#125; // 创建 size 大小缓冲区（userdata 类型），并压入栈顶 data = (u_char *) lua_newuserdata(L, size); // 将应答内容拷贝到缓冲区 for (p = data, cl = in; cl; cl = cl-&gt;next) &#123; b = cl-&gt;buf; p = ngx_copy(p, b-&gt;pos, b-&gt;last - b-&gt;pos); if (b-&gt;last_buf || b-&gt;last_in_chain) &#123; break; &#125; &#125; // 将栈上由 data 指向的 size 长度字符压入栈顶 // Lua 会生成给定字符串的内部副本，在函数返回后可以删除 data 指向的内容 lua_pushlstring(L, (char *) data, size); return 1;&#125; 2. 更新函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210intngx_http_lua_body_filter_param_set(lua_State *L, ngx_http_request_t *r, ngx_http_lua_ctx_t *ctx)&#123; int type; int idx; int found; u_char *data; size_t size; unsigned last; unsigned flush = 0; ngx_buf_t *b; ngx_chain_t *cl; ngx_chain_t *in; // 检查第二个参数是否是 int，如果是 int 则返回值 // 其实还是操作的栈，判断栈中从栈底开始第二个元素是否是 int 类型并返回 idx = luaL_checkint(L, 2); dd(&quot;index: %d&quot;, idx); if (idx != 1 &amp;&amp; idx != 2) &#123; return luaL_error(L, &quot;bad index: %d&quot;, idx); &#125; // 更新发送结束标识 if (idx == 2) &#123; /* overwriting the eof flag */ last = lua_toboolean(L, 3); // 获得应答 body 的 ngx_chain_t 数据 lua_getglobal(L, ngx_http_lua_chain_key); in = lua_touserdata(L, -1); // 将从栈顶开始向下的两个元素 pop 出栈(并未使用) lua_pop(L, 1); if (last) &#123; ctx-&gt;seen_last_in_filter = 1; /* the &quot;in&quot; chain cannot be NULL and we set the &quot;last_buf&quot; or * &quot;last_in_chain&quot; flag in the last buf of &quot;in&quot; */ // 设置应答 body 的 ngx_chain_t 中的标识为结束 for (cl = in; cl; cl = cl-&gt;next) &#123; if (cl-&gt;next == NULL) &#123; if (r == r-&gt;main) &#123; cl-&gt;buf-&gt;last_buf = 1; &#125; else &#123; cl-&gt;buf-&gt;last_in_chain = 1; &#125; break; &#125; &#125; &#125; else &#123; /* last == 0 */ // 设置应答 body 的 ngx_chain_t 中的标识为未结束 found = 0; for (cl = in; cl; cl = cl-&gt;next) &#123; b = cl-&gt;buf; if (b-&gt;last_buf) &#123; b-&gt;last_buf = 0; found = 1; &#125; if (b-&gt;last_in_chain) &#123; b-&gt;last_in_chain = 0; found = 1; &#125; if (found &amp;&amp; b-&gt;last == b-&gt;pos &amp;&amp; !ngx_buf_in_memory(b)) &#123; /* make it a special sync buf to make * ngx_http_write_filter_module happy. */ b-&gt;sync = 1; &#125; &#125; ctx-&gt;seen_last_in_filter = 0; &#125; return 0; &#125; /* idx == 1, overwriting the chunk data */ // 更新发送内容 // 获得从栈底(1)开始，第三个索引处的数据类型 type = lua_type(L, 3); switch (type) &#123; case LUA_TSTRING: case LUA_TNUMBER: // 直接转换为字符串，方便更新发送缓冲区 data = (u_char *) lua_tolstring(L, 3, &amp;size); break; case LUA_TNIL: /* discard the buffers */ // 从 _G 中获取 __ngx_cl 到栈顶 lua_getglobal(L, ngx_http_lua_chain_key); /* key val */ in = lua_touserdata(L, -1); lua_pop(L, 1); last = 0; for (cl = in; cl; cl = cl-&gt;next) &#123; b = cl-&gt;buf; if (b-&gt;flush) &#123; flush = 1; &#125; if (b-&gt;last_in_chain || b-&gt;last_buf) &#123; last = 1; &#125; dd(&quot;mark the buf as consumed: %d&quot;, (int) ngx_buf_size(b)); b-&gt;pos = b-&gt;last; &#125; /* cl == NULL */ goto done; case LUA_TTABLE: size = ngx_http_lua_calc_strlen_in_table(L, 3 /* index */, 3 /* arg */, 1 /* strict */); data = NULL; break; default: return luaL_error(L, &quot;bad chunk data type: %s&quot;, lua_typename(L, type)); &#125; // 从 _G 中获取 __ngx_cl 内容到栈顶 lua_getglobal(L, ngx_http_lua_chain_key); in = lua_touserdata(L, -1); lua_pop(L, 1); // 清空除栈底两个元素外的其他元素 last = 0; for (cl = in; cl; cl = cl-&gt;next) &#123; b = cl-&gt;buf; if (b-&gt;flush) &#123; flush = 1; &#125; if (b-&gt;last_buf || b-&gt;last_in_chain) &#123; last = 1; &#125; dd(&quot;mark the buf as consumed: %d&quot;, (int) ngx_buf_size(cl-&gt;buf)); cl-&gt;buf-&gt;pos = cl-&gt;buf-&gt;last; &#125; /* cl == NULL */ if (size == 0) &#123; goto done; &#125; cl = ngx_http_lua_chain_get_free_buf(r-&gt;connection-&gt;log, r-&gt;pool, &amp;ctx-&gt;free_bufs, size); if (cl == NULL) &#123; return luaL_error(L, &quot;no memory&quot;); &#125; // 拷贝应答内容到发送缓冲区 if (type == LUA_TTABLE) &#123; cl-&gt;buf-&gt;last = ngx_http_lua_copy_str_in_table(L, 3, cl-&gt;buf-&gt;last); &#125; else &#123; cl-&gt;buf-&gt;last = ngx_copy(cl-&gt;buf-&gt;pos, data, size); &#125;done:// 更新 last_buf 标记 if (last || flush) &#123; if (cl == NULL) &#123; cl = ngx_http_lua_chain_get_free_buf(r-&gt;connection-&gt;log, r-&gt;pool, &amp;ctx-&gt;free_bufs, 0); if (cl == NULL) &#123; return luaL_error(L, &quot;no memory&quot;); &#125; &#125; if (last) &#123; ctx-&gt;seen_last_in_filter = 1; if (r == r-&gt;main) &#123; cl-&gt;buf-&gt;last_buf = 1; &#125; else &#123; cl-&gt;buf-&gt;last_in_chain = 1; &#125; &#125; if (flush) &#123; cl-&gt;buf-&gt;flush = 1; &#125; &#125; // 更新 _G 中 __ngx_cl 值为最新值 lua_pushlightuserdata(L, cl); lua_setglobal(L, ngx_http_lua_chain_key); return 0;&#125; 三 Lua C API1. 栈结构在 C 与 Lua 之间传递数据是通过栈来实现，栈中的内容 TValue 类型（同时包含类型与值信息），在 C、Lua 间可以识别转换。栈顶可以用 -1 索引，栈底可以用 1 索引 调用 ngx.arg[2] = 1 时栈结构： 12345---------------------------------------| 正数索引 | 数据 | 负数索引 | 栈中位置 |---------------------------------------| 2 | 2 | -1 | 栈顶 || 1 | _G | -2 | 栈底 | 栈中 _G 是在 body filter 指令处理函数（ngx_http_lua_body_filter_inline 或 ngx_http_lua_body_filter_file）中设置的栈底环境变量（_G 全局 table）。 2. 函数说明lua_isnumber、lua_isstring 系列函数并不会判断参数类型，他们会进行类型转换，如果转换成功返回其值。这样的话，对于 string 类型可以调用 lua_isnumber 函数。 luaL_getn 四 参考资料 lua_newuserdata lua_pushlstring lua_pop","categories":[{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/categories/NGINX/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"Lua","slug":"Lua","permalink":"https://juzipeek.github.io/tags/Lua/"},{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/tags/NGINX/"},{"name":"OpenResty","slug":"OpenResty","permalink":"https://juzipeek.github.io/tags/OpenResty/"}]},{"title":"ngx_http_limit_req_module 模块","slug":"nginx-2019-03-24-ngx-http-limit-req-module-模块","date":"2022-09-03T12:55:44.506Z","updated":"2022-09-03T12:55:44.506Z","comments":true,"path":"2022/09/03/nginx-2019-03-24-ngx-http-limit-req-module-模块/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/nginx-2019-03-24-ngx-http-limit-req-module-%E6%A8%A1%E5%9D%97/","excerpt":"","text":"一 概述ngx_http_limit_req_module 模块可以用来限制请求频率。我们要明确限制的请求对象，如何区分一个请求？可以使用请求对端地址、URL 参数或者其他头\\包体信息。NGINX 使用多进程模式，如果仅在进程内实现频率限制，同一个请求被均衡到其他进程时频率限制会失效，此时需要使用共享内存同步频率信息。 二 模块说明ngx_http_limit_req_module 介入阶段：NGX_HTTP_PREACCESS_PHASE。 1. limit_req_zone 指令12# 指令limit_req_zone key zone=name:size rate=rate; 可使用域：http功能：设置一块共享内存用来保存 key 的状态参数。如果限制域的存储空间耗尽了，对于后续所有请求，服务器都会返回 503。 字段 含义 可取值 key 使用 key 在共享内存中保存/查询其对应值 变量（例如 $binary_remote_addr）、字符串（name）或者两者混合 rate 每个 key 平均访问频率限制 1r/s（每秒一个请求）,10r/m（每分钟十个请求） zone 共享内存声明，name 为共享内存名，size 为共享内存大小 2. limit_req 指令12# 语法limit_req zone=name [burst=number] [nodelay]; 可使用域：http\\server\\location 字段 含义 可取值 zone 引用 limit_req_zone 定义的共享内存 limit_req_zone 定义的 name burst 突发请求数，默认值为零，设置允许超过频率限制的请求数。如果超过平均频率的请求数小于 burst，那么请求会被延时处理；如果超过平均频率的请求数大于 burst，那么会返回 503 数值 nodelay 如果未设置 nodelay，在超过频率后会将当前请求放入定时器中，待时间到达后再进行请求处理。如果设置了 nodelay 则请求处理结束 nodelay 3. limit_req_status12# 语法limit_req_status code;# code 默认为 503 可使用域：http\\server\\location功能：设置拒绝请求的响应状态码 4. limit_req_log_level12# 语法limit_req_log_level info | notice | warn | error; 可使用域：http\\server\\location功能：设置因为访问频率过高拒绝或延迟处理请求时记录的日志级别，limit_req_log_level 设置的是拒绝处理请求的日志级别，延迟处理请求的日志级别比拒绝处理请求的日志级别低一个级别。例如：limit_req_log_level notice 拒绝处理的日志级别为 notice，延迟的日志级别为 info。 三 实现在 ngx_http_limit_req_module 中 key 使用红黑树结构存储。 1. 模块声明与指令定义123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 指令定义static ngx_command_t ngx_http_limit_req_commands[] = &#123; &#123; ngx_string(&quot;limit_req_zone&quot;), // 定义共享内存 NGX_HTTP_MAIN_CONF|NGX_CONF_TAKE3, ngx_http_limit_req_zone, // ... &#125;, &#123; ngx_string(&quot;limit_req&quot;),// 定义访问限制 NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE123, ngx_http_limit_req, // ... &#125;, &#123; ngx_string(&quot;limit_req_log_level&quot;), // 触发限制访问（拒绝/延时）时记录日志的级别 NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1, ngx_conf_set_enum_slot,// 使用枚举设置变量配置值 NGX_HTTP_LOC_CONF_OFFSET, offsetof(ngx_http_limit_req_conf_t, limit_log_level), &amp;ngx_http_limit_req_log_levels // 枚举值定义 &#125;, &#123; ngx_string(&quot;limit_req_status&quot;), // 返回状态码 NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1, ngx_conf_set_num_slot, NGX_HTTP_LOC_CONF_OFFSET, offsetof(ngx_http_limit_req_conf_t, status_code), &amp;ngx_http_limit_req_status_bounds // 枚举值定义 &#125;, ngx_null_command&#125;;// 模块的上下文static ngx_http_module_t ngx_http_limit_req_module_ctx = &#123; NULL, /* preconfiguration */ ngx_http_limit_req_init, /* postconfiguration 设置函数指针 */ NULL, /* create main configuration */ NULL, /* init main configuration */ NULL, /* create server configuration */ NULL, /* merge server configuration */ ngx_http_limit_req_create_conf, /* create location configuration */ ngx_http_limit_req_merge_conf /* merge location configuration */&#125;;// 模块定义ngx_module_t ngx_http_limit_req_module = &#123; NGX_MODULE_V1, &amp;ngx_http_limit_req_module_ctx, /* module context */ ngx_http_limit_req_commands, /* module directives */ NGX_HTTP_MODULE, /* module type */ // ... NGX_MODULE_V1_PADDING&#125;; 2. 共享内存初始化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114static char *ngx_http_limit_req_zone(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; u_char *p; size_t len; ssize_t size; ngx_str_t *value, name, s; ngx_int_t rate, scale; ngx_uint_t i; ngx_shm_zone_t *shm_zone; ngx_http_limit_req_ctx_t *ctx; ngx_http_compile_complex_value_t ccv; value = cf-&gt;args-&gt;elts; ctx = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_http_limit_req_ctx_t)); if (ctx == NULL) &#123; return NGX_CONF_ERROR; &#125; ngx_memzero(&amp;ccv, sizeof(ngx_http_compile_complex_value_t)); ccv.cf = cf; ccv.value = &amp;value[1]; ccv.complex_value = &amp;ctx-&gt;key; if (ngx_http_compile_complex_value(&amp;ccv) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; size = 0; rate = 1; scale = 1; name.len = 0; // 指令解析 // 配置示例：limit_req_zone $binary_remote_addr zone=limit_ip:50m rate=10r/s; for (i = 2; i &lt; cf-&gt;args-&gt;nelts; i++) &#123; if (ngx_strncmp(value[i].data, &quot;zone=&quot;, 5) == 0) &#123; // name name.data = value[i].data + 5; p = (u_char *) ngx_strchr(name.data, &#x27;:&#x27;); if (p == NULL) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;invalid zone size \\&quot;%V\\&quot;&quot;, &amp;value[i]); return NGX_CONF_ERROR; &#125; name.len = p - name.data; // size s.data = p + 1; s.len = value[i].data + value[i].len - s.data; size = ngx_parse_size(&amp;s); if (size == NGX_ERROR) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,&quot;invalid zone size \\&quot;%V\\&quot;&quot;, &amp;value[i]); return NGX_CONF_ERROR; &#125; // 共享内存大小不能小于 8 个 page_size if (size &lt; (ssize_t) (8 * ngx_pagesize)) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;zone \\&quot;%V\\&quot; is too small&quot;, &amp;value[i]); return NGX_CONF_ERROR; &#125; continue; &#125; if (ngx_strncmp(value[i].data, &quot;rate=&quot;, 5) == 0) &#123; len = value[i].len; p = value[i].data + len - 3; if (ngx_strncmp(p, &quot;r/s&quot;, 3) == 0) &#123; scale = 1; len -= 3; &#125; else if (ngx_strncmp(p, &quot;r/m&quot;, 3) == 0) &#123; scale = 60; len -= 3; &#125; rate = ngx_atoi(value[i].data + 5, len - 5); if (rate &lt;= 0) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;invalid rate \\&quot;%V\\&quot;&quot;, &amp;value[i]); return NGX_CONF_ERROR; &#125; continue; &#125; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;invalid parameter \\&quot;%V\\&quot;&quot;, &amp;value[i]); return NGX_CONF_ERROR; &#125; if (name.len == 0) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;\\&quot;%V\\&quot; must have \\&quot;zone\\&quot; parameter&quot;, &amp;cmd-&gt;name); return NGX_CONF_ERROR; &#125; ctx-&gt;rate = rate * 1000 / scale; // 将共享内存添加到 cycle-&gt;shared_memory 动态数组中，统一管理 shm_zone = ngx_shared_memory_add(cf, &amp;name, size, &amp;ngx_http_limit_req_module); if (shm_zone == NULL) &#123; return NGX_CONF_ERROR; &#125; if (shm_zone-&gt;data) &#123; ctx = shm_zone-&gt;data; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;%V \\&quot;%V\\&quot; is already bound to key \\&quot;%V\\&quot;&quot;, &amp;cmd-&gt;name, &amp;name, &amp;ctx-&gt;key.value); return NGX_CONF_ERROR; &#125; // 共享内存通过 ngx_http_limit_req_init_zone 创建并初始化 shm_zone-&gt;init = ngx_http_limit_req_init_zone; shm_zone-&gt;data = ctx; return NGX_CONF_OK;&#125; ngx_http_limit_req_zone 函数并没有立即创建共享内存，仅将共享内存配置信息解析并放在 cycle 中统一管理。配置解析，功能实现分开，思路非常棒，凡事都理清。 在调用 ngx_http_limit_req_init_zone 之前 NGINX 已经根据配置创建好了共享内存，在 ngx_http_limit_req_init_zone 函数中主要做的是如何使用这块共享内存。NGINX 已经将共享内存申请的重复工作封装好，我们只需要将共享内存配置信息创建好，它可以替我们创建好共享内存直接使用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657static ngx_int_tngx_http_limit_req_init_zone(ngx_shm_zone_t *shm_zone, void *data)&#123; ngx_http_limit_req_ctx_t *octx = data; size_t len; ngx_http_limit_req_ctx_t *ctx; ctx = shm_zone-&gt;data; if (octx) &#123; if (ctx-&gt;key.value.len != octx-&gt;key.value.len || ngx_strncmp(ctx-&gt;key.value.data, octx-&gt;key.value.data, ctx-&gt;key.value.len) != 0) &#123; ngx_log_error(NGX_LOG_EMERG, shm_zone-&gt;shm.log, 0, &quot;limit_req \\&quot;%V\\&quot; uses the \\&quot;%V\\&quot; key while previously it used the \\&quot;%V\\&quot; key&quot;, &amp;shm_zone-&gt;shm.name, &amp;ctx-&gt;key.value, &amp;octx-&gt;key.value); return NGX_ERROR; &#125; ctx-&gt;sh = octx-&gt;sh; ctx-&gt;shpool = octx-&gt;shpool; return NGX_OK; &#125; // 直接使用 NGINX 创建的共享内存 ctx-&gt;shpool = (ngx_slab_pool_t *) shm_zone-&gt;shm.addr; if (shm_zone-&gt;shm.exists) &#123; ctx-&gt;sh = ctx-&gt;shpool-&gt;data; return NGX_OK; &#125; ctx-&gt;sh = ngx_slab_alloc(ctx-&gt;shpool, sizeof(ngx_http_limit_req_shctx_t)); if (ctx-&gt;sh == NULL) &#123; return NGX_ERROR; &#125; ctx-&gt;shpool-&gt;data = ctx-&gt;sh; // 初始化红黑树 ngx_rbtree_init(&amp;ctx-&gt;sh-&gt;rbtree, &amp;ctx-&gt;sh-&gt;sentinel, ngx_http_limit_req_rbtree_insert_value); // 初始化 LRU 队列 ngx_queue_init(&amp;ctx-&gt;sh-&gt;queue); len = sizeof(&quot; in limit_req zone \\&quot;\\&quot;&quot;) + shm_zone-&gt;shm.name.len; ctx-&gt;shpool-&gt;log_ctx = ngx_slab_alloc(ctx-&gt;shpool, len); if (ctx-&gt;shpool-&gt;log_ctx == NULL) &#123; return NGX_ERROR; &#125; ngx_sprintf(ctx-&gt;shpool-&gt;log_ctx, &quot; in limit_req zone \\&quot;%V\\&quot;%Z&quot;, &amp;shm_zone-&gt;shm.name); ctx-&gt;shpool-&gt;log_nomem = 0; return NGX_OK;&#125; 3. 访问限制配置limit_req_zone 指令用来声明共享内存，limit_req 指令用来在当前范围启用访问限制。limit_req 指令主要功能是将访问限制配置添加到main\\server\\location 级别的模块配置结构体中，main\\server\\location 级别可以有多个访问限制，通过动态数组来组织。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879static char *ngx_http_limit_req(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; ngx_http_limit_req_conf_t *lrcf = conf; ngx_int_t burst; ngx_str_t *value, s; ngx_uint_t i, nodelay; ngx_shm_zone_t *shm_zone; ngx_http_limit_req_limit_t *limit, *limits; value = cf-&gt;args-&gt;elts; shm_zone = NULL; burst = 0; nodelay = 0; // 配置信息解析 for (i = 1; i &lt; cf-&gt;args-&gt;nelts; i++) &#123; if (ngx_strncmp(value[i].data, &quot;zone=&quot;, 5) == 0) &#123; s.len = value[i].len - 5; s.data = value[i].data + 5; shm_zone = ngx_shared_memory_add(cf, &amp;s, 0, &amp;ngx_http_limit_req_module); if (shm_zone == NULL) &#123; return NGX_CONF_ERROR; &#125; continue; &#125; if (ngx_strncmp(value[i].data, &quot;burst=&quot;, 6) == 0) &#123; burst = ngx_atoi(value[i].data + 6, value[i].len - 6); if (burst &lt;= 0) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;invalid burst rate \\&quot;%V\\&quot;&quot;, &amp;value[i]); return NGX_CONF_ERROR; &#125; continue; &#125; if (ngx_strcmp(value[i].data, &quot;nodelay&quot;) == 0) &#123; nodelay = 1; continue; &#125; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;invalid parameter \\&quot;%V\\&quot;&quot;, &amp;value[i]); return NGX_CONF_ERROR; &#125; // 判断是否是非法配置 if (shm_zone == NULL) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;\\&quot;%V\\&quot; must have \\&quot;zone\\&quot; parameter&quot;, &amp;cmd-&gt;name); return NGX_CONF_ERROR; &#125; // 获得访问配置限制的动态数组 limits = lrcf-&gt;limits.elts; if (limits == NULL) &#123; if (ngx_array_init(&amp;lrcf-&gt;limits, cf-&gt;pool, 1, sizeof(ngx_http_limit_req_limit_t)) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; &#125; // 直接通过共享内存判断是否已添加相同访问限制 for (i = 0; i &lt; lrcf-&gt;limits.nelts; i++) &#123; if (shm_zone == limits[i].shm_zone) &#123; return &quot;is duplicate&quot;; &#125; &#125; // 添加新的访问限制项 limit = ngx_array_push(&amp;lrcf-&gt;limits); if (limit == NULL) &#123; return NGX_CONF_ERROR; &#125; limit-&gt;shm_zone = shm_zone; limit-&gt;burst = burst * 1000; limit-&gt;nodelay = nodelay; return NGX_CONF_OK;&#125; 4. 共享内存查找ngx_http_limit_req_lookup 用于在共享内存中查找、新增节点。当未查找到节点时会分配新的节点用以存储当前请求统计信息，并将当前节点加入 LRU 队列首部；当查找到时会将 LRU 队列中当前节点重新插入到首部，并计算请求频率以及超出值更新到节点中，根据是否超出返回相应应答。account 参数用来判断当前访问现在是否是当前域的最后限制，**limit_req 模块仅在最后一个访问限制配置中保存访问信息**。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120static ngx_int_tngx_http_limit_req_lookup(ngx_http_limit_req_limit_t *limit, ngx_uint_t hash, ngx_str_t *key, ngx_uint_t *ep, ngx_uint_t account)&#123; size_t size; ngx_int_t rc, excess; ngx_msec_t now; ngx_msec_int_t ms; ngx_rbtree_node_t *node, *sentinel; ngx_http_limit_req_ctx_t *ctx; ngx_http_limit_req_node_t *lr; now = ngx_current_msec; ctx = limit-&gt;shm_zone-&gt;data; // 红黑树查找 node = ctx-&gt;sh-&gt;rbtree.root; sentinel = ctx-&gt;sh-&gt;rbtree.sentinel; while (node != sentinel) &#123; // 递归查找左右子树 if (hash &lt; node-&gt;key) &#123; node = node-&gt;left; continue; &#125; if (hash &gt; node-&gt;key) &#123; node = node-&gt;right; continue; &#125; /* hash == node-&gt;key */ lr = (ngx_http_limit_req_node_t *) &amp;node-&gt;color; rc = ngx_memn2cmp(key-&gt;data, lr-&gt;data, key-&gt;len, (size_t) lr-&gt;len); if (rc == 0) &#123; // 找到节点 // queue 使用 list_head 结构，所有根据当前节点就可以直接完成删除操作 ngx_queue_remove(&amp;lr-&gt;queue); ngx_queue_insert_head(&amp;ctx-&gt;sh-&gt;queue, &amp;lr-&gt;queue); ms = (ngx_msec_int_t) (now - lr-&gt;last); // lr-&gt;excess ：历史超出数 // ctx-&gt;rate * ms : 根据与上次请求间隔计算出这段时间允许通过的个数 excess = lr-&gt;excess - ctx-&gt;rate * ngx_abs(ms) / 1000 + 1000; if (excess &lt; 0) &#123; excess = 0; &#125; *ep = excess; if ((ngx_uint_t) excess &gt; limit-&gt;burst) &#123; return NGX_BUSY; &#125; // 仅在最后的访问限制中添加节点 if (account) &#123; lr-&gt;excess = excess; lr-&gt;last = now; return NGX_OK; &#125; lr-&gt;count++; // 访问计数增加 1 ctx-&gt;node = lr; return NGX_AGAIN; &#125; // key 不相同，继续查找左右子树 node = (rc &lt; 0) ? node-&gt;left : node-&gt;right; &#125; // 未找到，添加新节点 *ep = 0; size = offsetof(ngx_rbtree_node_t, color) + offsetof(ngx_http_limit_req_node_t, data) + key-&gt;len; // 从 LRU 队列、红黑树中删除一或两个请求频率为零的节点 // 1. 如果待删除的节点访问时间在一分钟内则不删除 // 2. 如果待删除的节点请求频率大于零则不删除 ngx_http_limit_req_expire(ctx, 1); node = ngx_slab_alloc_locked(ctx-&gt;shpool, size); if (node == NULL) &#123; // 删除最旧的访问节点 // 如果第二第三旧的节点在最近一分钟内没有访问则删除 // 如果第二第三旧的节点访问频率等于零则删除 ngx_http_limit_req_expire(ctx, 0); node = ngx_slab_alloc_locked(ctx-&gt;shpool, size); if (node == NULL) &#123; ngx_log_error(NGX_LOG_ALERT, ngx_cycle-&gt;log, 0, &quot;could not allocate node%s&quot;, ctx-&gt;shpool-&gt;log_ctx); return NGX_ERROR; &#125; &#125; node-&gt;key = hash; lr = (ngx_http_limit_req_node_t *) &amp;node-&gt;color; lr-&gt;len = (u_short) key-&gt;len; lr-&gt;excess = 0; ngx_memcpy(lr-&gt;data, key-&gt;data, key-&gt;len); ngx_rbtree_insert(&amp;ctx-&gt;sh-&gt;rbtree, node); ngx_queue_insert_head(&amp;ctx-&gt;sh-&gt;queue, &amp;lr-&gt;queue); if (account) &#123; lr-&gt;last = now; lr-&gt;count = 0; return NGX_OK; &#125; lr-&gt;last = 0; lr-&gt;count = 1; // 新节点，访问计数设置为 1 ctx-&gt;node = lr; return NGX_AGAIN;&#125; 5. 业务处理接口ngx_http_limit_req_handler 函数介入 NGX_HTTP_PREACCESS_PHASE 处理阶段。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129static ngx_int_tngx_http_limit_req_handler(ngx_http_request_t *r)&#123; uint32_t hash; ngx_str_t key; ngx_int_t rc; ngx_uint_t n, excess; ngx_msec_t delay; ngx_http_limit_req_ctx_t *ctx; ngx_http_limit_req_conf_t *lrcf; ngx_http_limit_req_limit_t *limit, *limits; if (r-&gt;main-&gt;limit_req_set) &#123; return NGX_DECLINED; &#125; // 取得 location 级别的访问限制动态数组 lrcf = ngx_http_get_module_loc_conf(r, ngx_http_limit_req_module); limits = lrcf-&gt;limits.elts; excess = 0; rc = NGX_DECLINED;#if (NGX_SUPPRESS_WARN) limit = NULL;#endif for (n = 0; n &lt; lrcf-&gt;limits.nelts; n++) &#123; limit = &amp;limits[n]; ctx = limit-&gt;shm_zone-&gt;data; // 从请求中计算 key if (ngx_http_complex_value(r, &amp;ctx-&gt;key, &amp;key) != NGX_OK) &#123; return NGX_HTTP_INTERNAL_SERVER_ERROR; &#125; // key 长度限制 if (key.len == 0) &#123; continue; &#125; // key 长度限制 if (key.len &gt; 65535) &#123; ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0, &quot;the value of the \\&quot;%V\\&quot; key is more than 65535 bytes: \\&quot;%V\\&quot;&quot;, &amp;ctx-&gt;key.value, &amp;key); continue; &#125; hash = ngx_crc32_short(key.data, key.len); ngx_shmtx_lock(&amp;ctx-&gt;shpool-&gt;mutex); // 共享内存中查找 key;访问是否超限在此处判断 // rc 有可能取值：NGX_ERROR,NGX_OK,NGX_AGAIN,NGX_BUSY // NGX_ERROR =&gt; 出错 // NGX_OK =&gt; 未超限 // NGX_AGAIN =&gt; 查找其他访问限制 // NGX_BUSY =&gt; 访问已超限 rc = ngx_http_limit_req_lookup(limit, hash, &amp;key, &amp;excess, (n == lrcf-&gt;limits.nelts - 1)); ngx_shmtx_unlock(&amp;ctx-&gt;shpool-&gt;mutex); ngx_log_debug4(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, &quot;limit_req[%ui]: %i %ui.%03ui&quot;, n, rc, excess / 1000, excess % 1000); if (rc != NGX_AGAIN) &#123; break; &#125; &#125; // NGX_DECLINED 表示不存在访问限制，即 lrcf-&gt;limits.nelts == 0；本模块不进行处理 if (rc == NGX_DECLINED) &#123; return NGX_DECLINED; &#125; // 设置标记，已经进行过访问限制检查 r-&gt;main-&gt;limit_req_set = 1; // 请求被限制 if (rc == NGX_BUSY || rc == NGX_ERROR) &#123; if (rc == NGX_BUSY) &#123; ngx_log_error(lrcf-&gt;limit_log_level, r-&gt;connection-&gt;log, 0, &quot;limiting requests, excess: %ui.%03ui by zone \\&quot;%V\\&quot;&quot;, excess / 1000, excess % 1000, &amp;limit-&gt;shm_zone-&gt;shm.name); &#125; // 遍历所有访问限制，因为本次访问被限制，应该将更新过的节点访问计数减 1 // 在 ngx_http_limit_req_lookup 中已经将 ctx-&gt;node 设置为当前请求节点 while (n--) &#123; ctx = limits[n].shm_zone-&gt;data; if (ctx-&gt;node == NULL) &#123; continue; &#125; ngx_shmtx_lock(&amp;ctx-&gt;shpool-&gt;mutex); ctx-&gt;node-&gt;count--; ngx_shmtx_unlock(&amp;ctx-&gt;shpool-&gt;mutex); ctx-&gt;node = NULL; &#125; // 范围设置的应答码 return lrcf-&gt;status_code; &#125; /* rc == NGX_AGAIN || rc == NGX_OK */ if (rc == NGX_AGAIN) &#123; excess = 0; &#125; // 更新各个访问限制的超出值以及请求计数，计算需要的最大的延时时间 // 延时时间 = 超出值/允许平局速率 delay = ngx_http_limit_req_account(limits, n, &amp;excess, &amp;limit); if (!delay) &#123; return NGX_DECLINED; &#125; ngx_log_error(lrcf-&gt;delay_log_level, r-&gt;connection-&gt;log, 0, &quot;delaying request, excess: %ui.%03ui, by zone \\&quot;%V\\&quot;&quot;, excess / 1000, excess % 1000, &amp;limit-&gt;shm_zone-&gt;shm.name); // 读事件处理 if (ngx_handle_read_event(r-&gt;connection-&gt;read, 0) != NGX_OK) &#123; return NGX_HTTP_INTERNAL_SERVER_ERROR; &#125; r-&gt;read_event_handler = ngx_http_test_reading; r-&gt;write_event_handler = ngx_http_limit_req_delay; r-&gt;connection-&gt;write-&gt;delayed = 1; // 添加延时处理定时器，delay 时间到达后调用 ngx_http_limit_req_delay 函数处理 ngx_add_timer(r-&gt;connection-&gt;write, delay); return NGX_AGAIN;&#125; 6. 延时后处理如果请求需要延时处理会将请求放入定时器中，当定时时间到后会执行定时器中超时处理函数 ngx_http_limit_req_delay。 123456789101112131415161718192021222324252627static voidngx_http_limit_req_delay(ngx_http_request_t *r)&#123; ngx_event_t *wev; ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, &quot;limit_req delay&quot;); // 有写事件，处理，直接结束请求 wev = r-&gt;connection-&gt;write; if (wev-&gt;delayed) &#123; if (ngx_handle_write_event(wev, 0) != NGX_OK) &#123; ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR); &#125; return; &#125; // 有读事件，处理，直接结束请求 if (ngx_handle_read_event(r-&gt;connection-&gt;read, 0) != NGX_OK) &#123; ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR); return; &#125; // 回归原有处理逻辑；继续进行 HTTP 各阶段处理 r-&gt;read_event_handler = ngx_http_block_reading; r-&gt;write_event_handler = ngx_http_core_run_phases; ngx_http_core_run_phases(r);&#125; 四 HTTP 应答码解释 204 服务器成功处理了请求，没有返回任何内容。 444 Nginx 上 HTTP 服务器扩展。服务器不向客户端返回任何信息，并关闭连接（有助于阻止恶意软件）。 503 服务不可用。 五 总结在使用 ngx_http_limit_req_module 时可以自己添加变量，变量值为请求头或包体中内容用于区分请求，直接使用官方模块实现访问频率限制。 六 ngx_http_limit_conn_module 说明ngx_http_limit_conn_module 与本模块功能相似，但是 limit_conn 的限制对象是连接数，只需要将键的连接数保存在共享内存中就可以。不过 limit_conn 同样有另外一个问题，在连接建立请求时可以累计连接数，但是连接关闭时如何减少连接数呢？limit_conn 采用的方法是在当前请求的连接池清理函数中添加清理函数 ngx_http_limit_conn_cleanup 用于减少计数清理内存。 ngx_http_limit_conn|req_module 模块在共享内存空间不够时均返回配置的应答码给客户端。 六 参考连接 NGINX 官方文档 HTTP 状态码 网友链接同时也是公式出处","categories":[{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/categories/NGINX/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/tags/NGINX/"}]},{"title":"ngx-rtmp-module","slug":"nginx-2019-02-16-ngx-rtmp","date":"2022-09-03T12:55:44.505Z","updated":"2022-09-03T12:55:44.505Z","comments":true,"path":"2022/09/03/nginx-2019-02-16-ngx-rtmp/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/nginx-2019-02-16-ngx-rtmp/","excerpt":"","text":"功能","categories":[{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/categories/NGINX/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"Linux","slug":"Linux","permalink":"https://juzipeek.github.io/tags/Linux/"},{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/tags/NGINX/"}]},{"title":"Nginx FIND_CONFIG 阶段介绍","slug":"nginx-2019-02-22-Nginx-FIND-CONFIG-阶段介绍","date":"2022-09-03T12:55:44.505Z","updated":"2022-09-03T12:55:44.505Z","comments":true,"path":"2022/09/03/nginx-2019-02-22-Nginx-FIND-CONFIG-阶段介绍/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/nginx-2019-02-22-Nginx-FIND-CONFIG-%E9%98%B6%E6%AE%B5%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"location 匹配规则location 的 5 种可选配置前缀： ~：正则匹配（区分大小写） ~*：正则匹配（不区分大小写） =：精确匹配 ^~：只匹配字符串，不查询正则表达式 @：制定一个命名的 location 上述前缀中，只有 ~ 和 ~* 是正则匹配，对于 NGINX 来说，优先级最高的是 = 匹配，接下来是普通匹配，最后会去匹配正则匹配。使用如下规则： 如果 = 匹配符合，会立即使用该 location 配置，而不会对后续 location 配置进行匹配。 对于 @ 匹配，只有请求是内部重定向请求时才会使用，普通请求不会进行匹配。 对于没有匹配成功上述两种匹配的所有普通匹配的 location，NGINX 进行最长前缀匹配，匹配结果与配置文件中 location 的编辑顺序并没有关系。 得到普通匹配的最长前缀匹配 location 以后，如果这个 location 不是 ^~ 匹配（标识不查询正则表达式），那么并不会结束匹配过程，而是会继续进行正则匹配，按照配置文件中 location 的编辑顺序得到首个匹配成功的正则匹配 location。 如果同时匹配到了普通匹配和正则匹配的 location 结果，nginx 会选取正则匹配的 location 作为最终的匹配结果。 功能介绍NGX_HTTP_FIND_CONFIG_PHASE 是 Nginx 中不可介入的处理阶段，主要功能是对当前请求进行 location 查找。查找的顺序： 根据请求获取请求所在 server 块的 loc_conf 配置 从 clcf 的静态 location 三叉树（左右子树以及当前节点的子树）查找，匹配最大前缀匹配 进行正则表达式查找 NGINX 框架代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798// FIND_CONFIG 阶段的 checker 函数ngx_int_tngx_http_core_find_config_phase(ngx_http_request_t *r, ngx_http_phase_handler_t *ph)&#123; u_char *p; size_t len; ngx_int_t rc; ngx_http_core_loc_conf_t *clcf; r-&gt;content_handler = NULL; r-&gt;uri_changed = 0; // 查找 location rc = ngx_http_core_find_location(r); if (rc == NGX_ERROR) &#123; ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR); return NGX_OK; &#125; clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module); // 本请求非内部请求，location 是内部 location =&gt; 拒绝访问 if (!r-&gt;internal &amp;&amp; clcf-&gt;internal) &#123; ngx_http_finalize_request(r, NGX_HTTP_NOT_FOUND); return NGX_OK; &#125; ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, &quot;using configuration \\&quot;%s%V\\&quot;&quot;, (clcf-&gt;noname ? &quot;*&quot; : (clcf-&gt;exact_match ? &quot;=&quot; : &quot;&quot;)), &amp;clcf-&gt;name); // 根据查找到的 location 更新请求的属性 ngx_http_update_location_config(r); ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, &quot;http cl:%O max:%O&quot;, r-&gt;headers_in.content_length_n, clcf-&gt;client_max_body_size); // 检查 location 内对包体大小的限制以及当前请求包体是否大于限制 if (r-&gt;headers_in.content_length_n != -1 &amp;&amp; !r-&gt;discard_body &amp;&amp; clcf-&gt;client_max_body_size &amp;&amp; clcf-&gt;client_max_body_size &lt; r-&gt;headers_in.content_length_n) &#123; ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0, &quot;client intended to send too large body: %O bytes&quot;, r-&gt;headers_in.content_length_n); r-&gt;expect_tested = 1; (void) ngx_http_discard_request_body(r); ngx_http_finalize_request(r, NGX_HTTP_REQUEST_ENTITY_TOO_LARGE); return NGX_OK; &#125; // 301 重定向处理 // 返回 301 应答码，并设置 http 头指向新的 location if (rc == NGX_DONE) &#123; ngx_http_clear_location(r); r-&gt;headers_out.location = ngx_list_push(&amp;r-&gt;headers_out.headers); if (r-&gt;headers_out.location == NULL) &#123; ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR); return NGX_OK; &#125; r-&gt;headers_out.location-&gt;hash = 1; ngx_str_set(&amp;r-&gt;headers_out.location-&gt;key, &quot;Location&quot;); if (r-&gt;args.len == 0) &#123; r-&gt;headers_out.location-&gt;value = clcf-&gt;name; &#125; else &#123; len = clcf-&gt;name.len + 1 + r-&gt;args.len; p = ngx_pnalloc(r-&gt;pool, len); if (p == NULL) &#123; ngx_http_clear_location(r); ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR); return NGX_OK; &#125; r-&gt;headers_out.location-&gt;value.len = len; r-&gt;headers_out.location-&gt;value.data = p; p = ngx_cpymem(p, clcf-&gt;name.data, clcf-&gt;name.len); *p++ = &#x27;?&#x27;; ngx_memcpy(p, r-&gt;args.data, r-&gt;args.len); &#125; ngx_http_finalize_request(r, NGX_HTTP_MOVED_PERMANENTLY); return NGX_OK; &#125; r-&gt;phase_handler++; return NGX_AGAIN;&#125; 静态 location 查找： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158/* * NGX_OK - exact or regex match * NGX_DONE - auto redirect * NGX_AGAIN - inclusive match * NGX_ERROR - regex error * NGX_DECLINED - no match */static ngx_int_tngx_http_core_find_location(ngx_http_request_t *r)&#123; ngx_int_t rc; ngx_http_core_loc_conf_t *pclcf;#if (NGX_PCRE) ngx_int_t n; ngx_uint_t noregex; ngx_http_core_loc_conf_t *clcf, **clcfp; noregex = 0;#endif // 首先从当前 server 块的 loc_conf 获取配置 pclcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module); rc = ngx_http_core_find_static_location(r, pclcf-&gt;static_locations); // 需要到子 location 中进行查找 if (rc == NGX_AGAIN) &#123;#if (NGX_PCRE) clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module); noregex = clcf-&gt;noregex;#endif /* look up nested locations */ rc = ngx_http_core_find_location(r); &#125; // NGX_OK 精确查找到 // NGX_DONE 需要重定向 if (rc == NGX_OK || rc == NGX_DONE) &#123; return rc; &#125; /* rc == NGX_DECLINED or rc == NGX_AGAIN in nested location */#if (NGX_PCRE) if (noregex == 0 &amp;&amp; pclcf-&gt;regex_locations) &#123; for (clcfp = pclcf-&gt;regex_locations; *clcfp; clcfp++) &#123; ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, &quot;test location: ~ \\&quot;%V\\&quot;&quot;, &amp;(*clcfp)-&gt;name); n = ngx_http_regex_exec(r, (*clcfp)-&gt;regex, &amp;r-&gt;uri); if (n == NGX_OK) &#123; r-&gt;loc_conf = (*clcfp)-&gt;loc_conf; /* look up nested locations */ rc = ngx_http_core_find_location(r); return (rc == NGX_ERROR) ? rc : NGX_OK; &#125; if (n == NGX_DECLINED) &#123; continue; &#125; return NGX_ERROR; &#125; &#125;#endif return rc;&#125;/* * NGX_OK - exact match * NGX_DONE - auto redirect * NGX_AGAIN - inclusive match * NGX_DECLINED - no match */static ngx_int_tngx_http_core_find_static_location(ngx_http_request_t *r, ngx_http_location_tree_node_t *node)&#123; u_char *uri; size_t len, n; ngx_int_t rc, rv; len = r-&gt;uri.len; uri = r-&gt;uri.data; rv = NGX_DECLINED; for ( ;; ) &#123; if (node == NULL) &#123; return rv; &#125; ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, &quot;test location: \\&quot;%*s\\&quot;&quot;, (size_t) node-&gt;len, node-&gt;name); n = (len &lt;= (size_t) node-&gt;len) ? len : node-&gt;len; rc = ngx_filename_cmp(uri, node-&gt;name, n); // 字符串不匹配 // 未查找到 location，继续进行查找 if (rc != 0) &#123; node = (rc &lt; 0) ? node-&gt;left : node-&gt;right; continue; &#125; // 字符串匹配，不过请求的 location 比当前比对上的 location 名长 // 如果当前 location 包含子 location，继续查找子 location;否则查找其他 location if (len &gt; (size_t) node-&gt;len) &#123; if (node-&gt;inclusive) &#123; r-&gt;loc_conf = node-&gt;inclusive-&gt;loc_conf; rv = NGX_AGAIN; node = node-&gt;tree; uri += n; len -= n; continue; &#125; /* exact only */ node = node-&gt;right; continue; &#125; // 请求 location 与当前节点 location 名相同 if (len == (size_t) node-&gt;len) &#123; if (node-&gt;exact) &#123; r-&gt;loc_conf = node-&gt;exact-&gt;loc_conf; return NGX_OK; &#125; else &#123; r-&gt;loc_conf = node-&gt;inclusive-&gt;loc_conf; return NGX_AGAIN; &#125; &#125; /* len &lt; node-&gt;len */ if (len + 1 == (size_t) node-&gt;len &amp;&amp; node-&gt;auto_redirect) &#123; r-&gt;loc_conf = (node-&gt;exact) ? node-&gt;exact-&gt;loc_conf: node-&gt;inclusive-&gt;loc_conf; rv = NGX_DONE; &#125; node = node-&gt;left; &#125;&#125;","categories":[{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/categories/NGINX/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/tags/NGINX/"}]},{"title":"Nginx POST_ACCESS 阶段介绍","slug":"nginx-2019-02-22-Nginx-POST-ACCESS-阶段介绍","date":"2022-09-03T12:55:44.505Z","updated":"2022-09-03T12:55:44.505Z","comments":true,"path":"2022/09/03/nginx-2019-02-22-Nginx-POST-ACCESS-阶段介绍/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/nginx-2019-02-22-Nginx-POST-ACCESS-%E9%98%B6%E6%AE%B5%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"功能介绍NGX_HTTP_POST_ACCESS_PHASE 作为 Nginx 11 个处理阶段中不可修改的阶段其主要功能是判断 NGX_HTTP_ACCESS_PHASE 阶段处理的访问码是否有设置，如果有设置则给客户返回应答码。 总结来说，NGX_HTTP_POST_ACCESS_PHASE 用来给 NGX_HTTP_ACCESS_PHASE 阶段收尾，在 NGX_HTTP_ACCESS_PHASE 阶段仅关注是否授权访问，NGX_HTTP_POST_ACCESS_PHASE 阶段根据结果对连接做出处理。 NGINX 框架代码说明123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119// 各阶段处理函数初始化static ngx_int_tngx_http_init_phase_handlers(ngx_conf_t *cf, ngx_http_core_main_conf_t *cmcf)&#123;... cmcf-&gt;phase_engine.handlers = ph; n = 0; for (i = 0; i &lt; NGX_HTTP_LOG_PHASE; i++) &#123; h = cmcf-&gt;phases[i].handlers.elts; switch (i) &#123; case NGX_HTTP_SERVER_REWRITE_PHASE: if (cmcf-&gt;phase_engine.server_rewrite_index == (ngx_uint_t) -1) &#123; cmcf-&gt;phase_engine.server_rewrite_index = n; &#125; checker = ngx_http_core_rewrite_phase; break; case NGX_HTTP_FIND_CONFIG_PHASE: find_config_index = n; ph-&gt;checker = ngx_http_core_find_config_phase; n++; ph++; continue; case NGX_HTTP_REWRITE_PHASE: if (cmcf-&gt;phase_engine.location_rewrite_index == (ngx_uint_t) -1) &#123; cmcf-&gt;phase_engine.location_rewrite_index = n; &#125; checker = ngx_http_core_rewrite_phase; break; case NGX_HTTP_POST_REWRITE_PHASE: if (use_rewrite) &#123; ph-&gt;checker = ngx_http_core_post_rewrite_phase; ph-&gt;next = find_config_index; n++; ph++; &#125; continue; case NGX_HTTP_ACCESS_PHASE: checker = ngx_http_core_access_phase; n++; break; // 本阶段不允许其他处理函数介入 case NGX_HTTP_POST_ACCESS_PHASE: if (use_access) &#123; ph-&gt;checker = ngx_http_core_post_access_phase; ph-&gt;next = n; ph++; &#125; continue; case NGX_HTTP_TRY_FILES_PHASE: if (cmcf-&gt;try_files) &#123; ph-&gt;checker = ngx_http_core_try_files_phase; n++; ph++; &#125; continue; case NGX_HTTP_CONTENT_PHASE: checker = ngx_http_core_content_phase; break; default: checker = ngx_http_core_generic_phase; &#125; n += cmcf-&gt;phases[i].handlers.nelts; for (j = cmcf-&gt;phases[i].handlers.nelts - 1; j &gt;=0; j--) &#123; ph-&gt;checker = checker; ph-&gt;handler = h[j]; ph-&gt;next = n; ph++; &#125; &#125; return NGX_OK;&#125;// post_access_phase 阶段 checker 函数// 本阶段其实无处理函数，只有 checker 函数。ngx_http_core_post_access_phase 作为 checker 函数被调用ngx_int_tngx_http_core_post_access_phase(ngx_http_request_t *r, ngx_http_phase_handler_t *ph)&#123; ngx_int_t access_code; ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, &quot;post access phase: %ui&quot;, r-&gt;phase_handler); access_code = r-&gt;access_code; // 只要设置了 access_code 就会返回 access_code 应答码 if (access_code) &#123; if (access_code == NGX_HTTP_FORBIDDEN) &#123; ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0, &quot;access forbidden by rule&quot;); &#125; r-&gt;access_code = 0; ngx_http_finalize_request(r, access_code); return NGX_OK; &#125; r-&gt;phase_handler++; return NGX_AGAIN;&#125; 总结在写 ACCESS 阶段处理函数时，并不需要直接将连接关闭，更好的方式是设置当前请求的 r-&gt;access_code，最终由 NGX_HTTP_POST_ACCESS_PHASE 进行应答处理。 只有将目的想清楚，功能点才能切分好设计才会清晰。","categories":[{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/categories/NGINX/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/tags/NGINX/"}]},{"title":"ngx_http_proxy_module 模块","slug":"nginx-2019-03-02-ngx-http-proxy-module-模块","date":"2022-09-03T12:55:44.505Z","updated":"2022-09-03T12:55:44.506Z","comments":true,"path":"2022/09/03/nginx-2019-03-02-ngx-http-proxy-module-模块/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/nginx-2019-03-02-ngx-http-proxy-module-%E6%A8%A1%E5%9D%97/","excerpt":"","text":"概述","categories":[{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/categories/NGINX/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/tags/NGINX/"}]},{"title":"","slug":"nginx-2019-02-16-nginx-http-模块配置文件结构","date":"2022-09-03T12:55:44.504Z","updated":"2022-09-03T12:55:44.504Z","comments":true,"path":"2022/09/03/nginx-2019-02-16-nginx-http-模块配置文件结构/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/nginx-2019-02-16-nginx-http-%E6%A8%A1%E5%9D%97%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/","excerpt":"","text":"gdb 输出12345678910111213# p *(ngx_http_conf_ctx_t *)ngx_cycle-&gt;conf_ctx[8]# http_core_loc_confp *(ngx_http_core_loc_conf_t*)(*(ngx_http_conf_ctx_t *)ngx_cycle-&gt;conf_ctx[8])-&gt;loc_conf# http_core_loc_conf 内部内容查看p *(*(ngx_http_core_loc_conf_t*)(*(ngx_http_conf_ctx_t *)ngx_cycle-&gt;conf_ctx[8])-&gt;loc_conf)-&gt;static_locationsp *(ngx_http_location_queue_t*)(*(ngx_http_core_loc_conf_t*)(*(ngx_http_conf_ctx_t *)ngx_cycle-&gt;conf_ctx[8])-&gt;loc_conf)-&gt;locationsp *(ngx_http_location_queue_t*)(*(ngx_http_core_loc_conf_t*)(*(ngx_http_conf_ctx_t *)ngx_cycle-&gt;conf_ctx[8])-&gt;loc_conf[1])-&gt;locationsp *(ngx_http_conf_ctx_t *)((ngx_http_conf_ctx_t *)ngx_cycle-&gt;conf_ctx[8])-&gt;main_confp *(ngx_http_core_main_conf_t *)((ngx_http_conf_ctx_t *)(ngx_cycle-&gt;conf_ctx[8]))-&gt;main_conf[0]p *(ngx_http_core_srv_conf_t*)(((ngx_http_core_main_conf_t *)((ngx_http_conf_ctx_t *)(ngx_cycle-&gt;conf_ctx[8]))-&gt;main_conf[0])-&gt;servers) main 层次main 层次的存储使用的是 ngx_cycle_t::conf_ctx，它只存储 core 模块的配置数据。core 模块数量很少，所以 ngx_cyclte_t::conf_ctx 数组几乎为空，主要存储 ngx_core_module 模块的配置数据，用以解析 master、daemon 等指令。 conf_ctx 四层指针的理解：第一层指针数组是核心模块使用；对于 HTTP 模块，指针数组中的每个元素指向的是 void * 类型的指针数组（ngx_http_conf_ctx_t * 类型指针数组），此指针数组用于保存不同 HTTP 模块的配置。 http 层次当解析到 http 指令时会调用 ngx_http_block 函数进行解析，会创建 ngx_http_conf_ctx_t 结构。http main 层次的 ngx_http_conf_ctx_t 结构不仅保存了所有 http 模块的 main 配置数据，同时也保存了所有 http 模块的 server 和 location 配置数据。这样实现了 Nginx 配置文件的指令作用域功能：低层次的指令可以在高层次进行配置，高层次指令的值作为低层次指令的默认值，多个低层次的指令可以共享高层次指令的值。 server 层次ngx_http_core_module 模块是第一个 http 模块，它的配置数据结构 ngx_http_core_main_conf_t 里有个动态数组成员 servers，保存了所有 server 相关的信息（ngx_http_core_srv_conf_t）。每个 server 块同样使用 ngx_http_conf_ctx_t 里的三个数组来保存模块配置数据，以为 http 块的配置不会出现在 server 块中，所有不会创建 main 配置数据，而是直接引用。 location 层次ngx_http_core_module 模块使用结构体 ngx_http_core_loc_conf_t 以队列的形式保存 server 里的所有 location 信息。 location 块与 http 和 server 块一样，使用 ngx_http_conf_ctx_t 的三个数组保存模块配置数据，但用指针引用上层 main 和 server 的配置数据，只调用模块的 create_loc_conf，只用一个数组持有所有 http 模块在本 location 里的配置数据。","categories":[],"tags":[]},{"title":"ngx_http_upstream_init_request","slug":"nginx-2018-11-29-ngx-http-upstream-init-request","date":"2022-09-03T12:55:44.503Z","updated":"2022-09-03T12:55:44.503Z","comments":true,"path":"2022/09/03/nginx-2018-11-29-ngx-http-upstream-init-request/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/nginx-2018-11-29-ngx-http-upstream-init-request/","excerpt":"","text":"概述可以理解 upstream 是 NGINX 作为客户端主动创建的一个到后端的连接，并将连接事件添加到事件循环中。在用户调用 ngx_http_upstream_init 会创建到后端的连接，而在 ngx_http_upstream_init 中会调用 ngx_http_upstream_init_request 作为主要的逻辑处理。 ngx_http_upstream_init_request123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220voidngx_http_upstream_init(ngx_http_request_t *r)&#123; ngx_connection_t *c; c = r-&gt;connection; ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c-&gt;log, 0, &quot;http init upstream, client timer: %d&quot;, c-&gt;read-&gt;timer_set);#if (NGX_HTTP_V2) if (r-&gt;stream) &#123; ngx_http_upstream_init_request(r); return; &#125;#endif // 删除客户端连接上的读超时定时器 if (c-&gt;read-&gt;timer_set) &#123; ngx_del_timer(c-&gt;read); &#125; if (ngx_event_flags &amp; NGX_USE_CLEAR_EVENT) &#123; if (!c-&gt;write-&gt;active) &#123; if (ngx_add_event(c-&gt;write, NGX_WRITE_EVENT, NGX_CLEAR_EVENT)== NGX_ERROR) &#123; ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR); return; &#125; &#125; &#125; ngx_http_upstream_init_request(r);&#125;static voidngx_http_upstream_init_request(ngx_http_request_t *r)&#123; ngx_str_t *host; ngx_uint_t i; ngx_resolver_ctx_t *ctx, temp; ngx_http_cleanup_t *cln; ngx_http_upstream_t *u; ngx_http_core_loc_conf_t *clcf; ngx_http_upstream_srv_conf_t *uscf, **uscfp; ngx_http_upstream_main_conf_t *umcf; if (r-&gt;aio) &#123; return; &#125; u = r-&gt;upstream;#if (NGX_HTTP_CACHE) ... // 缓存相关#endif u-&gt;store = u-&gt;conf-&gt;store; // 检查与下游(即客户端)之间的 TCP 连接是否断开 if (!u-&gt;store &amp;&amp; !r-&gt;post_action &amp;&amp; !u-&gt;conf-&gt;ignore_client_abort) &#123; r-&gt;read_event_handler = ngx_http_upstream_rd_check_broken_connection; r-&gt;write_event_handler = ngx_http_upstream_wr_check_broken_connection; &#125; if (r-&gt;request_body) &#123; u-&gt;request_bufs = r-&gt;request_body-&gt;bufs; &#125; // 调用 upstream 设置的回调方法，构建到上游服务器的请求 if (u-&gt;create_request(r) != NGX_OK) &#123; ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR); return; &#125; if (ngx_http_upstream_set_local(r, u, u-&gt;conf-&gt;local) != NGX_OK) &#123; ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR); return; &#125; clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module); u-&gt;output.alignment = clcf-&gt;directio_alignment; u-&gt;output.pool = r-&gt;pool; u-&gt;output.bufs.num = 1; u-&gt;output.bufs.size = clcf-&gt;client_body_buffer_size; if (u-&gt;output.output_filter == NULL) &#123; u-&gt;output.output_filter = ngx_chain_writer; u-&gt;output.filter_ctx = &amp;u-&gt;writer; &#125; u-&gt;writer.pool = r-&gt;pool; // upstream_states 用于表示上游响应的状 if (r-&gt;upstream_states == NULL) &#123; r-&gt;upstream_states = ngx_array_create(r-&gt;pool, 1, sizeof(ngx_http_upstream_state_t)); if (r-&gt;upstream_states == NULL) &#123; ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR); return; &#125; &#125; else &#123; u-&gt;state = ngx_array_push(r-&gt;upstream_states); if (u-&gt;state == NULL) &#123; ngx_http_upstream_finalize_request(r, u, NGX_HTTP_INTERNAL_SERVER_ERROR); return; &#125; ngx_memzero(u-&gt;state, sizeof(ngx_http_upstream_state_t)); &#125; // upstream 清理函数 cln = ngx_http_cleanup_add(r, 0); if (cln == NULL) &#123; ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR); return; &#125; cln-&gt;handler = ngx_http_upstream_cleanup; cln-&gt;data = r; u-&gt;cleanup = &amp;cln-&gt;handler; // 上游服务器的地址 if (u-&gt;resolved == NULL) &#123; // 如果创建 upstream 的代码中没有创建 resolved 配置，那么使用 upstream 的配置参数 uscf = u-&gt;conf-&gt;upstream; &#125; else &#123; // 使用创建 upstream 时设置的 resolved 作为上游服务器地址 host = &amp;u-&gt;resolved-&gt;host; umcf = ngx_http_get_module_main_conf(r, ngx_http_upstream_module); uscfp = umcf-&gt;upstreams.elts; for (i = 0; i &lt; umcf-&gt;upstreams.nelts; i++) &#123; uscf = uscfp[i]; if (uscf-&gt;host.len == host-&gt;len &amp;&amp; ((uscf-&gt;port == 0 &amp;&amp; u-&gt;resolved-&gt;no_port) || uscf-&gt;port == u-&gt;resolved-&gt;port) &amp;&amp; ngx_strncasecmp(uscf-&gt;host.data, host-&gt;data, host-&gt;len) == 0) &#123; goto found; &#125; &#125; if (u-&gt;resolved-&gt;sockaddr) &#123; if (u-&gt;resolved-&gt;port == 0 &amp;&amp; u-&gt;resolved-&gt;sockaddr-&gt;sa_family != AF_UNIX) &#123; ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0, &quot;no port in upstream \\&quot;%V\\&quot;&quot;, host); ngx_http_upstream_finalize_request(r, u, NGX_HTTP_INTERNAL_SERVER_ERROR); return; &#125; if (ngx_http_upstream_create_round_robin_peer(r, u-&gt;resolved) != NGX_OK) &#123; ngx_http_upstream_finalize_request(r, u, NGX_HTTP_INTERNAL_SERVER_ERROR); return; &#125; ngx_http_upstream_connect(r, u); return; &#125; if (u-&gt;resolved-&gt;port == 0) &#123; ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0, &quot;no port in upstream \\&quot;%V\\&quot;&quot;, host); ngx_http_upstream_finalize_request(r, u, NGX_HTTP_INTERNAL_SERVER_ERROR); return; &#125; // 进行域名解析 temp.name = *host; // clcf-&gt;resolver 是保存在 ngx_http_core_module 中，通过指令 resolver 设置 ctx = ngx_resolve_start(clcf-&gt;resolver, &amp;temp); if (ctx == NULL) &#123; ngx_http_upstream_finalize_request(r, u, NGX_HTTP_INTERNAL_SERVER_ERROR); return; &#125; if (ctx == NGX_NO_RESOLVER) &#123; ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0, &quot;no resolver defined to resolve %V&quot;, host); ngx_http_upstream_finalize_request(r, u, NGX_HTTP_BAD_GATEWAY); return; &#125; ctx-&gt;name = *host; ctx-&gt;handler = ngx_http_upstream_resolve_handler; ctx-&gt;data = r; ctx-&gt;timeout = clcf-&gt;resolver_timeout; u-&gt;resolved-&gt;ctx = ctx; // 进行域名解析 if (ngx_resolve_name(ctx) != NGX_OK) &#123; u-&gt;resolved-&gt;ctx = NULL; ngx_http_upstream_finalize_request(r, u, NGX_HTTP_INTERNAL_SERVER_ERROR); return; &#125; return; &#125;found: if (uscf == NULL) &#123; ngx_log_error(NGX_LOG_ALERT, r-&gt;connection-&gt;log, 0, &quot;no upstream configuration&quot;); ngx_http_upstream_finalize_request(r, u, NGX_HTTP_INTERNAL_SERVER_ERROR); return; &#125; u-&gt;upstream = uscf;#if (NGX_HTTP_SSL) u-&gt;ssl_name = uscf-&gt;host;#endif if (uscf-&gt;peer.init(r, uscf) != NGX_OK) &#123; ngx_http_upstream_finalize_request(r, u, NGX_HTTP_INTERNAL_SERVER_ERROR); return; &#125; u-&gt;peer.start_time = ngx_current_msec; if (u-&gt;conf-&gt;next_upstream_tries &amp;&amp; u-&gt;peer.tries &gt; u-&gt;conf-&gt;next_upstream_tries) &#123; u-&gt;peer.tries = u-&gt;conf-&gt;next_upstream_tries; &#125; // 连接上游服务器 ngx_http_upstream_connect(r, u);&#125; resolver 指令说明123Syntax: resolver address ... [valid=time] [ipv6=on|off];Default: —Context: http, server, location 在 resolver 指令中可以指定多个 dns，设置重置域名 ttl 值。","categories":[{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/categories/NGINX/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/tags/NGINX/"}]},{"title":"Nginx stream 模块","slug":"nginx-2018-12-05-Nginx-stream-模块","date":"2022-09-03T12:55:44.503Z","updated":"2022-09-03T12:55:44.503Z","comments":true,"path":"2022/09/03/nginx-2018-12-05-Nginx-stream-模块/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/nginx-2018-12-05-Nginx-stream-%E6%A8%A1%E5%9D%97/","excerpt":"","text":"stream 模块在 NGINX 内部四层协议处理是从 ngx_stream_module 模块的 stream 指令处理开始。ngx_stream_module 是核心模块，作用与 ngx_http_module 相同。 处理阶段定义在 NGX_STREAM_MODULE 模块中定义了：NGX_STREAM_POST_ACCEPT_PHASE、NGX_STREAM_PREACCESS_PHASE、NGX_STREAM_ACCESS_PHASE、NGX_STREAM_SSL_PHASE、NGX_STREAM_PREREAD_PHASE、NGX_STREAM_CONTENT_PHASE、NGX_STREAM_LOG_PHASE 七个处理阶段。阅读 ngx_stream_block 中调用的 ngx_stream_init_phase_handlers 函数代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455static ngx_int_tngx_stream_init_phase_handlers(ngx_conf_t *cf, ngx_stream_core_main_conf_t *cmcf)&#123; ngx_int_t j; ngx_uint_t i, n; ngx_stream_handler_pt *h; ngx_stream_phase_handler_t *ph; ngx_stream_phase_handler_pt checker; n = 1 /* content phase */; for (i = 0; i &lt; NGX_STREAM_LOG_PHASE; i++) &#123; n += cmcf-&gt;phases[i].handlers.nelts; &#125; ph = ngx_pcalloc(cf-&gt;pool, n * sizeof(ngx_stream_phase_handler_t) + sizeof(void *)); if (ph == NULL) &#123; return NGX_ERROR; &#125; cmcf-&gt;phase_engine.handlers = ph; n = 0; for (i = 0; i &lt; NGX_STREAM_LOG_PHASE; i++) &#123; h = cmcf-&gt;phases[i].handlers.elts; switch (i) &#123; case NGX_STREAM_PREREAD_PHASE: checker = ngx_stream_core_preread_phase; break; // 最后的 continue; 说明这个阶段只能有一个处理函数 case NGX_STREAM_CONTENT_PHASE: ph-&gt;checker = ngx_stream_core_content_phase; n++; ph++; continue; default: checker = ngx_stream_core_generic_phase; &#125; n += cmcf-&gt;phases[i].handlers.nelts; for (j = cmcf-&gt;phases[i].handlers.nelts - 1; j &gt;= 0; j--) &#123; ph-&gt;checker = checker; ph-&gt;handler = h[j]; ph-&gt;next = n; ph++; &#125; &#125; return NGX_OK;&#125; 七个阶段中除了 NGX_STREAM_CONTENT_PHASE 阶段不允许介入，其他阶段用户都可以介入处理。 ngx_stream_optimize_servers调用 ngx_stream_add_ports 和 ngx_stream_optimize_servers 添加端口监听的回调函数。在 ngx_stream_optimize_servers 函数中，把绑定的 IP 和端口以及对应的配置赋值到所监听结构体的 servers 的变量。添加的目的主要是为了能够在请求到达的时候找到对应的配置，也就是为了根据五元组中目的 IP 和端口来获取监听该 IP 和端口所对应的配置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116static char *ngx_stream_optimize_servers(ngx_conf_t *cf, ngx_array_t *ports)&#123; ngx_uint_t i, p, last, bind_wildcard; ngx_listening_t *ls; ngx_stream_port_t *stport; ngx_stream_conf_port_t *port; ngx_stream_conf_addr_t *addr; ngx_stream_core_srv_conf_t *cscf; port = ports-&gt;elts; for (p = 0; p &lt; ports-&gt;nelts; p++) &#123; // 对 PORT 下的 IP 地址排序。宽绑定（通配符绑定）的排序到最后。 // 设置了特殊标识需要 BIND 的排在最前。不需要 BIND 的排到中间位置。 ngx_sort(port[p].addrs.elts, (size_t) port[p].addrs.nelts, sizeof(ngx_stream_conf_addr_t), ngx_stream_cmp_conf_addrs); addr = port[p].addrs.elts; last = port[p].addrs.nelts; /* * if there is the binding to the &quot;*:port&quot; then we need to bind() * to the &quot;*:port&quot; only and ignore the other bindings */ // 最后一个地址是否是宽绑定的， // 如果是那么没有特殊标识设置的就不需要绑定监听了， // 只需要绑定监听这个宽绑定 IP 就可以。 if (addr[last - 1].opt.wildcard) &#123; addr[last - 1].opt.bind = 1; bind_wildcard = 1; &#125; else &#123; bind_wildcard = 0; &#125; i = 0; while (i &lt; last) &#123; // 有宽绑定且不需要单独绑定 if (bind_wildcard &amp;&amp; !addr[i].opt.bind) &#123; i++; continue; &#125; // 如果没有宽绑定，每个地址都需要监听 // 如果有宽绑定，只需要绑定设置了特殊标识的地址和宽绑定地址， // 不需要绑定监听的都会被添加到宽绑定地址的监听数组中(ls-&gt;servers-&gt;addrs) ls = ngx_create_listening(cf, &amp;addr[i].opt.sockaddr.sockaddr, addr[i].opt.socklen); if (ls == NULL) &#123; return NGX_CONF_ERROR; &#125; ls-&gt;addr_ntop = 1; ls-&gt;handler = ngx_stream_init_connection; ls-&gt;pool_size = 256; ls-&gt;type = addr[i].opt.type; cscf = addr-&gt;opt.ctx-&gt;srv_conf[ngx_stream_core_module.ctx_index]; ls-&gt;logp = cscf-&gt;error_log; ls-&gt;log.data = &amp;ls-&gt;addr_text; ls-&gt;log.handler = ngx_accept_log_error; ls-&gt;backlog = addr[i].opt.backlog; ls-&gt;rcvbuf = addr[i].opt.rcvbuf; ls-&gt;sndbuf = addr[i].opt.sndbuf; ls-&gt;wildcard = addr[i].opt.wildcard; ls-&gt;keepalive = addr[i].opt.so_keepalive;#if (NGX_HAVE_KEEPALIVE_TUNABLE) ls-&gt;keepidle = addr[i].opt.tcp_keepidle; ls-&gt;keepintvl = addr[i].opt.tcp_keepintvl; ls-&gt;keepcnt = addr[i].opt.tcp_keepcnt;#endif#if (NGX_HAVE_INET6) ls-&gt;ipv6only = addr[i].opt.ipv6only;#endif#if (NGX_HAVE_REUSEPORT) ls-&gt;reuseport = addr[i].opt.reuseport;#endif stport = ngx_palloc(cf-&gt;pool, sizeof(ngx_stream_port_t)); if (stport == NULL) &#123; return NGX_CONF_ERROR; &#125; ls-&gt;servers = stport; stport-&gt;naddrs = i + 1; switch (ls-&gt;sockaddr-&gt;sa_family) &#123;#if (NGX_HAVE_INET6) case AF_INET6: if (ngx_stream_add_addrs6(cf, stport, addr) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; break;#endif default: /* AF_INET */ if (ngx_stream_add_addrs(cf, stport, addr) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; break; &#125; if (ngx_clone_listening(cf, ls) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; addr++; last--; &#125; &#125; return NGX_CONF_OK;&#125; 本节摘自网络 NGX_STREAM_CONTENT_PHASE 阶段设置处理函数方法参见 ngx_stream_proxy_module 模块的 proxy_pass 指令处理函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657static char *ngx_stream_proxy_pass(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; ngx_stream_proxy_srv_conf_t *pscf = conf; ngx_url_t u; ngx_str_t *value, *url; ngx_stream_complex_value_t cv; ngx_stream_core_srv_conf_t *cscf; ngx_stream_compile_complex_value_t ccv; if (pscf-&gt;upstream || pscf-&gt;upstream_value) &#123; return &quot;is duplicate&quot;; &#125; cscf = ngx_stream_conf_get_module_srv_conf(cf, ngx_stream_core_module); // 处理函数设置 cscf-&gt;handler = ngx_stream_proxy_handler; value = cf-&gt;args-&gt;elts; url = &amp;value[1]; ngx_memzero(&amp;ccv, sizeof(ngx_stream_compile_complex_value_t)); ccv.cf = cf; ccv.value = url; ccv.complex_value = &amp;cv; if (ngx_stream_compile_complex_value(&amp;ccv) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; if (cv.lengths) &#123; pscf-&gt;upstream_value = ngx_palloc(cf-&gt;pool, sizeof(ngx_stream_complex_value_t)); if (pscf-&gt;upstream_value == NULL) &#123; return NGX_CONF_ERROR; &#125; *pscf-&gt;upstream_value = cv; return NGX_CONF_OK; &#125; ngx_memzero(&amp;u, sizeof(ngx_url_t)); u.url = *url; u.no_resolve = 1; pscf-&gt;upstream = ngx_stream_upstream_add(cf, &amp;u, 0); if (pscf-&gt;upstream == NULL) &#123; return NGX_CONF_ERROR; &#125; return NGX_CONF_OK;&#125;","categories":[{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/categories/NGINX/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/tags/NGINX/"}]},{"title":"Valgrind DEBUG NGINX","slug":"nginx-2019-01-08-Valgrind-DEBUG-NGINX","date":"2022-09-03T12:55:44.503Z","updated":"2022-09-03T12:55:44.503Z","comments":true,"path":"2022/09/03/nginx-2019-01-08-Valgrind-DEBUG-NGINX/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/nginx-2019-01-08-Valgrind-DEBUG-NGINX/","excerpt":"","text":"一 valgrind 安装1234567wget http://www.valgrind.org/downloads/valgrind-3.14.0.tar.bz2tar jxvf valgrind-3.14.0.tar.bz2cd valgrind-3.14.0./configuremake sudo make install 二 分析 NGINX12345678# 启动测试valgrind --trace-children=yes --log-file=memcheck.log --tool=memcheck --leak-check=full /srv/nginx/sbin/nginx# 进行测试命令# ...# 关闭程序/srv/nginx/sbin/nginx -s quit 三 输出说明 definitely lost 确认丢失。程序中存在内存泄露，应尽快修复。当程序结束时如果一块动态分配的内存没有被释放且通过程序内的指针变量均无法访问这块内存则会报这个错误。 indirectly lost 间接丢失。当使用了含有指针成员的类或结构时可能会报这个错误。这类错误无需直接修复，他们总是与“definitely lost”一起出现，只要修复“definitely lost”即可。 still reachable 可以访问，未丢失但也未释放。如果程序是正常结束的，那么它可能不会造成程序崩溃，但长时间运行有可能耗尽系统资源，因此笔者建议修复它。如果程序是崩溃（如访问非法的地址而崩溃）而非正常结束的，则应当暂时忽略它，先修复导致程序崩溃的错误，然后重新检测。 suppressed 已被解决。出现了内存泄露但系统自动处理了。可以无视这类错误。","categories":[{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/categories/NGINX/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"Linux","slug":"Linux","permalink":"https://juzipeek.github.io/tags/Linux/"},{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/tags/NGINX/"},{"name":"Valgrind","slug":"Valgrind","permalink":"https://juzipeek.github.io/tags/Valgrind/"}]},{"title":"Naxsi","slug":"nginx-2019-01-26-Naxsi","date":"2022-09-03T12:55:44.503Z","updated":"2022-09-03T12:56:41.259Z","comments":true,"path":"2022/09/03/nginx-2019-01-26-Naxsi/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/nginx-2019-01-26-Naxsi/","excerpt":"","text":"概述NAXSI means Nginx Anti XSS &amp; SQL Injection。NAXSI 是 Nginx 模块，用于防止跨站攻击、SQL 注入。 安装123456789# 下载wget https://github.com/nbs-system/naxsi/archive/0.56.tar.gztar zxvf 0.56.tar.gz# configure./configure --with-cc=/usr/bin/gcc-4.8 --with-cc-opt=-U_FORTIFY_SOURCE --with-pcre=/opt/pcre-8.38 --with-pcre-jit --with-http_dav_module --with-http_ssl_module --with-http_realip_module --with-openssl=/opt/openssl-1.1.0h --add-module=/opt/nginx-1.13.2/src/dynamod/nginx_accept_language_module --with-ld-opt=&#x27;-lpcre -Wl,-z,relro -Wl,-rpath,/usr/local/luajit/lib&#x27; --add-dynamic-module=/opt/nginx-1.13.2/src/dynamod/naxsi/naxsi_srcmake modulescp objs/ngx_http_naxsi_module.so /srv/nginx/module 基础配置nginx.conf: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;error_log logs/error.log debug;#pid logs/nginx.pid;load_module module/ngx_http_naxsi_module.so;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; include naxsi_core.rules; #导入 naxsi 核心规则 log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; $status $body_bytes_sent &quot;$http_referer&quot; &#x27; &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;; sendfile on; keepalive_timeout 65; #gzip on; server &#123; listen 8080 default; server_name localhost; index index.html index.htm index.php; location /naxsi_test &#123; SecRulesEnabled; # LearningMode; DeniedUrl &quot;/RequestDenied&quot;; CheckRule &quot;$SQL &gt;= 8&quot; BLOCK; CheckRule &quot;$RFI &gt;= 8&quot; BLOCK; CheckRule &quot;$TRAVERSAL &gt;= 4&quot; BLOCK; CheckRule &quot;$EVADE &gt;= 4&quot; BLOCK; CheckRule &quot;$XSS &gt;= 8&quot; BLOCK; return 200 &quot;ok&quot;; &#125; location /RequestDenied &#123; return 403; &#125; location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf|flv|ico)$ &#123; expires 30d; access_log off; &#125; location ~ .*\\.(js|css)?$ &#123; expires 7d; access_log off; &#125; &#125;&#125; 测试命令： 1curl &#x27;http://127.0.0.1:8080/naxsi_test?a=&lt;&gt;&#x27; 可以从日志中看到 naxsi 输出。 命令说明在 Naxsi 内同时有 Naxsi 风格和 NGINX 风格的指令，左右是相同的。 1. MainRule/main_rule定义一条规则或白名单。 2. BasicRule/basic_rule定义一条规则或白名单。 3. DeniedUrl/denied_url指示 naxsi 将 BLOCK 的请求重定向 DeniedUrl 指定的位置。示例： 12345678location / &#123;...DeniedUrl &quot;/RequestDenied&quot;;&#125;location /RequestDenied &#123;return 418; #I&#x27;m a teapot&#125; 4. CheckRule/check_rule定义当分值达到阈值采取的动作。可采取动作： 1LOG, BLOCK, DROP, ALLOW 5. LearningMode/learning_mode6. SecRulesEnabled/rules_enabledSecRulesEnabled 用来指示当前 location 是否启用 NAXSI 检查。 7. SecRulesDisabled/rules_disabledSecRulesDisabled 在当前 location 禁用 NAXSI 检查。 8. LibInjectionSql/libinjection_sql开启 SQL 注入检测。 9. LibInjectionXss/libinjection_xss开启跨站攻击检查。 NAXSI 规则指令处理函数1. SCORE_T 指令处理SCORE_T 定义： 1#define SCORE_T &quot;s:&quot; 可选值以及相应处理结果： 可选值 处理结果 BLOCK 本规则 block 位置 1 DROP 本规则 drop 位置 1 ALLOW 本规则 allow 位置 1 LOG 本规则 log 位置 1 [-][0-9] 计算出相应数值 2. ID_T 指令处理ID_T 定义： 1#define ID_T &quot;id:&quot; 功能：计算本规则的 ID 号 3. MSG_T 指令处理MSG_T 定义： 1#define MSG_T &quot;msg:&quot; 功能：msg 用来定义当前规则的描述信息。 4. RX_T 指令处理RX_T 定义： 1#define RX_T &quot;rx:&quot; 功能：rx 用于定义正则表达式，内部会预先编译为正则表达式对象，并将其存储在 rule-&gt;br-&gt;rx 中。 5. STR_T 指令处理STR_T 定义： 1#define STR_T &quot;str:&quot; 功能：str 用于定义字符串匹配，内部使用小写字母表示字符串以忽略大小写，并使 rule-&gt;br-&gt;str 指向转换后的小写字符串。 6. LIBINJ_XSS_T 指令处理LIBINJ_XSS_T 定义： 1#define LIBINJ_XSS_T &quot;d:libinj_xss&quot; 功能：仅指定本规则为 xss 类型。rule-&gt;br-&gt;match_type = LIBINJ_XSS 本规则对 GET 请求中 foo 参数进行跨站攻击检查，如果检测到跨站攻击则 DROP 请求。 1MainRule &quot;id:4241&quot; &quot;s:DROP&quot; &quot;d:libinj_xss&quot; &quot;mz:$ARGS_VAR:foo&quot;; 7. LIBINJ_SQL_T 指令处理LIBINJ_SQL_T 定义： 1#define LIBINJ_SQL_T &quot;d:libinj_sql&quot; 功能：仅指定本规则为 SQL 注入类型。rule-&gt;br-&gt;match_type = LIBINJ_SQL 本规则对 GET 请求中 foo 参数进行 SQL 注入检查，如果检测到 SQL 注入则 DROP 请求。 1MainRule &quot;id:4241&quot; &quot;s:DROP&quot; &quot;d:libinj_sql&quot; &quot;mz:$ARGS_VAR:foo&quot;; 8. MATCH_ZONE_T 指令处理MATCH_ZONE_T 定义： 1#define MATCH_ZONE_T &quot;mz:&quot; 功能：mz 指令用于指定用于匹配的区域。支持：RAW_BODY、BODY、HEADERS、URL、ARGS、NAME、FILE_EXT；用户自定义 ARGS_VAR、HEADERS_VAR、BODY_VAR、URL；以及支持正则表达式的用户自定义区域 ARGS_VAR、HEADERS_VAR、BODY_VAR、URL。用户自定义、支持正则表达式的用户自定义区域会将值保存在 custom_rule-&gt;target 中。 9. NEGATIVE_T 指令处理NEGATIVE_T 定义： 1#define NEGATIVE_T &quot;negative&quot; 功能：rule-&gt;br-&gt;negative = 1 以下规则将所有请求的 URL 不是以 rest 开头的请求 DROP 掉： 1MainRule &quot;id:4241&quot; negative &quot;s:DROP&quot; &quot;rx:^/rest/&quot; &quot;mz:URL&quot;; 10. WHITELIST_T 指令处理WHITELIST_T 定义： 1#define WHITELIST_T &quot;wl:&quot; 功能：白名单规则列表，使用动态数组保存。 NAXSI 模块指令处理1. MainRule/main_rule 指令处理函数MAIN 级别的全局定义。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566static char *ngx_http_dummy_read_main_conf(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; ngx_http_dummy_main_conf_t *alcf = conf; ngx_str_t *value; ngx_http_rule_t rule, *rule_r; // 省略代码 if (ngx_strcmp(value[0].data, TOP_MAIN_BASIC_RULE_T) &amp;&amp; ngx_strcmp(value[0].data, TOP_MAIN_BASIC_RULE_N)) &#123; ngx_http_dummy_line_conf_error(cf, value); return (NGX_CONF_ERROR); &#125; // 规则解析 if (ngx_http_dummy_cfg_parse_one_rule(cf/*, alcf*/, value, &amp;rule, cf-&gt;args-&gt;nelts) != NGX_CONF_OK) &#123; ngx_http_dummy_line_conf_error(cf, value); return (NGX_CONF_ERROR); &#125; // 将解析出来的规则保存到当前 location 相应的配置节点 if (rule.br-&gt;headers || rule.br-&gt;headers_var) &#123; NX_LOG_DEBUG(_debug_main_conf, NGX_LOG_EMERG, cf, 0, &quot;pushing rule %d in header rules&quot;, rule.rule_id); if (alcf-&gt;header_rules == NULL) &#123; alcf-&gt;header_rules = ngx_array_create(cf-&gt;pool, 2, sizeof(ngx_http_rule_t)); if (alcf-&gt;header_rules == NULL) return NGX_CONF_ERROR; /* LCOV_EXCL_LINE */ &#125; rule_r = ngx_array_push(alcf-&gt;header_rules); if (!rule_r) return (NGX_CONF_ERROR); /* LCOV_EXCL_LINE */ memcpy(rule_r, &amp;rule, sizeof(ngx_http_rule_t)); &#125; /* push in body match rules (POST/PUT) */ if (rule.br-&gt;body || rule.br-&gt;body_var) &#123; // ... rule_r = ngx_array_push(alcf-&gt;body_rules); memcpy(rule_r, &amp;rule, sizeof(ngx_http_rule_t)); &#125; /* push in raw body match rules (POST/PUT) xx*/ if (rule.br-&gt;raw_body) &#123; // ... rule_r = ngx_array_push(alcf-&gt;raw_body_rules); memcpy(rule_r, &amp;rule, sizeof(ngx_http_rule_t)); &#125; /* push in generic rules, as it&#x27;s matching the URI */ if (rule.br-&gt;url) &#123; // ... rule_r = ngx_array_push(alcf-&gt;generic_rules); memcpy(rule_r, &amp;rule, sizeof(ngx_http_rule_t)); &#125; /* push in GET arg rules, but we should push in POST rules too */ if (rule.br-&gt;args_var || rule.br-&gt;args) &#123; // ... rule_r = ngx_array_push(alcf-&gt;get_rules); memcpy(rule_r, &amp;rule, sizeof(ngx_http_rule_t)); &#125; return (NGX_CONF_OK);&#125; 2. BasicRule/basic_rule 指令处理函数LOCATION 级别的规则定义，当前 LOCATION 使用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697/*** my hugly configuration parsing function.** should be rewritten, cause code is hugly and not bof proof at all** does : top level parsing config function, ** see foo_cfg_parse.c for stuff*/static char *ngx_http_dummy_read_conf(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; ngx_http_dummy_loc_conf_t *alcf = conf, **bar; ngx_http_dummy_main_conf_t *main_cf; ngx_str_t *value; ngx_http_rule_t rule, *rule_r; main_cf = ngx_http_conf_get_module_main_conf(cf, ngx_http_naxsi_module); if (!alcf-&gt;pushed) &#123; // 将当前 location 的规则放入 MAIN 配置中 bar = ngx_array_push(main_cf-&gt;locations); if (!bar) return (NGX_CONF_ERROR); *bar = alcf; alcf-&gt;pushed = 1; &#125; /* ** if it&#x27;s a basic rule */ if (!ngx_strcmp(value[0].data, TOP_BASIC_RULE_T) || !ngx_strcmp(value[0].data, TOP_BASIC_RULE_N)) &#123; // 规则解析 if (ngx_http_dummy_cfg_parse_one_rule(cf, value, &amp;rule, cf-&gt;args-&gt;nelts) != NGX_CONF_OK) &#123; ngx_http_dummy_line_conf_error(cf, value); return (NGX_CONF_ERROR); &#125; // 根据解析的规则存储到不同的位置 /* push in whitelist rules, as it have a whitelist ID array */ if (rule.wlid_array &amp;&amp; rule.wlid_array-&gt;nelts &gt; 0) &#123; if (alcf-&gt;whitelist_rules == NULL) &#123; alcf-&gt;whitelist_rules = ngx_array_create(cf-&gt;pool, 2, sizeof(ngx_http_rule_t)); if (alcf-&gt;whitelist_rules == NULL) &#123; return NGX_CONF_ERROR; &#125; &#125; rule_r = ngx_array_push(alcf-&gt;whitelist_rules); if (!rule_r) &#123; return (NGX_CONF_ERROR); &#125; memcpy(rule_r, &amp;rule, sizeof(ngx_http_rule_t)); &#125; else &#123; /* else push in appropriate ruleset : it&#x27;s a normal rule */ if (rule.br-&gt;headers || rule.br-&gt;headers_var) &#123; if (alcf-&gt;header_rules == NULL) &#123; alcf-&gt;header_rules = ngx_array_create(cf-&gt;pool, 2, sizeof(ngx_http_rule_t)); if (alcf-&gt;header_rules == NULL) return NGX_CONF_ERROR; &#125; rule_r = ngx_array_push(alcf-&gt;header_rules); if (!rule_r) return (NGX_CONF_ERROR); memcpy(rule_r, &amp;rule, sizeof(ngx_http_rule_t)); &#125; /* push in body match rules (POST/PUT) */ if (rule.br-&gt;body || rule.br-&gt;body_var) &#123; rule_r = ngx_array_push(alcf-&gt;body_rules); memcpy(rule_r, &amp;rule, sizeof(ngx_http_rule_t)); &#125; /* push in raw body match rules (POST/PUT) */ if (rule.br-&gt;raw_body) &#123; rule_r = ngx_array_push(alcf-&gt;raw_body_rules); memcpy(rule_r, &amp;rule, sizeof(ngx_http_rule_t)); &#125; /* push in generic rules, as it&#x27;s matching the URI */ if (rule.br-&gt;url) &#123; rule_r = ngx_array_push(alcf-&gt;generic_rules); memcpy(rule_r, &amp;rule, sizeof(ngx_http_rule_t)); &#125; /* push in GET arg rules, but we should push in POST rules too */ if (rule.br-&gt;args_var || rule.br-&gt;args) &#123; rule_r = ngx_array_push(alcf-&gt;get_rules); memcpy(rule_r, &amp;rule, sizeof(ngx_http_rule_t)); &#125; &#125; return (NGX_CONF_OK); &#125; return (NGX_CONF_ERROR);&#125; 3. 请求处理函数在 postconfig 阶段设置 ACCESS 阶段处理函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899static ngx_int_t ngx_http_dummy_init(ngx_conf_t *cf)&#123; ngx_http_handler_pt *h; ngx_http_core_main_conf_t *cmcf; ngx_http_dummy_main_conf_t *main_cf; ngx_http_dummy_loc_conf_t **loc_cf; unsigned int i; cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module); main_cf = ngx_http_conf_get_module_main_conf(cf, ngx_http_naxsi_module); if (cmcf == NULL || main_cf == NULL) return (NGX_ERROR); /*LCOV_EXCL_LINE*/ // 设置在 NGX_HTTP_REWRITE_PHASE 阶段，保证先于其他 ACCESS 阶段处理函数处理 /* Register for access phase */ h = ngx_array_push(&amp;cmcf-&gt;phases[NGX_HTTP_REWRITE_PHASE].handlers); if (h == NULL) return (NGX_ERROR); *h = ngx_http_dummy_access_handler; /* Go with each locations registred in the srv_conf. */ loc_cf = main_cf-&gt;locations-&gt;elts; for (i = 0; i &lt; main_cf-&gt;locations-&gt;nelts; i++) &#123; if (loc_cf[i]-&gt;enabled &amp;&amp; (!loc_cf[i]-&gt;denied_url || loc_cf[i]-&gt;denied_url-&gt;len &lt;= 0)) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;Missing DeniedURL, abort.&quot;); return (NGX_ERROR); &#125; loc_cf[i]-&gt;flag_enable_h = ngx_hash_key_lc((u_char *)RT_ENABLE, strlen(RT_ENABLE)); loc_cf[i]-&gt;flag_learning_h = ngx_hash_key_lc((u_char *)RT_LEARNING, strlen(RT_LEARNING)); loc_cf[i]-&gt;flag_post_action_h = ngx_hash_key_lc((u_char *)RT_POST_ACTION, strlen(RT_POST_ACTION)); loc_cf[i]-&gt;flag_extensive_log_h = ngx_hash_key_lc((u_char *)RT_EXTENSIVE_LOG, strlen(RT_EXTENSIVE_LOG)); loc_cf[i]-&gt;flag_libinjection_xss_h = ngx_hash_key_lc((u_char *)RT_LIBINJECTION_XSS, strlen(RT_LIBINJECTION_XSS)); loc_cf[i]-&gt;flag_libinjection_sql_h = ngx_hash_key_lc((u_char *)RT_LIBINJECTION_SQL, strlen(RT_LIBINJECTION_SQL)); // 白名单汇总去重 if(ngx_http_dummy_create_hashtables_n(loc_cf[i], cf) != NGX_OK) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;WhiteList Hash building failed&quot;); return (NGX_ERROR); &#125; &#125; /* initialize prng (used for fragmented logs) */ srandom(time(0) * getpid()); /* ** initalise internal rules for libinjection sqli/xss ** (needs proper special scores) */ nx_int__libinject_sql = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_http_rule_t)); nx_int__libinject_xss = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_http_rule_t)); if (!nx_int__libinject_xss || !nx_int__libinject_sql) return (NGX_ERROR); nx_int__libinject_sql-&gt;sscores = ngx_array_create(cf-&gt;pool, 2, sizeof(ngx_http_special_score_t)); nx_int__libinject_xss-&gt;sscores = ngx_array_create(cf-&gt;pool, 2, sizeof(ngx_http_special_score_t)); if (!nx_int__libinject_sql-&gt;sscores || !nx_int__libinject_xss-&gt;sscores ) return (NGX_ERROR); /* internal ID sqli - 17*/ nx_int__libinject_sql-&gt;rule_id = 17; /* internal ID xss - 18*/ nx_int__libinject_xss-&gt;rule_id = 18; /* libinjection sqli/xss - special score init */ ngx_http_special_score_t *libjct_sql = ngx_array_push(nx_int__libinject_sql-&gt;sscores); ngx_http_special_score_t *libjct_xss = ngx_array_push(nx_int__libinject_xss-&gt;sscores); if (!libjct_sql || !libjct_xss) return (NGX_ERROR); libjct_sql-&gt;sc_tag = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_str_t)); libjct_xss-&gt;sc_tag = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_str_t)); if (!libjct_sql-&gt;sc_tag || !libjct_xss-&gt;sc_tag) return (NGX_ERROR); libjct_sql-&gt;sc_tag-&gt;data = ngx_pcalloc(cf-&gt;pool, 18 /* LIBINJECTION_SQL */); libjct_xss-&gt;sc_tag-&gt;data = ngx_pcalloc(cf-&gt;pool, 18 /* LIBINJECTION_XSS */); if (!libjct_sql-&gt;sc_tag-&gt;data || !libjct_xss-&gt;sc_tag-&gt;data) return (NGX_ERROR); strncpy((char *)libjct_sql-&gt;sc_tag-&gt;data, (char *)&quot;$LIBINJECTION_SQL&quot;, 17); strncpy((char *)libjct_xss-&gt;sc_tag-&gt;data, (char *)&quot;$LIBINJECTION_XSS&quot;, 17); libjct_xss-&gt;sc_tag-&gt;len = 17; libjct_sql-&gt;sc_tag-&gt;len = 17; libjct_sql-&gt;sc_score = 8; libjct_xss-&gt;sc_score = 8; return (NGX_OK);&#125; 3. 规则匹配函数ngx_http_apply_rulematch_v_n 函数的思路是首先判断当前规则、条件是否满足白名单，如果满足则不需要继续进行。如果不满足则根据当前规则进行打分、设置状态（BLOCK、DROP、ALLOw）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138intngx_http_apply_rulematch_v_n(ngx_http_rule_t *r, ngx_http_request_ctx_t *ctx, ngx_http_request_t *req, ngx_str_t *name, ngx_str_t *value, enum DUMMY_MATCH_ZONE zone, ngx_int_t nb_match, ngx_int_t target_name)&#123; unsigned int found = 0, i, z; ngx_http_special_score_t *sc, *rsc; ngx_http_dummy_loc_conf_t *cf; ngx_http_matched_rule_t *mr; ngx_str_t empty=ngx_string(&quot;&quot;); if (!name) name = &amp;empty; if (!value) value = &amp;empty; cf = ngx_http_get_module_loc_conf(req, ngx_http_naxsi_module); if (!cf || !ctx ) return (0); // 使用白名单过滤，如果在白名单内则不需要继续进行规则匹配 if (ngx_http_dummy_is_rule_whitelisted_n(req, cf, r, name, zone, target_name) == 1) &#123; NX_DEBUG(_debug_whitelist_light, NGX_LOG_DEBUG_HTTP, req-&gt;connection-&gt;log, 0, &quot;rule is whitelisted.&quot;); return (0); &#125; NX_DEBUG(_debug_extensive_log, NGX_LOG_DEBUG_HTTP, req-&gt;connection-&gt;log, 0, &quot;Current extensive log value: %d&quot;, ctx-&gt;extensive_log); if (ctx-&gt;extensive_log) &#123; if (target_name) naxsi_log_offending(value, name, req, r, zone, target_name); else naxsi_log_offending(name, value, req, r, zone, target_name); &#125; if (nb_match == 0) nb_match = 1; if (!ctx-&gt;matched) ctx-&gt;matched = ngx_array_create(req-&gt;pool, 2, sizeof(ngx_http_matched_rule_t)); /* log stuff, cause this case sux */ if (!ctx-&gt;matched) return (0); mr = ngx_array_push(ctx-&gt;matched); if (!mr) return (0); memset(mr, 0, sizeof(ngx_http_matched_rule_t)); if (target_name) mr-&gt;target_name = 1; switch(zone) &#123; case HEADERS: mr-&gt;headers_var = 1; break; case URL: mr-&gt;url = 1; break; case ARGS: mr-&gt;args_var = 1; break; case BODY: mr-&gt;body_var = 1; break; case FILE_EXT: mr-&gt;file_ext = 1; break; default: break; &#125;; mr-&gt;rule = r; // the current &quot;name&quot; ptr will be free by caller, so make a copy mr-&gt;name = ngx_pcalloc(req-&gt;pool, sizeof(ngx_str_t)); if (name-&gt;len &gt; 0) &#123; mr-&gt;name-&gt;data = ngx_pcalloc(req-&gt;pool, name-&gt;len+1); memcpy(mr-&gt;name-&gt;data, name-&gt;data, name-&gt;len); mr-&gt;name-&gt;len = name-&gt;len; &#125; else &#123; mr-&gt;name-&gt;data = NULL; mr-&gt;name-&gt;len = 0; &#125; /* apply special score on rulematch */ if (r-&gt;sscores) &#123; NX_DEBUG(_debug_whitelist, NGX_LOG_DEBUG_HTTP, req-&gt;connection-&gt;log, 0, &quot;Rule applies %d custom scores&quot;, r-&gt;sscores-&gt;nelts); if (!ctx-&gt;special_scores) //create the list ctx-&gt;special_scores = ngx_array_create(req-&gt;pool, 1, sizeof(ngx_http_special_score_t)); rsc = r-&gt;sscores-&gt;elts; for (z = 0; z &lt; r-&gt;sscores-&gt;nelts; z++) &#123; //search into the list for matching special score found = 0; sc = ctx-&gt;special_scores-&gt;elts; for (i = 0; i &lt; ctx-&gt;special_scores-&gt;nelts; i++) &#123; if (rsc[z].sc_tag &amp;&amp; sc[i].sc_tag &amp;&amp; sc[i].sc_tag-&gt;len == rsc[z].sc_tag-&gt;len &amp;&amp; !ngx_strcmp(sc[i].sc_tag-&gt;data, rsc[z].sc_tag-&gt;data)) &#123; NX_DEBUG(_debug_whitelist, NGX_LOG_DEBUG_HTTP, req-&gt;connection-&gt;log, 0, &quot;Special Score (%V) actual=%d,next=%d&quot;, rsc[z].sc_tag, sc[i].sc_score, sc[i].sc_score+(rsc[z].sc_score * nb_match)); sc[i].sc_score += (rsc[z].sc_score * nb_match); found = 1; break; &#125; &#125; if (!found) &#123; NX_DEBUG(_debug_whitelist, NGX_LOG_DEBUG_HTTP, req-&gt;connection-&gt;log, 0, &quot;Special Score (%V) next=%d&quot;, rsc[z].sc_tag, (rsc[z].sc_score * nb_match)); sc = ngx_array_push(ctx-&gt;special_scores); if (!sc) return (0); memset(sc, 0, sizeof(ngx_http_special_score_t)); sc-&gt;sc_tag = rsc[z].sc_tag; sc-&gt;sc_score = (rsc[z].sc_score * nb_match); &#125; &#125; &#125; /* else, apply normal score */ ctx-&gt;score += (r-&gt;score * nb_match); if (r-&gt;block) ctx-&gt;block = 1; if (r-&gt;allow) ctx-&gt;allow = 1; if (r-&gt;drop) ctx-&gt;drop = 1; if (r-&gt;log) ctx-&gt;log = 1; ngx_http_dummy_update_current_ctx_status(ctx, cf, req); return (1);&#125; 总结naxsi 代码逻辑或者对 WAF 抽象不够，使用 naxsi 构建 WAF 并不如使用 OpenResty 构建，OpenResty 更加灵活。","categories":[{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/categories/NGINX/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"Linux","slug":"Linux","permalink":"https://juzipeek.github.io/tags/Linux/"},{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/tags/NGINX/"},{"name":"Naxsi","slug":"Naxsi","permalink":"https://juzipeek.github.io/tags/Naxsi/"}]},{"title":"Nginx keepalive 配置","slug":"nginx-2018-11-21-Nginx-keepalive-配置","date":"2022-09-03T12:55:44.502Z","updated":"2022-09-03T12:55:44.502Z","comments":true,"path":"2022/09/03/nginx-2018-11-21-Nginx-keepalive-配置/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/nginx-2018-11-21-Nginx-keepalive-%E9%85%8D%E7%BD%AE/","excerpt":"","text":"使用限制对于客户端、upstream 都可以设置 keepalive 选项。 客户端设置 keepalive_requests The number of requests a client can make over a single keepalive connection. The default is 100, but a much higher value can be especially useful for testing with a load‑generation tool, which generally sends a large number of requests from a single client. keepalive_timeout How long an idle keepalive connection remains open.default 75000 ms. upstream 设置 keepalive The number of idle keepalive connections to an upstream server that remain open for each worker process. There is no default value. 示例 123456upstream memcached_backend &#123; server 127.0.0.1:11211; server 10.0.0.2:11211; keepalive 32;&#125;","categories":[{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/categories/NGINX/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/tags/NGINX/"}]},{"title":"Nginx Http ctx","slug":"nginx-2018-11-22-Nginx-不同阶段间信息传递","date":"2022-09-03T12:55:44.502Z","updated":"2022-09-03T12:55:44.502Z","comments":true,"path":"2022/09/03/nginx-2018-11-22-Nginx-不同阶段间信息传递/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/nginx-2018-11-22-Nginx-%E4%B8%8D%E5%90%8C%E9%98%B6%E6%AE%B5%E9%97%B4%E4%BF%A1%E6%81%AF%E4%BC%A0%E9%80%92/","excerpt":"","text":"模块上下文一般情况下我们会对自己的模块设置、获取上下文通过调用接口： 123#define ngx_http_get_module_ctx(r, module) (r)-&gt;ctx[module.ctx_index]#define ngx_http_set_ctx(r, c, module) r-&gt;ctx[module.ctx_index] = c; 其中 module 参数是模块变量。 不同阶段间上下文传递如果要在不同阶段间传递参数，可以将模块变量声明为 extern 然后在本模块就可以使用。","categories":[{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/categories/NGINX/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/tags/NGINX/"}]},{"title":"NGX_HTTP_LOG_PHASE 阶段介绍","slug":"nginx-2018-11-23-NGX-HTTP-LOG-PHASE","date":"2022-09-03T12:55:44.502Z","updated":"2022-09-03T12:55:44.502Z","comments":true,"path":"2022/09/03/nginx-2018-11-23-NGX-HTTP-LOG-PHASE/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/nginx-2018-11-23-NGX-HTTP-LOG-PHASE/","excerpt":"","text":"phase_engine初始化NGINX 中每个阶段的处理函数是在 ngx_http_core_run_phases 函数中调用 123456789101112131415161718192021voidngx_http_core_run_phases(ngx_http_request_t *r)&#123; ngx_int_t rc; ngx_http_phase_handler_t *ph; ngx_http_core_main_conf_t *cmcf; cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module); ph = cmcf-&gt;phase_engine.handlers; while (ph[r-&gt;phase_handler].checker) &#123; rc = ph[r-&gt;phase_handler].checker(r, &amp;ph[r-&gt;phase_handler]); if (rc == NGX_OK) &#123; return; &#125; &#125;&#125; 其中 phase_engine 初始化如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117static ngx_int_tngx_http_init_phase_handlers(ngx_conf_t *cf, ngx_http_core_main_conf_t *cmcf)&#123; ngx_int_t j; ngx_uint_t i, n; ngx_uint_t find_config_index, use_rewrite, use_access; ngx_http_handler_pt *h; ngx_http_phase_handler_t *ph; ngx_http_phase_handler_pt checker; cmcf-&gt;phase_engine.server_rewrite_index = (ngx_uint_t) -1; cmcf-&gt;phase_engine.location_rewrite_index = (ngx_uint_t) -1; find_config_index = 0; use_rewrite = cmcf-&gt;phases[NGX_HTTP_REWRITE_PHASE].handlers.nelts ? 1 : 0; use_access = cmcf-&gt;phases[NGX_HTTP_ACCESS_PHASE].handlers.nelts ? 1 : 0; n = 1 /* find config phase */ + use_rewrite /* post rewrite phase */ + use_access /* post access phase */ + cmcf-&gt;try_files; for (i = 0; i &lt; NGX_HTTP_LOG_PHASE; i++) &#123; n += cmcf-&gt;phases[i].handlers.nelts; &#125; ph = ngx_pcalloc(cf-&gt;pool, n * sizeof(ngx_http_phase_handler_t) + sizeof(void *)); if (ph == NULL) &#123; return NGX_ERROR; &#125; cmcf-&gt;phase_engine.handlers = ph; n = 0; for (i = 0; i &lt; NGX_HTTP_LOG_PHASE; i++) &#123; h = cmcf-&gt;phases[i].handlers.elts; switch (i) &#123; case NGX_HTTP_SERVER_REWRITE_PHASE: if (cmcf-&gt;phase_engine.server_rewrite_index == (ngx_uint_t) -1) &#123; cmcf-&gt;phase_engine.server_rewrite_index = n; &#125; checker = ngx_http_core_rewrite_phase; break; case NGX_HTTP_FIND_CONFIG_PHASE: find_config_index = n; ph-&gt;checker = ngx_http_core_find_config_phase; n++; ph++; continue; case NGX_HTTP_REWRITE_PHASE: if (cmcf-&gt;phase_engine.location_rewrite_index == (ngx_uint_t) -1) &#123; cmcf-&gt;phase_engine.location_rewrite_index = n; &#125; checker = ngx_http_core_rewrite_phase; break; case NGX_HTTP_POST_REWRITE_PHASE: if (use_rewrite) &#123; ph-&gt;checker = ngx_http_core_post_rewrite_phase; ph-&gt;next = find_config_index; n++; ph++; &#125; continue; case NGX_HTTP_ACCESS_PHASE: checker = ngx_http_core_access_phase; n++; break; case NGX_HTTP_POST_ACCESS_PHASE: if (use_access) &#123; ph-&gt;checker = ngx_http_core_post_access_phase; ph-&gt;next = n; ph++; &#125; continue; case NGX_HTTP_TRY_FILES_PHASE: if (cmcf-&gt;try_files) &#123; ph-&gt;checker = ngx_http_core_try_files_phase; n++; ph++; &#125; continue; case NGX_HTTP_CONTENT_PHASE: checker = ngx_http_core_content_phase; break; default: checker = ngx_http_core_generic_phase; &#125; n += cmcf-&gt;phases[i].handlers.nelts; for (j = cmcf-&gt;phases[i].handlers.nelts - 1; j &gt;=0; j--) &#123; ph-&gt;checker = checker; ph-&gt;handler = h[j]; ph-&gt;next = n; ph++; &#125; &#125; return NGX_OK;&#125; 从上面可以看到 phase_engine 中不存在 NGX_HTTP_LOG_PHASE 阶段的处理，所以在 ngx_http_core_run_phases 中不会调用日志处理阶段。 NGX_HTTP_LOG_PHASE 阶段调用在 NGINX 源码中搜索 NGX_HTTP_LOG_PHASE，可以找到日志记录阶段的调用函数 ngx_http_log_request： 12345678910111213141516static voidngx_http_log_request(ngx_http_request_t *r)&#123; ngx_uint_t i, n; ngx_http_handler_pt *log_handler; ngx_http_core_main_conf_t *cmcf; cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module); log_handler = cmcf-&gt;phases[NGX_HTTP_LOG_PHASE].handlers.elts; n = cmcf-&gt;phases[NGX_HTTP_LOG_PHASE].handlers.nelts; for (i = 0; i &lt; n; i++) &#123; log_handler[i](r); &#125;&#125; 而 ngx_http_log_request 在整个 NGINX 源码中有两个调用点 ngx_http_finalize_request 和 ngx_http_free_request。可以看到日志阶段是在给出应答后才进行调用，NGINX 提供的 $request_time 耗时是从接收到请求信息到给出应答，并且已被客户端接收的耗时。 ngx_http_log_module1234Syntax: access_log path [format [buffer=size] [gzip[=level]] [flush=time] [if=condition]];access_log off;Default: access_log logs/access.log combined;Context: http, server, location, if in location, limit_except access_log 指令用来配置访问日志的路径、格式以及缓存。在 format 参数中可以使用 syslog: 前缀来指定使用 syslog 进行日志收集。如果在当前层级（http&#123;&#125;、server&#123;&#125;、location&#123;&#125; 等）使用 access_log off 配置，会在当前层级禁止日志输出。 如果使用 buffer 或 gzip 参数，access_log 会对输出进行缓存。buffer 参数会指定缓存的大小，flush 参数可以指定 access_log 从缓存刷新到文件的时间。触发缓存内容写入磁盘的条件： 在下次写 log 时内容无法在 buffer 中缓存； buffer 中的内容以及比 flush 参数指定的时间更长； worker 在重新打开文件或者关闭状态。 如果配置了 gzip 参数，日志被写入磁盘钱会进行压缩，可以指定压缩等级（1-9，1 速度最快、压缩比低）。使用 gzip 时 buffer 参数默认为 64K 字节。 其实日志目录参数 path 可以使用变量，不过使用变量后在每次写日志时会打开日志文件、写日志、关闭，因此不能使用 buffer 参数。使用 open_log_file_cache 可以缓存文件描述符。 1234Syntax: open_log_file_cache max=N [inactive=time] [min_uses=N] [valid=time];open_log_file_cache off;Default: open_log_file_cache off;Context: http, server, location 定义一个缓存，用来保存 access_log 的 path 配置中包含变量文件描述符。 参数 含义 备注 max 缓存可以存储文件描述符最多 max 个 使用 LRU 踢除 inactive 缓存中文件描述符允许不活跃时间，超过此时间会关闭 min_uses 与 inactive 配合，在 inactive 时间内使用次数小于 min_uses 值同样会关闭文件描述符。默认为 1。 valid 文件名有效期设置；超过此时间需要检查文件名是否发生变化（因为使用变量） 模块思路模块实现思路比较简单，模块在指令解析过程中会创建 ngx_http_log_t 配置结构，并保存在模块的 main_conf 中。在 postconfiguration 阶段会在 NGX_HTTP_LOG_PHASE 处理阶段添加处理函数。postconfiguration 阶段处理函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243static ngx_int_tngx_http_log_init(ngx_conf_t *cf)&#123; ngx_str_t *value; ngx_array_t a; ngx_http_handler_pt *h; ngx_http_log_fmt_t *fmt; ngx_http_log_main_conf_t *lmcf; ngx_http_core_main_conf_t *cmcf; lmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_log_module); if (lmcf-&gt;combined_used) &#123; if (ngx_array_init(&amp;a, cf-&gt;pool, 1, sizeof(ngx_str_t)) != NGX_OK) &#123; return NGX_ERROR; &#125; value = ngx_array_push(&amp;a); if (value == NULL) &#123; return NGX_ERROR; &#125; *value = ngx_http_combined_fmt; fmt = lmcf-&gt;formats.elts; if (ngx_http_log_compile_format(cf, NULL, fmt-&gt;ops, &amp;a, 0) != NGX_CONF_OK) &#123; return NGX_ERROR; &#125; &#125; cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module); h = ngx_array_push(&amp;cmcf-&gt;phases[NGX_HTTP_LOG_PHASE].handlers); if (h == NULL) &#123; return NGX_ERROR; &#125; *h = ngx_http_log_handler; return NGX_OK;&#125;","categories":[{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/categories/NGINX/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/tags/NGINX/"}]},{"title":"error_log 指令解析","slug":"nginx-2018-11-23-error-log-指令解析","date":"2022-09-03T12:55:44.502Z","updated":"2022-09-03T12:55:44.502Z","comments":true,"path":"2022/09/03/nginx-2018-11-23-error-log-指令解析/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/nginx-2018-11-23-error-log-%E6%8C%87%E4%BB%A4%E8%A7%A3%E6%9E%90/","excerpt":"","text":"概述在 NGINX 源码中搜索 error_log 可以发现有多处指令定义。比如在 ngx_http_core_module 中指令定义 12345678910111213141516171819static ngx_command_t ngx_http_core_commands[] = &#123;... &#123; ngx_string(&quot;error_log&quot;), NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_1MORE, ngx_http_core_error_log, NGX_HTTP_LOC_CONF_OFFSET, 0, NULL &#125;,...&#125;;static char *ngx_http_core_error_log(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; ngx_http_core_loc_conf_t *clcf = conf; return ngx_log_set_log(cf, &amp;clcf-&gt;error_log);&#125; 观察 ngx_mail_core_module、ngx_errlog_module 等其他模块的 error_log 指令处理函数，可以发现最终都会调用到 ngx_log_set_log 函数。其定义如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113char *ngx_log_set_log(ngx_conf_t *cf, ngx_log_t **head)&#123; ngx_log_t *new_log; ngx_str_t *value, name; ngx_syslog_peer_t *peer; if (*head != NULL &amp;&amp; (*head)-&gt;log_level == 0) &#123; new_log = *head; &#125; else &#123; new_log = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_log_t)); if (new_log == NULL) &#123; return NGX_CONF_ERROR; &#125; if (*head == NULL) &#123; *head = new_log; &#125; &#125; value = cf-&gt;args-&gt;elts; if (ngx_strcmp(value[1].data, &quot;stderr&quot;) == 0) &#123; ngx_str_null(&amp;name); cf-&gt;cycle-&gt;log_use_stderr = 1; new_log-&gt;file = ngx_conf_open_file(cf-&gt;cycle, &amp;name); if (new_log-&gt;file == NULL) &#123; return NGX_CONF_ERROR; &#125; &#125; else if (ngx_strncmp(value[1].data, &quot;memory:&quot;, 7) == 0) &#123; // 内存调试日志，只有 NGX_DEBUG 模式支持#if (NGX_DEBUG) size_t size, needed; ngx_pool_cleanup_t *cln; ngx_log_memory_buf_t *buf; value[1].len -= 7; value[1].data += 7; needed = sizeof(&quot;MEMLOG :&quot; NGX_LINEFEED) + cf-&gt;conf_file-&gt;file.name.len + NGX_SIZE_T_LEN + NGX_INT_T_LEN + NGX_MAX_ERROR_STR; size = ngx_parse_size(&amp;value[1]); if (size == (size_t) NGX_ERROR || size &lt; needed) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;invalid buffer size \\&quot;%V\\&quot;&quot;, &amp;value[1]); return NGX_CONF_ERROR; &#125; buf = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_log_memory_buf_t)); if (buf == NULL) &#123; return NGX_CONF_ERROR; &#125; buf-&gt;start = ngx_pnalloc(cf-&gt;pool, size); if (buf-&gt;start == NULL) &#123; return NGX_CONF_ERROR; &#125; buf-&gt;end = buf-&gt;start + size; buf-&gt;pos = ngx_slprintf(buf-&gt;start, buf-&gt;end, &quot;MEMLOG %uz %V:%ui%N&quot;, size, &amp;cf-&gt;conf_file-&gt;file.name, cf-&gt;conf_file-&gt;line); ngx_memset(buf-&gt;pos, &#x27; &#x27;, buf-&gt;end - buf-&gt;pos); cln = ngx_pool_cleanup_add(cf-&gt;pool, 0); if (cln == NULL) &#123; return NGX_CONF_ERROR; &#125; cln-&gt;data = new_log; cln-&gt;handler = ngx_log_memory_cleanup; new_log-&gt;writer = ngx_log_memory_writer; new_log-&gt;wdata = buf;#else ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;nginx was built without debug support&quot;); return NGX_CONF_ERROR;#endif &#125; else if (ngx_strncmp(value[1].data, &quot;syslog:&quot;, 7) == 0) &#123; peer = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_syslog_peer_t)); if (peer == NULL) &#123; return NGX_CONF_ERROR; &#125; if (ngx_syslog_process_conf(cf, peer) != NGX_CONF_OK) &#123; return NGX_CONF_ERROR; &#125; new_log-&gt;writer = ngx_syslog_writer; new_log-&gt;wdata = peer; &#125; else &#123; // 普通文件日志，关联一个文件对象。此时并未打开文件 // 如果跟踪代码走进去，可以发先会将当前文件存入 cycle-&gt;open_files 动态数组中，文件的打开动作在 ngx_init_cycle 阶段将所有动态数组中文件打开 new_log-&gt;file = ngx_conf_open_file(cf-&gt;cycle, &amp;value[1]); if (new_log-&gt;file == NULL) &#123; return NGX_CONF_ERROR; &#125; &#125; if (ngx_log_set_levels(cf, new_log) != NGX_CONF_OK) &#123; return NGX_CONF_ERROR; &#125; if (*head != new_log) &#123; // log 链表是按 log_level 从大到小的顺序排列的，将一个新的 ngx_log_t 对象插入到一个已存在的 log 链表中。 // 一般 log 链表的头是一个固定地址，因此需要插入到头部时需要更改头部指针指向 ngx_log_insert(*head, new_log); &#125; return NGX_CONF_OK;&#125; ngx_log_error_core作为 NGINX 的日志输出函数，通过 ngx_log_error、ngx_log_debug 能够非常方便打印调试信息（NGINX 提供了 HEX 转换函数也方便打印二进制信息），其实两个函数是宏定义，真正的实现者是 ngx_log_error_core。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495voidngx_log_error_core(ngx_uint_t level, ngx_log_t *log, ngx_err_t err, const char *fmt, ...)&#123; u_char *p, *last, *msg; ssize_t n; ngx_uint_t wrote_stderr, debug_connection; // 输出缓冲区，当输出信息过长时会导致信息截断，可以调整 NGX_MAX_ERROR_STR 来调整输出信息长度 u_char errstr[NGX_MAX_ERROR_STR]; // 1. 进行输出信息拼接 last = errstr + NGX_MAX_ERROR_STR; p = ngx_cpymem(errstr, ngx_cached_err_log_time.data, ngx_cached_err_log_time.len); p = ngx_slprintf(p, last, &quot; [%V] &quot;, &amp;err_levels[level]); /* pid#tid */ p = ngx_slprintf(p, last, &quot;%P#&quot; NGX_TID_T_FMT &quot;: &quot;, ngx_log_pid, ngx_log_tid); if (log-&gt;connection) &#123; p = ngx_slprintf(p, last, &quot;*%uA &quot;, log-&gt;connection); &#125; msg = p;#if (NGX_HAVE_VARIADIC_MACROS) va_start(args, fmt); p = ngx_vslprintf(p, last, fmt, args); va_end(args);#else p = ngx_vslprintf(p, last, fmt, args);#endif if (err) &#123; p = ngx_log_errno(p, last, err); &#125; if (level != NGX_LOG_DEBUG &amp;&amp; log-&gt;handler) &#123; p = log-&gt;handler(log, p, last - p); &#125; if (p &gt; last - NGX_LINEFEED_SIZE) &#123; p = last - NGX_LINEFEED_SIZE; &#125; ngx_linefeed(p); wrote_stderr = 0; debug_connection = (log-&gt;log_level &amp; NGX_LOG_DEBUG_CONNECTION) != 0; // 遍历 log 进行信息输出 while (log) &#123; if (log-&gt;log_level &lt; level &amp;&amp; !debug_connection) &#123; break; &#125; // 可以自定义 writer 行为 if (log-&gt;writer) &#123; log-&gt;writer(log, level, errstr, p - errstr); goto next; &#125; if (ngx_time() == log-&gt;disk_full_time) &#123; /* * on FreeBSD writing to a full filesystem with enabled softupdates * may block process for much longer time than writing to non-full * filesystem, so we skip writing to a log for one second */ goto next; &#125; // 输出信息写入文件 n = ngx_write_fd(log-&gt;file-&gt;fd, errstr, p - errstr); if (n == -1 &amp;&amp; ngx_errno == NGX_ENOSPC) &#123; log-&gt;disk_full_time = ngx_time(); &#125; if (log-&gt;file-&gt;fd == ngx_stderr) &#123; wrote_stderr = 1; &#125; next: log = log-&gt;next; &#125; // 输出到终端 if (!ngx_use_stderr || level &gt; NGX_LOG_WARN || wrote_stderr) &#123; return; &#125; // 输出信息调整 msg -= (7 + err_levels[level].len + 3); (void) ngx_sprintf(msg, &quot;nginx: [%V] &quot;, &amp;err_levels[level]); (void) ngx_write_console(ngx_stderr, msg, p - msg);&#125; 阅读上面的代码可以发现输出日志会遍历 log 链表中进行输出。","categories":[{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/categories/NGINX/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/tags/NGINX/"}]},{"title":"介入 Nginx HTTP 请求处理阶段方法","slug":"nginx-2018-11-20-介入-Nginx-HTTP-请求处理阶段方法","date":"2022-09-03T12:55:44.501Z","updated":"2022-09-03T12:55:44.501Z","comments":true,"path":"2022/09/03/nginx-2018-11-20-介入-Nginx-HTTP-请求处理阶段方法/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/nginx-2018-11-20-%E4%BB%8B%E5%85%A5-Nginx-HTTP-%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E9%98%B6%E6%AE%B5%E6%96%B9%E6%B3%95/","excerpt":"","text":"NGINX 处理阶段说明在 NGINX 中 HTTP 请求分为 11 个处理阶段，其中只有 7 个阶段用户可以介入。除了 NGX_HTTP_CONTENT_PHASE 阶段外，其余阶段只能通过向全局的 ngx_http_core_main_conf_t 结构体的 phases 数组添加 ngx_http_handler_pt 处理方法实现。在 NGX_HTTP_CONTENT_PHASE 阶段，除了上述方法外还可以通过将 ngx_http_handler_pt 设置到 ngx_http_core_loc_conf_t 结构体的 handler 指针中。 使用 ngx_http_core_loc_conf_t 介入 NGX_HTTP_CONTENT_PHASE 处理如果使用将 ngx_http_handler_pt 设置到 ngx_http_core_loc_conf_t-&gt;handler 的方法来处理 HTTP 请求，那么在 NGX_HTTP_CONTENT_PHASE 阶段只有 handler 指针指向的处理函数被调用。并且无论处理函数返回任何值，都会直接调用 ngx_http_finalize_request 方法结束请求。 示例代码： 1234567891011static char *ngx_http_empty_gif(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; ngx_http_core_loc_conf_t *clcf; clcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module); clcf-&gt;handler = ngx_http_empty_gif_handler; return NGX_CONF_OK;&#125; 向 ngx_http_core_main_conf_t-&gt;phases 添加处理方法这种方法通过向 NGX_HTTP_CONTENT_PHASE 阶段的动态数组添加处理函数来实现，此时在 NGX_HTTP_CONTENT_PHASE 会调用本阶段的多个处理函数。如果处理函数返回 NGX_DECLINED 会调用下一个处理函数，返回其他值则会调用 ngx_http_finalize_request 方法结束请求。 示例代码： 123456789101112131415161718static ngx_int_tngx_http_autoindex_init(ngx_conf_t *cf)&#123; ngx_http_handler_pt *h; ngx_http_core_main_conf_t *cmcf; cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module); h = ngx_array_push(&amp;cmcf-&gt;phases[NGX_HTTP_CONTENT_PHASE].handlers); if (h == NULL) &#123; return NGX_ERROR; &#125; *h = ngx_http_autoindex_handler; return NGX_OK;&#125; 介入其他处理阶段示例代码： 123456789101112131415161718static ngx_int_tngx_http_limit_conn_init(ngx_conf_t *cf)&#123; ngx_http_handler_pt *h; ngx_http_core_main_conf_t *cmcf; cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module); h = ngx_array_push(&amp;cmcf-&gt;phases[NGX_HTTP_PREACCESS_PHASE].handlers); if (h == NULL) &#123; return NGX_ERROR; &#125; *h = ngx_http_limit_conn_handler; return NGX_OK;&#125;","categories":[{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/categories/NGINX/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/tags/NGINX/"}]},{"title":"ngx_cycle_t 中 connections 说明","slug":"nginx-2018-11-11-ngx-cycle-t","date":"2022-09-03T12:55:44.500Z","updated":"2022-09-03T12:55:44.500Z","comments":true,"path":"2022/09/03/nginx-2018-11-11-ngx-cycle-t/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/nginx-2018-11-11-ngx-cycle-t/","excerpt":"","text":"ngx_cycle_t1234567891011121314151617181920212223242526272829303132333435363738394041424344454647typedef struct ngx_cycle_s ngx_cycle_t;struct ngx_cycle_s &#123; void ****conf_ctx; ngx_pool_t *pool; ngx_log_t *log; ngx_log_t new_log; ngx_uint_t log_use_stderr; /* unsigned log_use_stderr:1; */ ngx_connection_t **files; ngx_connection_t *free_connections; // 指向 connection 中的一个可用连接 ngx_uint_t free_connection_n; ngx_module_t **modules; ngx_uint_t modules_n; ngx_uint_t modules_used; /* unsigned modules_used:1; */ ngx_queue_t reusable_connections_queue; ngx_uint_t reusable_connections_n; ngx_array_t listening; ngx_array_t paths; ngx_array_t config_dump; ngx_rbtree_t config_dump_rbtree; ngx_rbtree_node_t config_dump_sentinel; ngx_list_t open_files; ngx_list_t shared_memory; ngx_uint_t files_n; ngx_uint_t connection_n; ngx_connection_t *connections; // 与 free_connections 配合形成链表结构 ngx_event_t *read_events; ngx_event_t *write_events; ngx_cycle_t *old_cycle; ngx_str_t conf_file; ngx_str_t conf_param; ngx_str_t conf_prefix; ngx_str_t prefix; ngx_str_t lock_file; ngx_str_t hostname;&#125;; ngx_connection_s1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374typedef struct ngx_connection_s ngx_connection_t;struct ngx_connection_s &#123; void *data; // 本结构的巧妙之处 ngx_event_t *read; ngx_event_t *write; ngx_socket_t fd; ngx_recv_pt recv; ngx_send_pt send; ngx_recv_chain_pt recv_chain; ngx_send_chain_pt send_chain; ngx_listening_t *listening; off_t sent; ngx_log_t *log; ngx_pool_t *pool; int type; struct sockaddr *sockaddr; socklen_t socklen; ngx_str_t addr_text; ngx_str_t proxy_protocol_addr; in_port_t proxy_protocol_port;#if (NGX_SSL || NGX_COMPAT) ngx_ssl_connection_t *ssl;#endif struct sockaddr *local_sockaddr; socklen_t local_socklen; ngx_buf_t *buffer; ngx_queue_t queue; ngx_atomic_uint_t number; ngx_uint_t requests; unsigned buffered:8; unsigned log_error:3; /* ngx_connection_log_error_e */ unsigned timedout:1; unsigned error:1; unsigned destroyed:1; unsigned idle:1; unsigned reusable:1; unsigned close:1; unsigned shared:1; unsigned sendfile:1; unsigned sndlowat:1; unsigned tcp_nodelay:2; /* ngx_connection_tcp_nodelay_e */ unsigned tcp_nopush:2; /* ngx_connection_tcp_nopush_e */ unsigned need_last_buf:1;#if (NGX_HAVE_AIO_SENDFILE || NGX_COMPAT) unsigned busy_count:2;#endif#if (NGX_THREADS || NGX_COMPAT) ngx_thread_task_t *sendfile_task;#endif&#125;; ​ NGINX 需要处理大量的网络连接，如何当有新的请求过来需要创建给它分配空间进行存储，当连接断开时需要将资源进行回收（释放或重置继续使用）。如果对每个连接都进行创建、释放存储资源会导致很多的内存申请释放调用导致性能降低。如果使用固定数组来保存连接信息，虽然避免了重复内存的申请释放调用，但是查找数组中使用、未使用连接会成为瓶颈（数组遍历）。NGINX 中使用了巧妙的方法解决这个问题，使用固定内存来存储连接信息，同时将每个节点通过一个 data 指针串联起来，这样连接表就成为一个链表。cycle 变量持有链表中第一可用的节点，当需要申请新的连接结构体时链表将当前节点给用户使用并前进；当需要释放连接时，将链表头作为释放节点的后继节点，链表头指向释放的节点。 connections/free_connections 使用​ connections 在 ngx_event_process_init 中初始化，示例代码： 1234567891011121314151617181920212223ngx_uint_t m, i;ngx_connection_t *c, *next, *old;// 内存分配cycle-&gt;connections = ngx_alloc(sizeof(ngx_connection_t) * cycle-&gt;connection_n, cycle-&gt;log);c = cycle-&gt;connections;i = cycle-&gt;connection_n;next = NULL;// 链表建立do &#123; i--; c[i].data = next; c[i].read = &amp;cycle-&gt;read_events[i]; c[i].write = &amp;cycle-&gt;write_events[i]; c[i].fd = (ngx_socket_t) -1; next = &amp;c[i];&#125; while (i);// free_connections 为链表头cycle-&gt;free_connections = next;cycle-&gt;free_connection_n = cycle-&gt;connection_n; ​ 获取连接 ngx_get_connection，从链表中取可用节点： 12345ngx_connection_t *c;c = ngx_cycle-&gt;free_connections; // 取节点值ngx_cycle-&gt;free_connections = c-&gt;data; // 链表头前进ngx_cycle-&gt;free_connection_n--; ​ 释放连接 ngx_free_connection，将节点归还给链表： 123456789101112voidngx_free_connection(ngx_connection_t *c)&#123; c-&gt;data = ngx_cycle-&gt;free_connections; ngx_cycle-&gt;free_connections = c; ngx_cycle-&gt;free_connection_n++; // 可用忽略 if (ngx_cycle-&gt;files &amp;&amp; ngx_cycle-&gt;files[c-&gt;fd] == c) &#123; ngx_cycle-&gt;files[c-&gt;fd] = NULL; &#125;&#125;","categories":[{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/categories/NGINX/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/tags/NGINX/"}]},{"title":"Nginx 命令解析 set 函数的说明","slug":"nginx-2018-11-18-Nginx-命令解析-set-函数的说明","date":"2022-09-03T12:55:44.500Z","updated":"2022-09-03T12:55:44.501Z","comments":true,"path":"2022/09/03/nginx-2018-11-18-Nginx-命令解析-set-函数的说明/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/nginx-2018-11-18-Nginx-%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90-set-%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%B4%E6%98%8E/","excerpt":"","text":"2018-11-18-Nginx 命令解析 set 函数的说明对于 ngx_command_t 中 set 的调用，可以参见 ngx_conf_handler 函数节选： 123456789101112131415161718192021222324252627282930313233static ngx_int_tngx_conf_handler(ngx_conf_t *cf, ngx_int_t last)&#123; void *conf, **confp; ...... /* set up the directive&#x27;s configuration context */ conf = NULL; // modules[i]-&gt;index 是代表模块位置的下标；modules[i]-&gt;ctx_index代表在他所属模块组的下标 if (cmd-&gt;type &amp; NGX_DIRECT_CONF) &#123; // 直接区配置结构体使用，将 void **** 转换为 void ** conf = ((void **) cf-&gt;ctx)[cf-&gt;cycle-&gt;modules[i]-&gt;index]; &#125; else if (cmd-&gt;type &amp; NGX_MAIN_CONF) &#123; // 配置结构体没有创建，将指针传递进去，创建配置结构体并更新 conf = &amp;(((void **) cf-&gt;ctx)[cf-&gt;cycle-&gt;modules[i]-&gt;index]); &#125; else if (cf-&gt;ctx) &#123; // 使用 cmd-&gt;conf 进行二次偏移，取到模块 cmd-&gt;conf 类型上下文的实际地址 // cmd-&gt;conf 可以取：NGX_HTTP_MAIN_CONF_OFFSET,NGX_HTTP_SRV_CONF_OFFSET,NGX_HTTP_LOC_CONF_OFFSET 等值 confp = *(void **) ((char *) cf-&gt;ctx + cmd-&gt;conf); if (confp) &#123; // 通过组下标找到位置 conf = confp[cf-&gt;cycle-&gt;modules[i]-&gt;ctx_index]; &#125; &#125; rv = cmd-&gt;set(cf, cmd, conf); if (rv == NGX_CONF_OK) &#123; return NGX_OK; &#125; ......&#125; 调用 set 时 conf 指针为模块的上下文。 NGX_DIRECT_CONF 由核心模块使用，表示模块需要解析不属于任何 &#123;&#125; 内的全局配置项，需要与 NGX_MAIN_CONF 配合使用。如果只有 NGX_MAIN_CONF 类型，说明存储配置的结构体还没有创建。 在 ngx_cycle_t 中有成员 conf_ctx 负责维护所有模块的配置结构体。","categories":[{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/categories/NGINX/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/tags/NGINX/"}]},{"title":"NGX_HTTP_MODULE 配置解析","slug":"nginx-2018-11-11-NGX-HTTP-MODULE-配置解析","date":"2022-09-03T12:55:44.499Z","updated":"2022-09-03T12:55:44.499Z","comments":true,"path":"2022/09/03/nginx-2018-11-11-NGX-HTTP-MODULE-配置解析/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/nginx-2018-11-11-NGX-HTTP-MODULE-%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90/","excerpt":"","text":"NGX_HTTP_MODULE 配置解析一 源起ngx_http_module 是 HTTP 类型模块在核心模块的代理，ngx_http_module 的指令 http 的解析（ngx_http_block 函数）为 HTTP 类型模块解析的入口。 二 ngx_http_block 分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182static char *ngx_http_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; char *rv; ngx_uint_t mi, m, s; ngx_conf_t pcf; ngx_http_module_t *module; ngx_http_conf_ctx_t *ctx; ngx_http_core_loc_conf_t *clcf; ngx_http_core_srv_conf_t **cscfp; ngx_http_core_main_conf_t *cmcf; if (*(ngx_http_conf_ctx_t **) conf) &#123; return &quot;is duplicate&quot;; &#125; /* the main http context */ ctx = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_http_conf_ctx_t)); // 参数 conf 为 ngx_http_module 的 ctx，可以参见配置指令解析 *(ngx_http_conf_ctx_t **) conf = ctx; /* count the number of the http modules and set up their indices */ ngx_http_max_module = ngx_count_modules(cf-&gt;cycle, NGX_HTTP_MODULE); /* 所有 HTTP 模块的 main_conf */ ctx-&gt;main_conf = ngx_pcalloc(cf-&gt;pool, sizeof(void *) * ngx_http_max_module); /* 所有模块的 srv_conf, 出现在 http&#123;&#125; 中的 srv_conf 配置项存储在此，后续合并使用 */ ctx-&gt;srv_conf = ngx_pcalloc(cf-&gt;pool, sizeof(void *) * ngx_http_max_module); /* 所有模块的 loc_conf, 出现在 http&#123;&#125; 中的 loc_conf 配置项存储在此，后续合并使用 */ ctx-&gt;loc_conf = ngx_pcalloc(cf-&gt;pool, sizeof(void *) * ngx_http_max_module); for (m = 0; cf-&gt;cycle-&gt;modules[m]; m++) &#123; if (cf-&gt;cycle-&gt;modules[m]-&gt;type != NGX_HTTP_MODULE) &#123; continue; &#125; module = cf-&gt;cycle-&gt;modules[m]-&gt;ctx; mi = cf-&gt;cycle-&gt;modules[m]-&gt;ctx_index; if (module-&gt;create_main_conf) &#123; // ngx_http_core_module 会创建 servers 数组 ctx-&gt;main_conf[mi] = module-&gt;create_main_conf(cf); &#125; if (module-&gt;create_srv_conf) &#123; ctx-&gt;srv_conf[mi] = module-&gt;create_srv_conf(cf); &#125; if (module-&gt;create_loc_conf) &#123; ctx-&gt;loc_conf[mi] = module-&gt;create_loc_conf(cf); &#125; &#125; pcf = *cf; cf-&gt;ctx = ctx; for (m = 0; cf-&gt;cycle-&gt;modules[m]; m++) &#123; if (cf-&gt;cycle-&gt;modules[m]-&gt;type != NGX_HTTP_MODULE) &#123; continue; &#125; module = cf-&gt;cycle-&gt;modules[m]-&gt;ctx; if (module-&gt;preconfiguration) &#123; if (module-&gt;preconfiguration(cf) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; &#125; &#125; /* parse inside the http&#123;&#125; block */ cf-&gt;module_type = NGX_HTTP_MODULE; cf-&gt;cmd_type = NGX_HTTP_MAIN_CONF; rv = ngx_conf_parse(cf, NULL); if (rv != NGX_CONF_OK) &#123; goto failed; &#125; /* * init http&#123;&#125; main_conf&#x27;s, merge the server&#123;&#125;s&#x27; srv_conf&#x27;s * and its location&#123;&#125;s&#x27; loc_conf&#x27;s */ cmcf = ctx-&gt;main_conf[ngx_http_core_module.ctx_index]; cscfp = cmcf-&gt;servers.elts; for (m = 0; cf-&gt;cycle-&gt;modules[m]; m++) &#123; if (cf-&gt;cycle-&gt;modules[m]-&gt;type != NGX_HTTP_MODULE) &#123; continue; &#125; module = cf-&gt;cycle-&gt;modules[m]-&gt;ctx; mi = cf-&gt;cycle-&gt;modules[m]-&gt;ctx_index; /* init http&#123;&#125; main_conf&#x27;s */ if (module-&gt;init_main_conf) &#123; rv = module-&gt;init_main_conf(cf, ctx-&gt;main_conf[mi]); if (rv != NGX_CONF_OK) &#123; goto failed; &#125; &#125; rv = ngx_http_merge_servers(cf, cmcf, module, mi); if (rv != NGX_CONF_OK) &#123; goto failed; &#125; &#125; /* create location trees */ for (s = 0; s &lt; cmcf-&gt;servers.nelts; s++) &#123; clcf = cscfp[s]-&gt;ctx-&gt;loc_conf[ngx_http_core_module.ctx_index]; if (ngx_http_init_locations(cf, cscfp[s], clcf) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; if (ngx_http_init_static_location_trees(cf, clcf) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; &#125; if (ngx_http_init_phases(cf, cmcf) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; if (ngx_http_init_headers_in_hash(cf, cmcf) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; for (m = 0; cf-&gt;cycle-&gt;modules[m]; m++) &#123; if (cf-&gt;cycle-&gt;modules[m]-&gt;type != NGX_HTTP_MODULE) &#123; continue; &#125; module = cf-&gt;cycle-&gt;modules[m]-&gt;ctx; if (module-&gt;postconfiguration) &#123; if (module-&gt;postconfiguration(cf) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; &#125; &#125; if (ngx_http_variables_init_vars(cf) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; /* * http&#123;&#125;&#x27;s cf-&gt;ctx was needed while the configuration merging * and in postconfiguration process */ *cf = pcf; if (ngx_http_init_phase_handlers(cf, cmcf) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; /* optimize the lists of ports, addresses and server names */ if (ngx_http_optimize_servers(cf, cmcf, cmcf-&gt;ports) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; return NGX_CONF_OK;failed: *cf = pcf; return rv;&#125; 三 server 指令解析函数 ngx_http_core_server123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899static char *ngx_http_core_server(ngx_conf_t *cf, ngx_command_t *cmd, void *dummy)&#123; char *rv; void *mconf; ngx_uint_t i; ngx_conf_t pcf; ngx_http_module_t *module; struct sockaddr_in *sin; ngx_http_conf_ctx_t *ctx, *http_ctx; ngx_http_listen_opt_t lsopt; ngx_http_core_srv_conf_t *cscf, **cscfp; ngx_http_core_main_conf_t *cmcf; ctx = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_http_conf_ctx_t)); http_ctx = cf-&gt;ctx; ctx-&gt;main_conf = http_ctx-&gt;main_conf; /* the server&#123;&#125;&#x27;s srv_conf */ ctx-&gt;srv_conf = ngx_pcalloc(cf-&gt;pool, sizeof(void *) * ngx_http_max_module); /* the server&#123;&#125;&#x27;s loc_conf */ ctx-&gt;loc_conf = ngx_pcalloc(cf-&gt;pool, sizeof(void *) * ngx_http_max_module); if (ctx-&gt;loc_conf == NULL) &#123; return NGX_CONF_ERROR; &#125; // 对当前 server 块依次调用所有 HTTP 模块的 create_srv_conf,create_loc_conf for (i = 0; cf-&gt;cycle-&gt;modules[i]; i++) &#123; if (cf-&gt;cycle-&gt;modules[i]-&gt;type != NGX_HTTP_MODULE) &#123; continue; &#125; module = cf-&gt;cycle-&gt;modules[i]-&gt;ctx; if (module-&gt;create_srv_conf) &#123; mconf = module-&gt;create_srv_conf(cf); ctx-&gt;srv_conf[cf-&gt;cycle-&gt;modules[i]-&gt;ctx_index] = mconf; &#125; if (module-&gt;create_loc_conf) &#123; mconf = module-&gt;create_loc_conf(cf); ctx-&gt;loc_conf[cf-&gt;cycle-&gt;modules[i]-&gt;ctx_index] = mconf; &#125; &#125; /* the server configuration context */ cscf = ctx-&gt;srv_conf[ngx_http_core_module.ctx_index]; cscf-&gt;ctx = ctx; cmcf = ctx-&gt;main_conf[ngx_http_core_module.ctx_index]; // 将当前 server 块配置添加到动态数组中 cscfp = ngx_array_push(&amp;cmcf-&gt;servers); if (cscfp == NULL) &#123; return NGX_CONF_ERROR; &#125; *cscfp = cscf; /* parse inside server&#123;&#125; */ pcf = *cf; cf-&gt;ctx = ctx; cf-&gt;cmd_type = NGX_HTTP_SRV_CONF; rv = ngx_conf_parse(cf, NULL); *cf = pcf; // 对为设置监听端口的 server 设置默认监听端口 80、8080 if (rv == NGX_CONF_OK &amp;&amp; !cscf-&gt;listen) &#123; ngx_memzero(&amp;lsopt, sizeof(ngx_http_listen_opt_t)); sin = &amp;lsopt.sockaddr.sockaddr_in; sin-&gt;sin_family = AF_INET;#if (NGX_WIN32) sin-&gt;sin_port = htons(80);#else sin-&gt;sin_port = htons((getuid() == 0) ? 80 : 8000);#endif sin-&gt;sin_addr.s_addr = INADDR_ANY; (void) ngx_sock_ntop(&amp;lsopt.sockaddr.sockaddr, lsopt.socklen, lsopt.addr, NGX_SOCKADDR_STRLEN, 1); if (ngx_http_add_listen(cf, cscf, &amp;lsopt) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; &#125; return rv;&#125; 在 server 指令解析过程中会设置当前 server &#123;&#125; 块的 ngx_http_conf_ctx_t 的 main_conf 为 http &#123;&#125; 的 main_conf，对于 srv_conf 和 loc_conf 会依次调用所有 HTTP 模块的 create_srv_conf 和 create_loc_conf 回调创建相应的配置结构，然后进入 server &#123;&#125; 块的解析。在 server &#123;&#125; 解析完毕后，会将当前 server &#123;&#125; 的配置 ngx_http_conf_ctx_t 加入 ngx_http_core_module 的 servers 数组中。 四 location 指令解析函数 ngx_http_core_location1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798static char *ngx_http_core_location(ngx_conf_t *cf, ngx_command_t *cmd, void *dummy)&#123; char *rv; u_char *mod; size_t len; ngx_str_t *value, *name; ngx_uint_t i; ngx_conf_t save; ngx_http_module_t *module; ngx_http_conf_ctx_t *ctx, *pctx; ngx_http_core_loc_conf_t *clcf, *pclcf; ctx = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_http_conf_ctx_t)); if (ctx == NULL) &#123; return NGX_CONF_ERROR; &#125; // cf 是在 ngx_http_core_server 中设置，cf 的值为当前 server &#123;&#125; 的 ngx_http_conf_ctx_t // pctx meaning parent ctx pctx = cf-&gt;ctx; ctx-&gt;main_conf = pctx-&gt;main_conf; ctx-&gt;srv_conf = pctx-&gt;srv_conf; ctx-&gt;loc_conf = ngx_pcalloc(cf-&gt;pool, sizeof(void *) * ngx_http_max_module); // 依次对所有 http 模块调用 create_loc_conf for (i = 0; cf-&gt;cycle-&gt;modules[i]; i++) &#123; if (cf-&gt;cycle-&gt;modules[i]-&gt;type != NGX_HTTP_MODULE) &#123; continue; &#125; module = cf-&gt;cycle-&gt;modules[i]-&gt;ctx; if (module-&gt;create_loc_conf) &#123; ctx-&gt;loc_conf[cf-&gt;cycle-&gt;modules[i]-&gt;ctx_index] = module-&gt;create_loc_conf(cf); &#125; &#125; clcf = ctx-&gt;loc_conf[ngx_http_core_module.ctx_index]; clcf-&gt;loc_conf = ctx-&gt;loc_conf; value = cf-&gt;args-&gt;elts; ...... // 忽略 location name 的处理，关注 main、srv、loc 配置的组织 pclcf = pctx-&gt;loc_conf[ngx_http_core_module.ctx_index]; /* 嵌套 location 的校验规则 */ if (cf-&gt;cmd_type == NGX_HTTP_LOC_CONF) &#123;#if 0 clcf-&gt;prev_location = pclcf;#endif if (pclcf-&gt;exact_match) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;location \\&quot;%V\\&quot; cannot be inside the exact location \\&quot;%V\\&quot;&quot;, &amp;clcf-&gt;name, &amp;pclcf-&gt;name); return NGX_CONF_ERROR; &#125; if (pclcf-&gt;named) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;location \\&quot;%V\\&quot; cannot be inside the named location \\&quot;%V\\&quot;&quot;,&amp;clcf-&gt;name, &amp;pclcf-&gt;name); return NGX_CONF_ERROR; &#125; if (clcf-&gt;named) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;named location \\&quot;%V\\&quot; can be on the server level only&quot;, &amp;clcf-&gt;name); return NGX_CONF_ERROR; &#125; len = pclcf-&gt;name.len;#if (NGX_PCRE) if (clcf-&gt;regex == NULL &amp;&amp; ngx_filename_cmp(clcf-&gt;name.data, pclcf-&gt;name.data, len) != 0)#else if (ngx_filename_cmp(clcf-&gt;name.data, pclcf-&gt;name.data, len) != 0)#endif &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;location \\&quot;%V\\&quot; is outside location \\&quot;%V\\&quot;&quot;, &amp;clcf-&gt;name, &amp;pclcf-&gt;name); return NGX_CONF_ERROR; &#125; &#125; // 将当前 location 添加到 ngx_http_core_module 模块父 location 的 loc_conf 配置中 locations 队列 if (ngx_http_add_location(cf, &amp;pclcf-&gt;locations, clcf) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; save = *cf; cf-&gt;ctx = ctx; cf-&gt;cmd_type = NGX_HTTP_LOC_CONF; rv = ngx_conf_parse(cf, NULL); *cf = save; return rv;&#125; 在解析 server &#123;&#125; 内的配置项时会使用如下代码： 12345678pcf = *cf;cf-&gt;ctx = ctx;cf-&gt;cmd_type = NGX_HTTP_SRV_CONF;rv = ngx_conf_parse(cf, NULL);*cf = pcf; 此时设置 cf 为当前 server &#123;&#125; 的配置。 12345678910111213141516171819202122232425262728293031323334353637383940ngx_int_tngx_http_add_location(ngx_conf_t *cf, ngx_queue_t **locations, ngx_http_core_loc_conf_t *clcf)&#123; ngx_http_location_queue_t *lq; if (*locations == NULL) &#123; *locations = ngx_palloc(cf-&gt;temp_pool, sizeof(ngx_http_location_queue_t)); ngx_queue_init(*locations); &#125; lq = ngx_palloc(cf-&gt;temp_pool, sizeof(ngx_http_location_queue_t)); if (lq == NULL) &#123; return NGX_ERROR; &#125; if (clcf-&gt;exact_match#if (NGX_PCRE) || clcf-&gt;regex#endif || clcf-&gt;named || clcf-&gt;noname) &#123; lq-&gt;exact = clcf; lq-&gt;inclusive = NULL; &#125; else &#123; lq-&gt;exact = NULL; lq-&gt;inclusive = clcf; &#125; lq-&gt;name = &amp;clcf-&gt;name; lq-&gt;file_name = cf-&gt;conf_file-&gt;file.name.data; lq-&gt;line = cf-&gt;conf_file-&gt;line; ngx_queue_init(&amp;lq-&gt;list); ngx_queue_insert_tail(*locations, &amp;lq-&gt;queue); return NGX_OK;&#125; 五 总结http &#123;&#125;、server &#123;&#125;、location &#123;&#125; 的配置项是通过 ngx_http_conf_ctx_t 结构组织的，其定义如下： 123456typedef struct &#123; void **main_conf; void **srv_conf; void **loc_conf;&#125; ngx_http_conf_ctx_t; http &#123;&#125; 级别的配置项由 ngx_http_module 模块管理，ngx_http_module 会持有 ngx_http_core_module，进而管理 server &#123;&#125;、location &#123;&#125; 级别配置。 server &#123;&#125;、location &#123;&#125; 两种级别的配置项都是通过 ngx_http_core_module 模块管理。 main_conf 是所有模块的 http&#123;&#125; 级配置项，由于只能有一个 http&#123;&#125; 存在他的组织是比较简单的，每个模块只需要有一个 main_conf， srv_conf 和 loc_conf 只需要指向对应模块的 main_conf 即可。 对于 srv_conf 的组织 NGINX 使用 ngx_http_core_module 模块作为管理者，所有的 server&#123;&#125; 块配置组织到动态数组中，数组的每个元素为一个 server&#123;&#125; 配置项，其中又包含各个模块的 ngx_http_conf_ctx_t 配置。 而 loc_conf 的配置 NGINX 使用 ngx_http_core_module 模块来管理，将 location &#123;&#125; 放入父配置项(ngx_http_conf_ctx_t)的 loc_conf 的 location 队列中。","categories":[{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/categories/NGINX/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/tags/NGINX/"}]},{"title":"Nginx 用模块的方式组织代码","slug":"nginx-2018-11-11-Nginx-用模块的方式组织代码","date":"2022-09-03T12:55:44.499Z","updated":"2022-09-03T12:55:44.500Z","comments":true,"path":"2022/09/03/nginx-2018-11-11-Nginx-用模块的方式组织代码/","link":"","permalink":"https://juzipeek.github.io/2022/09/03/nginx-2018-11-11-Nginx-%E7%94%A8%E6%A8%A1%E5%9D%97%E7%9A%84%E6%96%B9%E5%BC%8F%E7%BB%84%E7%BB%87%E4%BB%A3%E7%A0%81/","excerpt":"","text":"起因在《深入理解 Nginx 模块开发与架构解析》一书中提到在 Nginx 中除少量核心代码，其他一切皆为模块。核心模块（NGX_CORE_MODULE）是基础类型的模块，官方核心模块有六个具体模块：ngx_core_module、ngx_errlog_module、ngx_events_module、ngx_openssl_module、ngx_http_module、ngx_mail_module，非模块化的框架代码只需要关注于如何调用六个核心模块。书中并没有说明框架代码如何调用核心模块，以及如何通过核心模块调用具体代码，本文对此进行分析。 如何将模块组织进框架在 configure 阶段会生成 ngx_modules.c 文件，其中有 ngx_modules 变量包含全部模块（有灵性的想法，不直接在代码中组织模块，通过脚本生成模块关系代码）。在 ngx_init_cycle （在其中调用 ngx_cycle_modules 初始化模块）函数中使用 ngx_cycle_modules 数组对 cycle 中的模块数组进行初始化。 框架代码如何调用核心模块以及核心模块到业务模块的转换官方 Nginx 共有五大类型的模块：配置模块、核心模块、事件模块、HTTP 模块、mail 模块，其中配置模块与核心模块这两种类型由 Nginx 的框架代码定义并直接使用。但是事件模块、HTTP 模块、mail 模块不会与框架产生直接关系。事件模块、HTTP 模块、mail 模块在核心模块中各有一个模块作为自己的“代言人”，并在同类模块中有一个作为核心业务与管理功能的模块。 1. 概览12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455ngx_cycle_t *ngx_init_cycle(ngx_cycle_t *old_cycle)&#123; ...... // 省略其他代码 for (i = 0; cycle-&gt;modules[i]; i++) &#123; if (cycle-&gt;modules[i]-&gt;type != NGX_CORE_MODULE) &#123; continue; &#125; module = cycle-&gt;modules[i]-&gt;ctx; if (module-&gt;create_conf) &#123; rv = module-&gt;create_conf(cycle); if (rv == NULL) &#123; ngx_destroy_pool(pool); return NULL; &#125; cycle-&gt;conf_ctx[cycle-&gt;modules[i]-&gt;index] = rv; &#125; &#125; ...... conf.ctx = cycle-&gt;conf_ctx; conf.cycle = cycle; conf.pool = pool; conf.log = log; conf.module_type = NGX_CORE_MODULE; conf.cmd_type = NGX_MAIN_CONF; if (ngx_conf_parse(&amp;conf, &amp;cycle-&gt;conf_file) != NGX_CONF_OK) &#123; environ = senv; ngx_destroy_cycle_pools(&amp;conf); return NULL; &#125; ...... for (i = 0; cycle-&gt;modules[i]; i++) &#123; if (cycle-&gt;modules[i]-&gt;type != NGX_CORE_MODULE) &#123; continue; &#125; module = cycle-&gt;modules[i]-&gt;ctx; if (module-&gt;init_conf) &#123; if (module-&gt;init_conf(cycle, cycle-&gt;conf_ctx[cycle-&gt;modules[i]-&gt;index]) == NGX_CONF_ERROR) &#123; environ = senv; ngx_destroy_cycle_pools(&amp;conf); return NULL; &#125; &#125; &#125; ...... // 省略其他代码&#125; 观察上面的代码，可以看到会对所有的核心模块（NGX_CORE_MODULE 类型）调用 create_conf、ngx_conf_parse、init_conf，框架直接调用核心模块并没有调用业务模块。核心模块中 ngx_mail_module、ngx_http_module、ngx_openssl_module、ngx_events_module、ngx_error_module 模块作为其他模块在核心模块的代理，当框架调用到他们时会在其 commands 数组中指定处理指令，而在其处理指令中会将待处理的指令类型、指令模块修改为具体类型，这是从核心模块到具体业务模块处理的转化，例如如下 ngx_http_module 模块的 ngx_http_block 处理代码： 12345678910static char *ngx_http_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; ... // 忽略其他代码 cf-&gt;module_type = NGX_HTTP_MODULE; cf-&gt;cmd_type = NGX_HTTP_MAIN_CONF; rv = ngx_conf_parse(cf, NULL); ... // 忽略其他代码&#125; 2. 框架如何调用事件模块代理 “ngx_events_module”1234567891011121314151617181920212223242526272829303132333435static ngx_command_t ngx_events_commands[] = &#123; &#123; ngx_string(&quot;events&quot;), NGX_MAIN_CONF|NGX_CONF_BLOCK|NGX_CONF_NOARGS, ngx_events_block, 0, 0, NULL &#125;, ngx_null_command&#125;;static ngx_core_module_t ngx_events_module_ctx = &#123; ngx_string(&quot;events&quot;), NULL, ngx_event_init_conf&#125;;ngx_module_t ngx_events_module = &#123; NGX_MODULE_V1, &amp;ngx_events_module_ctx, /* module context */ ngx_events_commands, /* module directives */ NGX_CORE_MODULE, /* module type */ NULL, /* init master */ NULL, /* init module */ NULL, /* init process */ NULL, /* init thread */ NULL, /* exit thread */ NULL, /* exit process */ NULL, /* exit master */ NGX_MODULE_V1_PADDING&#125;; 从上面代码中可以看到 ngx_events_module 的具体化接口 ngx_events_module_ctx 并不存在 create_conf 调用，而 ngx_event_init_conf 也仅做了 ngx_events_module 模块存在判断，并未做其他工作。那我们猜测 ngx_events_block 做了事件模块的代理工作，下面分析 ngx_events_block 代码。 12345678pcf = *cf;cf-&gt;ctx = ctx;// 指定处理事件类型模块的指令cf-&gt;module_type = NGX_EVENT_MODULE;cf-&gt;cmd_type = NGX_EVENT_CONF;rv = ngx_conf_parse(cf, NULL); 在 ngx_events_block 中会遍历 cycle 中所有 NGX_EVENT_MODULE 模块（注意 ngx_events_module 为核心模块类型，此时为核心模块到事件模块的处理转换，参见上面的代码），并调用模块的 create_conf 接口创建存储配置项的机构体指针。接下来会为所有的事件模块解析配置文件，调用 ngx_conf_parse 解析 NGX_EVENT_MODULE 类型模块感兴趣的配置项。之后对所有的 NGX_EVENT_MODULE 类型模块回调 init_conf。 ngx_event_core_module 模块作为 NGX_EVENT_MODULE 类型模块的一员，同样会经历上面的步骤：create_conf、init_conf 接口回调以及指令解析。ngx_event_core_module 定义： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758static ngx_str_t event_core_name = ngx_string(&quot;event_core&quot;);static ngx_command_t ngx_event_core_commands[] = &#123; &#123; ngx_string(&quot;worker_connections&quot;), NGX_EVENT_CONF|NGX_CONF_TAKE1, ngx_event_connections, 0, 0, NULL &#125;, &#123; ngx_string(&quot;use&quot;), NGX_EVENT_CONF|NGX_CONF_TAKE1, ngx_event_use, 0, 0, NULL &#125;, &#123; ngx_string(&quot;multi_accept&quot;), ...&#125;, &#123; ngx_string(&quot;accept_mutex&quot;), ...&#125;, &#123; ngx_string(&quot;accept_mutex_delay&quot;), ...&#125;, &#123; ngx_string(&quot;debug_connection&quot;), ...&#125;, ngx_null_command&#125;;static ngx_event_module_t ngx_event_core_module_ctx = &#123; &amp;event_core_name, ngx_event_core_create_conf, /* create configuration */ ngx_event_core_init_conf, /* init configuration */ &#123; NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL &#125;&#125;;ngx_module_t ngx_event_core_module = &#123; NGX_MODULE_V1, &amp;ngx_event_core_module_ctx, /* module context */ ngx_event_core_commands, /* module directives */ NGX_EVENT_MODULE, /* module type */ NULL, /* init master */ ngx_event_module_init, /* init module */ // core 模块作为代理模块就可以做事件模块的模块初始化工作 ngx_event_process_init, /* init process */ // core 模块作为代理模块就可以做事件模块的进程初始化工作 NULL, /* init thread */ NULL, /* exit thread */ NULL, /* exit process */ NULL, /* exit master */ NGX_MODULE_V1_PADDING&#125;; 观察 ngx_event_core_module 就可以看到 module_init、process_init 是切人点，实现事件模块的代理。 3. 总结与事件模块类似，HTTP 模块、mail 模块也是通过核心模块转换到核心模块的具象化类型进行处理。这样做的好处是，框架关心核心模块，核心模块中有某个具象模块的代理用来从核心模块到具象模块的转变，将复杂的文件分解抽象以模块的方式组织代码。在之后的源码阅读中可以从其核心模块代理开始，逐步转换到业务模块管理者，再跳转到具体的业务模块实现。","categories":[{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/categories/NGINX/"}],"tags":[{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/tags/NGINX/"}]}],"categories":[{"name":"tools","slug":"tools","permalink":"https://juzipeek.github.io/categories/tools/"},{"name":"Network","slug":"Network","permalink":"https://juzipeek.github.io/categories/Network/"},{"name":"Lua","slug":"Lua","permalink":"https://juzipeek.github.io/categories/Lua/"},{"name":"Linux","slug":"Linux","permalink":"https://juzipeek.github.io/categories/Linux/"},{"name":"Go","slug":"Go","permalink":"https://juzipeek.github.io/categories/Go/"},{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/categories/C/"},{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/categories/NGINX/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://juzipeek.github.io/tags/nginx/"},{"name":"openresty","slug":"openresty","permalink":"https://juzipeek.github.io/tags/openresty/"},{"name":"systemtap","slug":"systemtap","permalink":"https://juzipeek.github.io/tags/systemtap/"},{"name":"flamegraph","slug":"flamegraph","permalink":"https://juzipeek.github.io/tags/flamegraph/"},{"name":"lua","slug":"lua","permalink":"https://juzipeek.github.io/tags/lua/"},{"name":"wrk","slug":"wrk","permalink":"https://juzipeek.github.io/tags/wrk/"},{"name":"ss","slug":"ss","permalink":"https://juzipeek.github.io/tags/ss/"},{"name":"shadowsocks","slug":"shadowsocks","permalink":"https://juzipeek.github.io/tags/shadowsocks/"},{"name":"git","slug":"git","permalink":"https://juzipeek.github.io/tags/git/"},{"name":"network","slug":"network","permalink":"https://juzipeek.github.io/tags/network/"},{"name":"keepalived","slug":"keepalived","permalink":"https://juzipeek.github.io/tags/keepalived/"},{"name":"ip","slug":"ip","permalink":"https://juzipeek.github.io/tags/ip/"},{"name":"multi-cast","slug":"multi-cast","permalink":"https://juzipeek.github.io/tags/multi-cast/"},{"name":"tcp","slug":"tcp","permalink":"https://juzipeek.github.io/tags/tcp/"},{"name":"udp","slug":"udp","permalink":"https://juzipeek.github.io/tags/udp/"},{"name":"C","slug":"C","permalink":"https://juzipeek.github.io/tags/C/"},{"name":"Lua","slug":"Lua","permalink":"https://juzipeek.github.io/tags/Lua/"},{"name":"Linux","slug":"Linux","permalink":"https://juzipeek.github.io/tags/Linux/"},{"name":"USDT","slug":"USDT","permalink":"https://juzipeek.github.io/tags/USDT/"},{"name":"Dtrace","slug":"Dtrace","permalink":"https://juzipeek.github.io/tags/Dtrace/"},{"name":"eBPF","slug":"eBPF","permalink":"https://juzipeek.github.io/tags/eBPF/"},{"name":"Go","slug":"Go","permalink":"https://juzipeek.github.io/tags/Go/"},{"name":"gcache","slug":"gcache","permalink":"https://juzipeek.github.io/tags/gcache/"},{"name":"cache","slug":"cache","permalink":"https://juzipeek.github.io/tags/cache/"},{"name":"grpc-gateway","slug":"grpc-gateway","permalink":"https://juzipeek.github.io/tags/grpc-gateway/"},{"name":"CPP","slug":"CPP","permalink":"https://juzipeek.github.io/tags/CPP/"},{"name":"LevelDB","slug":"LevelDB","permalink":"https://juzipeek.github.io/tags/LevelDB/"},{"name":"SSDB","slug":"SSDB","permalink":"https://juzipeek.github.io/tags/SSDB/"},{"name":"asm","slug":"asm","permalink":"https://juzipeek.github.io/tags/asm/"},{"name":"coroutine","slug":"coroutine","permalink":"https://juzipeek.github.io/tags/coroutine/"},{"name":"NGINX","slug":"NGINX","permalink":"https://juzipeek.github.io/tags/NGINX/"},{"name":"HTTP2","slug":"HTTP2","permalink":"https://juzipeek.github.io/tags/HTTP2/"},{"name":"HTTP","slug":"HTTP","permalink":"https://juzipeek.github.io/tags/HTTP/"},{"name":"OpenResty","slug":"OpenResty","permalink":"https://juzipeek.github.io/tags/OpenResty/"},{"name":"Kong","slug":"Kong","permalink":"https://juzipeek.github.io/tags/Kong/"},{"name":"Valgrind","slug":"Valgrind","permalink":"https://juzipeek.github.io/tags/Valgrind/"},{"name":"Naxsi","slug":"Naxsi","permalink":"https://juzipeek.github.io/tags/Naxsi/"}]}